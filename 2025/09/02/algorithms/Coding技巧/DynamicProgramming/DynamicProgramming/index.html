<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="keywords" content="Hexo Theme Redefine">
    
    <meta name="author" content="ZaynPei">
    
    <!-- Completely eliminate flash of wrong theme -->
    <script>
        (function() {
            const THEME_KEY = "REDEFINE-THEME-STATUS";
            const DARK = "dark", LIGHT = "light";
            
            // Get preferred theme
            function getTheme() {
                try {
                    const saved = localStorage.getItem(THEME_KEY);
                    if (saved) {
                        const { isDark } = JSON.parse(saved);
                        return isDark ? DARK : LIGHT;
                    }
                } catch (e) {}
                
                return matchMedia("(prefers-color-scheme: dark)").matches ? DARK : LIGHT;
            }
            
            // Apply theme to document
            function applyTheme(theme) {
                const isDark = theme === DARK;
                const root = document.documentElement;
                
                // Set data attribute for CSS variables
                root.setAttribute("data-theme", theme);
                
                // Set classes for compatibility
                root.classList.add(theme);
                root.classList.remove(isDark ? LIGHT : DARK);
                root.style.colorScheme = theme;
            }
            
            // Initial application
            const theme = getTheme();
            applyTheme(theme);
            
            // Listen for system preference changes
            matchMedia("(prefers-color-scheme: dark)").addEventListener("change", ({ matches }) => {
                // Only update if using system preference (no localStorage entry)
                if (!localStorage.getItem(THEME_KEY)) {
                    applyTheme(matches ? DARK : LIGHT);
                }
            });
            
            // Set body classes once DOM is ready
            if (document.readyState !== "loading") {
                document.body.classList.add(theme + "-mode");
            } else {
                document.addEventListener("DOMContentLoaded", () => {
                    document.body.classList.add(theme + "-mode");
                    document.body.classList.remove((theme === DARK ? LIGHT : DARK) + "-mode");
                });
            }
        })();
    </script>
    
    <!-- Critical CSS to prevent flash -->
    <style>
        :root[data-theme="dark"] {
            --background-color: #202124;
            --background-color-transparent: rgba(32, 33, 36, 0.6);
            --second-background-color: #2d2e32;
            --third-background-color: #34353a;
            --third-background-color-transparent: rgba(32, 33, 36, 0.6);
            --primary-color: #0066CC;
            --first-text-color: #ffffff;
            --second-text-color: #eeeeee;
            --third-text-color: #bebec6;
            --fourth-text-color: #999999;
            --default-text-color: #bebec6;
            --invert-text-color: #373D3F;
            --border-color: rgba(255, 255, 255, 0.08);
            --selection-color: #0066CC;
            --shadow-color-1: rgba(255, 255, 255, 0.08);
            --shadow-color-2: rgba(255, 255, 255, 0.05);
        }
        
        :root[data-theme="light"] {
            --background-color: #fff;
            --background-color-transparent: rgba(255, 255, 255, 0.6);
            --second-background-color: #f8f8f8;
            --third-background-color: #f2f2f2;
            --third-background-color-transparent: rgba(241, 241, 241, 0.6);
            --primary-color: #0066CC;
            --first-text-color: #16171a;
            --second-text-color: #2f3037;
            --third-text-color: #5e5e5e;
            --fourth-text-color: #eeeeee;
            --default-text-color: #373D3F;
            --invert-text-color: #bebec6;
            --border-color: rgba(0, 0, 0, 0.08);
            --selection-color: #0066CC;
            --shadow-color-1: rgba(0, 0, 0, 0.08);
            --shadow-color-2: rgba(0, 0, 0, 0.05);
        }
        
        body {
            background-color: var(--background-color);
            color: var(--default-text-color);
        }
        
        /* Apply body classes as soon as DOM is ready */
        :root[data-theme="dark"] body {
            background-color: var(--background-color);
            color: var(--default-text-color);
        }
    </style>
    
    <!-- preconnect -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>

    
    <!--- Seo Part-->
    
    <link rel="canonical" href="https://zaynpei.github.io/2025/09/02/algorithms/coding技巧/dynamicprogramming/dynamicprogramming/"/>
    <meta name="robots" content="index,follow">
    <meta name="googlebot" content="index,follow">
    <meta name="revisit-after" content="1 days">
    
    
    
        
        <meta name="description" content="Hexo Theme Redefine, Redefine Your Hexo Journey.">
<meta property="og:type" content="article">
<meta property="og:title" content="动态规划(Dynamic Programming)">
<meta property="og:url" content="https://zaynpei.github.io/2025/09/02/algorithms/Coding%E6%8A%80%E5%B7%A7/DynamicProgramming/DynamicProgramming/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="Hexo Theme Redefine, Redefine Your Hexo Journey.">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://zaynpei.github.io/images/redefine-og.webp">
<meta property="article:published_time" content="2025-09-02T14:00:00.000Z">
<meta property="article:modified_time" content="2025-11-03T09:29:27.117Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="algorithms">
<meta property="article:tag" content="动态规划">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://zaynpei.github.io/images/redefine-og.webp">
    
    
    <!--- Icon Part-->
    <link rel="icon" type="image/png" href="/images/icons%E7%81%AF%E5%A1%94.png" sizes="192x192">
    <link rel="apple-touch-icon" sizes="180x180" href="/images/icons%E7%81%AF%E5%A1%94.png">
    <meta name="theme-color" content="#A31F34">
    <link rel="shortcut icon" href="/images/icons%E7%81%AF%E5%A1%94.png">
    <!--- Page Info-->
    
    <title>
        
            动态规划(Dynamic Programming) | ZaynPei&#39;s Base
        
    </title>

    
<link rel="stylesheet" href="/fonts/Chillax/chillax.css">


    <!--- Inject Part-->
    
        
            
    
            
    
            
                
                    <link rel="stylesheet" href="/css/custom.css">
                
    

    
<link rel="stylesheet" href="/css/style.css">


    
        
<link rel="stylesheet" href="/css/build/tailwind.css">

    

    
<link rel="stylesheet" href="/fonts/GeistMono/geist-mono.css">

    
<link rel="stylesheet" href="/fonts/Geist/geist.css">

    <!--- Font Part-->
    
    
        <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;700&display=swap" rel="stylesheet">
    
    
        <link href="https://cdn.jsdelivr.net/npm/@callmebill/lxgw-wenkai-web@1.320/style.css" rel="stylesheet">
    
    
    
    

    <script id="hexo-configurations">
    window.config = {"hostname":"zaynpei.github.io","root":"/","language":"en","path":"search.json"};
    window.theme = {"articles":{"style":{"font_size":"16px","line_height":1.5,"image_border_radius":"14px","image_alignment":"center","image_caption":false,"link_icon":true,"delete_mask":false,"title_alignment":"left","headings_top_spacing":{"h1":"3.2rem","h2":"2.4rem","h3":"1.9rem","h4":"1.6rem","h5":"1.4rem","h6":"1.3rem"}},"word_count":{"enable":true,"count":true,"min2read":true},"author_label":{"enable":true,"auto":false,"list":[]},"code_block":{"copy":true,"style":"mac","highlight_theme":{"light":"default","dark":"a11y-dark"},"font":{"enable":true,"family":"'JetBrains Mono', monospace","url":"https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;700&display=swap"}},"toc":{"enable":true,"max_depth":6,"number":false,"expand":true,"init_open":true},"copyright":{"enable":false,"default":"cc_by_nc_sa"},"lazyload":true,"pangu_js":false,"recommendation":{"enable":false,"title":"推荐阅读","limit":3,"mobile_limit":2,"placeholder":"/images/wallhaven-wqery6-light.webp","skip_dirs":[]},"font":{"enable":true,"url":"https://cdn.jsdelivr.net/npm/@callmebill/lxgw-wenkai-web@1.320/style.css","family":"'LXGW WenKai', sans-serif"}},"colors":{"primary":"#A31F34","secondary":null,"default_mode":"light"},"global":{"fonts":{"chinese":{"enable":true,"family":"'LXGW WenKai', sans-serif","url":"https://cdn.jsdelivr.net/npm/@callmebill/lxgw-wenkai-web@1.320/style.css"},"english":{"enable":false,"family":null,"url":null},"title":{"enable":false,"family":null,"url":null}},"content_max_width":"1000px","sidebar_width":"210px","hover":{"shadow":true,"scale":false},"scroll_progress":{"bar":false,"percentage":true},"website_counter":{"url":"https://cn.vercount.one/js","enable":false,"site_pv":true,"site_uv":true,"post_pv":true},"single_page":true,"preloader":{"enable":false,"custom_message":null},"side_tools":{"gear_rotation":true,"auto_expand":false},"open_graph":{"enable":true,"image":"/images/redefine-og.webp","description":"Hexo Theme Redefine, Redefine Your Hexo Journey."},"google_analytics":{"enable":false,"id":null}},"home_banner":{"enable":true,"style":"fixed","image":{"light":"/images/wallhaven-wqery6-light.webp","dark":"/images/wallhaven-wqery6-dark.webp"},"title":"For ourselves","subtitle":{"text":["For yourself"],"hitokoto":{"enable":false,"show_author":false,"api":"https://v1.hitokoto.cn"},"typing_speed":100,"backing_speed":80,"starting_delay":500,"backing_delay":1500,"loop":true,"smart_backspace":true},"text_color":{"light":"#fff","dark":"#d1d1b6"},"text_style":{"title_size":"2.8rem","subtitle_size":"1.5rem","line_height":1.2},"custom_font":{"enable":false,"family":null,"url":null},"social_links":{"enable":false,"style":"default","links":{"github":null,"instagram":null,"zhihu":null,"twitter":null,"email":null},"qrs":{"weixin":null}}},"plugins":{"feed":{"enable":false},"aplayer":{"enable":false,"type":"fixed","audios":[{"name":null,"artist":null,"url":null,"cover":null,"lrc":null}]},"mermaid":{"enable":false,"version":"11.4.1"}},"version":"2.8.5","navbar":{"auto_hide":false,"color":{"left":"#f78736","right":"#367df7","transparency":35},"width":{"home":"1200px","pages":"1000px"},"links":{"Home":{"path":"/","icon":"fa-regular fa-house"},"ai":{"path":"docs/ai/","icon":"fa-regular fa-robot"},"algorithms":{"path":"docs/algorithms/","icon":"fa-regular fa-code"},"language":{"path":"docs/lang/","icon":"fa-regular fa-language"},"system":{"path":"docs/system/","icon":"fa-regular fa-desktop"},"web":{"path":"docs/web/","icon":"fa-regular fa-globe"},"misc":{"path":"docs/misc/","icon":"fa-regular fa-boxes-stacked"},"tools":{"path":"docs/tools/","icon":"fa-regular fa-wrench"}},"search":{"enable":true,"preload":true}},"page_templates":{"friends_column":2,"tags_style":"blur"},"home":{"sidebar":{"enable":true,"position":"left","first_item":"menu","announcement":null,"show_on_mobile":true,"links":null},"article_date_format":"auto","excerpt_length":200,"categories":{"enable":true,"limit":3},"tags":{"enable":true,"limit":3}},"footerStart":"2025/6/25 13:20:00"};
    window.lang_ago = {"second":"%s seconds ago","minute":"%s minutes ago","hour":"%s hours ago","day":"%s days ago","week":"%s weeks ago","month":"%s months ago","year":"%s years ago"};
    window.data = {"masonry":false};
  </script>
    
    <!--- Fontawesome Part-->
    
<link rel="stylesheet" href="/fontawesome/fontawesome.min.css">

    
<link rel="stylesheet" href="/fontawesome/brands.min.css">

    
<link rel="stylesheet" href="/fontawesome/solid.min.css">

    
<link rel="stylesheet" href="/fontawesome/regular.min.css">

    
    
    
    
<meta name="generator" content="Hexo 7.3.0"><style>mjx-container[jax="SVG"] {
  direction: ltr;
}

mjx-container[jax="SVG"] > svg {
  overflow: visible;
}

mjx-container[jax="SVG"][display="true"] {
  display: block;
  text-align: center;
  margin: 1em 0;
}

mjx-container[jax="SVG"][justify="left"] {
  text-align: left;
}

mjx-container[jax="SVG"][justify="right"] {
  text-align: right;
}

g[data-mml-node="merror"] > g {
  fill: red;
  stroke: red;
}

g[data-mml-node="merror"] > rect[data-background] {
  fill: yellow;
  stroke: none;
}

g[data-mml-node="mtable"] > line[data-line] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > rect[data-frame] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > .mjx-dashed {
  stroke-dasharray: 140;
}

g[data-mml-node="mtable"] > .mjx-dotted {
  stroke-linecap: round;
  stroke-dasharray: 0,140;
}

g[data-mml-node="mtable"] > svg {
  overflow: visible;
}

[jax="SVG"] mjx-tool {
  display: inline-block;
  position: relative;
  width: 0;
  height: 0;
}

[jax="SVG"] mjx-tool > mjx-tip {
  position: absolute;
  top: 0;
  left: 0;
}

mjx-tool > mjx-tip {
  display: inline-block;
  padding: .2em;
  border: 1px solid #888;
  font-size: 70%;
  background-color: #F8F8F8;
  color: black;
  box-shadow: 2px 2px 5px #AAAAAA;
}

g[data-mml-node="maction"][data-toggle] {
  cursor: pointer;
}

mjx-status {
  display: block;
  position: fixed;
  left: 1em;
  bottom: 1em;
  min-width: 25%;
  padding: .2em .4em;
  border: 1px solid #888;
  font-size: 90%;
  background-color: #F8F8F8;
  color: black;
}

foreignObject[data-mjx-xml] {
  font-family: initial;
  line-height: normal;
  overflow: visible;
}

.MathJax path {
  stroke-width: 3;
}

mjx-container[display="true"] {
  overflow: auto hidden;
}

mjx-container[display="true"] + br {
  display: none;
}
</style></head>



<body>
	<div class="progress-bar-container">
	

	
	<span class="pjax-progress-bar"></span>
	<!--        <span class="swup-progress-icon">-->
	<!--            <i class="fa-solid fa-circle-notch fa-spin"></i>-->
	<!--        </span>-->
	
</div>

<main class="page-container" id="swup">

	

	<div class="main-content-container flex flex-col justify-between min-h-dvh">
		<div class="main-content-header">
			<header class="navbar-container px-6 md:px-12">
    <div class="navbar-content transition-navbar ">
        <div class="left">
            
                <a class="logo-image h-8 w-8 sm:w-10 sm:h-10 mr-3" href="/">
                    <img src="/images/icons%E7%81%AF%E5%A1%94.png" class="w-full h-full rounded-xs">
                </a>
            
            <a class="logo-title" href="/">
                
                ZaynPei&#39;s Base
                
            </a>
        </div>

        <div class="right">
            <!-- PC -->
            <div class="desktop">
                <ul class="navbar-list">
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class=""
                                   href="/"
                                        >
                                    <i class="fa-regular fa-house fa-fw"></i>
                                    HOME
                                    
                                </a>

                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class=""
                                   href="/docs/ai/"
                                        >
                                    <i class="fa-regular fa-robot fa-fw"></i>
                                    AI
                                    
                                </a>

                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class=""
                                   href="/docs/algorithms/"
                                        >
                                    <i class="fa-regular fa-code fa-fw"></i>
                                    ALGORITHMS
                                    
                                </a>

                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class=""
                                   href="/docs/lang/"
                                        >
                                    <i class="fa-regular fa-language fa-fw"></i>
                                    LANGUAGE
                                    
                                </a>

                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class=""
                                   href="/docs/system/"
                                        >
                                    <i class="fa-regular fa-desktop fa-fw"></i>
                                    SYSTEM
                                    
                                </a>

                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class=""
                                   href="/docs/web/"
                                        >
                                    <i class="fa-regular fa-globe fa-fw"></i>
                                    WEB
                                    
                                </a>

                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class=""
                                   href="/docs/misc/"
                                        >
                                    <i class="fa-regular fa-boxes-stacked fa-fw"></i>
                                    MISC
                                    
                                </a>

                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class=""
                                   href="/docs/tools/"
                                        >
                                    <i class="fa-regular fa-wrench fa-fw"></i>
                                    TOOLS
                                    
                                </a>

                                <!-- Submenu -->
                                
                            </li>
                    
                    
                        <li class="navbar-item search search-popup-trigger">
                            <i class="fa-solid fa-magnifying-glass"></i>
                        </li>
                    
                </ul>
            </div>
            <!-- Mobile -->
            <div class="mobile">
                
                    <div class="icon-item search search-popup-trigger"><i class="fa-solid fa-magnifying-glass"></i>
                    </div>
                
                <div class="icon-item navbar-bar">
                    <div class="navbar-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Mobile sheet -->
    <div class="navbar-drawer h-dvh w-full absolute top-0 left-0 bg-background-color flex flex-col justify-between">
        <ul class="drawer-navbar-list flex flex-col px-4 justify-center items-start">
            
                
                    

                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                           href="/"
                        >
                            <span>
                                HOME
                            </span>
                            
                                <i class="fa-regular fa-house fa-sm fa-fw"></i>
                            
                        </a>
                        

                        
                    </li>
            
                
                    

                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                           href="/docs/ai/"
                        >
                            <span>
                                AI
                            </span>
                            
                                <i class="fa-regular fa-robot fa-sm fa-fw"></i>
                            
                        </a>
                        

                        
                    </li>
            
                
                    

                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                           href="/docs/algorithms/"
                        >
                            <span>
                                ALGORITHMS
                            </span>
                            
                                <i class="fa-regular fa-code fa-sm fa-fw"></i>
                            
                        </a>
                        

                        
                    </li>
            
                
                    

                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                           href="/docs/lang/"
                        >
                            <span>
                                LANGUAGE
                            </span>
                            
                                <i class="fa-regular fa-language fa-sm fa-fw"></i>
                            
                        </a>
                        

                        
                    </li>
            
                
                    

                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                           href="/docs/system/"
                        >
                            <span>
                                SYSTEM
                            </span>
                            
                                <i class="fa-regular fa-desktop fa-sm fa-fw"></i>
                            
                        </a>
                        

                        
                    </li>
            
                
                    

                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                           href="/docs/web/"
                        >
                            <span>
                                WEB
                            </span>
                            
                                <i class="fa-regular fa-globe fa-sm fa-fw"></i>
                            
                        </a>
                        

                        
                    </li>
            
                
                    

                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                           href="/docs/misc/"
                        >
                            <span>
                                MISC
                            </span>
                            
                                <i class="fa-regular fa-boxes-stacked fa-sm fa-fw"></i>
                            
                        </a>
                        

                        
                    </li>
            
                
                    

                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                           href="/docs/tools/"
                        >
                            <span>
                                TOOLS
                            </span>
                            
                                <i class="fa-regular fa-wrench fa-sm fa-fw"></i>
                            
                        </a>
                        

                        
                    </li>
            

            
            
        </ul>

        <div class="statistics flex justify-around my-2.5">
    <a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/tags">
        <div class="number text-2xl sm:text-xl text-second-text-color font-semibold">19</div>
        <div class="label text-third-text-color text-sm">Tags</div>
    </a>
    <a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/categories">
        <div class="number text-2xl sm:text-xl text-second-text-color font-semibold">21</div>
        <div class="label text-third-text-color text-sm">Categories</div>
    </a>
    <a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/archives">
        <div class="number text-2xl sm:text-xl text-second-text-color font-semibold">193</div>
        <div class="label text-third-text-color text-sm">Posts</div>
    </a>
</div>
    </div>

    <div class="window-mask"></div>

</header>


		</div>

		<div class="main-content-body transition-fade-up">
			

			<div class="main-content">
				<div class="post-page-container flex relative justify-between box-border w-full h-full">
	<div class="article-content-container">

		<div class="article-title relative w-full">
			
			<div class="w-full flex items-center pt-6 justify-start">
				<h1 class="article-title-regular text-second-text-color tracking-tight text-4xl md:text-6xl font-semibold px-2 sm:px-6 md:px-8 py-3">动态规划(Dynamic Programming)</h1>
			</div>
			
		</div>

		
		<div class="article-header flex flex-row gap-2 items-center px-2 sm:px-6 md:px-8">
			<div class="avatar w-[46px] h-[46px] flex-shrink-0 rounded-medium border border-border-color p-[1px]">
				<img src="/images/redefine-avatar.svg">
			</div>
			<div class="info flex flex-col justify-between">
				<div class="author flex items-center">
					<span class="name text-default-text-color text-lg font-semibold">ZaynPei</span>
					
					<span class="author-label ml-1.5 text-xs px-2 py-0.5 rounded-small text-third-text-color border border-shadow-color-1">Lv6</span>
					
				</div>
				<div class="meta-info">
					<div class="article-meta-info">
    <span class="article-date article-meta-item">
        <i class="fa-regular fa-pen-fancy"></i>&nbsp;
        <span class="desktop">2025-09-02 22:00</span>
        <span class="mobile">2025-09-02 22:00</span>
        <span class="hover-info">Created</span>
    </span>
    
        <span class="article-date article-meta-item">
            <i class="fa-regular fa-wrench"></i>&nbsp;
            <span class="desktop">2025-11-03 17:29:27</span>
            <span class="mobile">2025-11-03 17:29:27</span>
            <span class="hover-info">Updated</span>
        </span>
    

    
        <span class="article-categories article-meta-item">
            <i class="fa-regular fa-folders"></i>&nbsp;
            <ul>
                
                
                    
                        
                        <li>
                            <a href="/categories/algorithms/">algorithms</a>&nbsp;
                        </li>
                    
                    
                
            </ul>
        </span>
    
    
        <span class="article-tags article-meta-item">
            <i class="fa-regular fa-tags"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/tags/algorithms/">algorithms</a>&nbsp;
                    </li>
                
                    <li>
                        | <a href="/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/">动态规划</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    

    
    
        <span class="article-wordcount article-meta-item">
            <i class="fa-regular fa-typewriter"></i>&nbsp;<span>11.7k Words</span>
        </span>
    
    
        <span class="article-min2read article-meta-item">
            <i class="fa-regular fa-clock"></i>&nbsp;<span>47 Mins</span>
        </span>
    
    
</div>

				</div>
			</div>
		</div>
		

		


		<div class="article-content markdown-body px-2 sm:px-6 md:px-8 pb-8">
			<p>动态规划（Dynamic Programming, DP）
是一种通过将复杂问题分解为更小的、<strong>重叠的子问题</strong>来求解的算法思想。它与分治法（Divide
and
Conquer）有些相似，但不同之处在于，动态规划适用于子问题重叠的场景，即不同的子问题会共享更小的子子问题。</p>
<p>DP的核心思想是 “<strong>记忆化</strong>” 或
“<strong>表格法</strong>”，即计算过一次的子问题的解，就将其存储起来，避免重复计算。这是一种典型的
“空间换时间”
的策略，通过使用额外的内存来存储中间结果，从而显著降低计算的时间复杂度。</p>
<h3 id="适用条件">适用条件</h3>
<p>一个问题能否使用动态规划来解决，通常取决于它是否满足以下三个核心特征：</p>
<p><strong>最优子结构</strong> (Optimal Substructure)</p>
<ul>
<li><p><strong>问题的最优解包含其子问题的最优解</strong>。换句话说，我们可以通过组合子问题的最优解来构造出原问题的最优解。</p></li>
<li><p>例如：在最短路径问题中，从A到C的最短路径，如果经过B点，那么这条路径中从A到B的部分也必然是A到B的最短路径。</p></li>
</ul>
<p><strong>重叠子问题</strong> (Overlapping Subproblems)</p>
<ul>
<li><p>在问题的求解过程中，许多子问题会被反复计算。DP的威力正体现在此，它通过<strong>存储已解决的子问题的答案</strong>来避免这种不必要的重复计算。</p></li>
<li><p>例如：在计算斐波那契数列时，F(5) 依赖 F(4) 和 F(3)，而 F(4) 依赖
F(3) 和 F(2)。F(3) 就是一个被重复计算的重叠子问题。</p></li>
</ul>
<p><strong>无后效性</strong> (No Aftereffect)</p>
<ul>
<li>一旦某个阶段的状态确定，它就不会再被后续的决策所改变。<strong>当前状态只与之前的状态有关</strong>，而与之后的状态无关。我们做的每一个决策都是基于当前已有的信息，而不用担心未来的决策会反过来影响当前决策的正确性。</li>
</ul>
<h3 id="解题步骤">解题步骤</h3>
<p>解决一个动态规划问题，通常可以遵循以下四个步骤，这是一个系统性的思考框架。</p>
<p><strong>第一步：定义状态</strong></p>
<p>这是动态规划中最关键，也往往是最困难的一步。状态定义需要清晰、无歧义，并且能够涵盖解决问题所需的所有信息。</p>
<p>一个常见且可行的操作是创建一个数组（通常称为 <strong>dp
数组</strong>），并明确 dp[i] 或 dp[i][j] 代表什么。</p>
<ul>
<li>例如：在计算斐波那契数列时，dp[i] 可能代表“第i个斐波那契数”。</li>
<li>例如：在爬楼梯问题中，dp[i] 可能代表“爬到第i级台阶的方法数”。</li>
<li>例如：在背包问题中，dp[i][j]
可能代表“前i个物品在容量为j的背包中的最大价值”。</li>
</ul>
<p>状态的定义必须能够帮助我们推导出最终的答案。一个好的状态定义是成功的一半。</p>
<p><strong>第二步：确定状态转移方程</strong></p>
<p>状态转移方程是动态规划的核心，它描述了不同状态之间是如何关联和演进的。</p>
<p>具体而言, 我们需要找出 dp[i] 与 dp[i-1], dp[i-2], …
等之前状态的关系。</p>
<p>这个方程是问题的数学模型。它告诉我们如何利用已知的子问题的解来计算出当前问题的解。例如，爬楼梯问题中，爬到第
i 级台阶的方法数等于爬到第 i-1 级和第 i-2
级的方法数之和，其状态转移方程就是 <span class="math inline"><em>d</em><em>p</em>[<em>i</em>] = <em>d</em><em>p</em>[<em>i</em> − 1] + <em>d</em><em>p</em>[<em>i</em> − 2]</span>。</p>
<p><strong>第三步：初始化</strong></p>
<p>任何递推关系都需要一个或多个起点，这就是初始状态。</p>
<p>我们需要根据状态定义，为 dp 数组中的基础情况（base case）赋初值。</p>
<p>例如，在斐波那契数列中，<span class="math inline"><em>d</em><em>p</em>[0] = 0, <em>d</em><em>p</em>[1] = 1</span>
就是初始状态。如果初始化错误，后续的所有计算都会是错误的。</p>
<p><strong>第四步：确定遍历顺序</strong></p>
<p>根据状态转移方程，我们需要确定计算 dp 数组的顺序,
也就是决定循环是从前向后还是从后向前，或者对于二维数组是逐行还是逐列。</p>
<p>遍历顺序必须保证，在计算 dp[i] 时，所有它所依赖的状态（如
dp[i-1]）都已经计算出来了。这通常意味着从小规模的问题向大规模问题进行迭代。</p>
<h3 id="两种模式">两种模式</h3>
<p>动态规划 (Dynamic Programming, DP)
的核心是将一个大问题分解成若干个子问题，并存储子问题的解以避免重复计算。它主要有两种实现方式：</p>
<ul>
<li><p>自顶向下 (Top-Down) DP：通常通过 递归 + 记忆化 来实现。</p></li>
<li><p>自底向上 (Bottom-Up) DP：通常通过 迭代 + 表格 来实现。</p></li>
</ul>
<ol type="1">
<li>自顶向下 (Top-Down) 动态规划 — 记忆化搜索</li>
</ol>
<p>这种方法也称为 记忆化搜索
(Memoization)。核心思想是从我们最终要求解的<strong>大问题出发</strong>，通过<strong>递归</strong>函数去解决它。如果在这个过程中遇到了一个子问题，我们先检查是否已经计算过这个子问题（即“记忆”里有没有）。</p>
<p>如果计算过，直接从“记忆”中取出答案;
如果没有计算过，就递归地去解决这个子问题，并将计算出的结果存入“记忆”中，以备后用。</p>
<p>这个过程就像是从树的顶部（根节点，即原始问题）开始，向下探索到树的底部（叶子节点，即最小的子问题）。</p>
<ol start="2" type="1">
<li><strong>自底向上</strong> (Bottom-Up) 动态规划 — 表格法</li>
</ol>
<p>这种方法也称为 表格法
(Tabulation)。核心思想完全反过来，我们不从大问题开始，而是从能够直接求解的、<strong>最小的子问题开始</strong>。然后利用这些小问题的解，像搭积木一样，一步步地构建出更大问题的解，直到最终解决了我们想要的那个大问题。</p>
<p>这个过程通常用一个数组或矩阵（我们称之为 dp
表）来完成，通过迭代（for循环）的方式，按照从小到大的顺序填充表格。</p>
<table>
<colgroup>
<col style="width: 33%">
<col style="width: 33%">
<col style="width: 33%">
</colgroup>
<thead>
<tr>
<th>特征 (Feature)</th>
<th>自顶向下 (Top-Down)</th>
<th>自底向上 (Bottom-Up)</th>
</tr>
</thead>
<tbody>
<tr>
<td>实现方式</td>
<td>递归 + 记忆化 (Memoization)</td>
<td>迭代 + 表格法 (Tabulation)</td>
</tr>
<tr>
<td>思路方向</td>
<td>从 大问题 分解到 小问题</td>
<td>从 小问题 构建到 大问题</td>
</tr>
<tr>
<td>子问题计算</td>
<td>按需计算：只计算解决最终问题所必需的子问题。</td>
<td>计算所有：通常会计算出所有可能的子问题的解。</td>
</tr>
<tr>
<td>代码直观性</td>
<td>通常更符合人类的直觉，因为其逻辑直接遵循问题的递归定义。</td>
<td>可能需要更仔细地设计循环和状态转移的顺序。</td>
</tr>
<tr>
<td>性能</td>
<td>可能会因递归深度过大导致栈溢出。函数调用有一定开销。</td>
<td>没有递归开销，通常性能略好一些。</td>
</tr>
</tbody>
</table>
<h3 id="二维降一维">二维降一维</h3>
<p>在动态规划中，很多问题的状态可以用二维数组来表示，例如 dp[i][j]
代表某个子问题的解。然而，二维数组往往会占用较多的空间，有时我们可以通过观察状态转移方程，发现某些情况下，<strong>当前状态只依赖于前一行或前一列的状态</strong>，从而将二维数组优化为一维数组(节省了空间,
但是循环仍旧是二维的)。</p>
<p>例如, 在某道题的二维 DP 中，状态转移方程是：</p>
<p><span class="math inline"><em>d</em><em>p</em>[<em>i</em>][<em>j</em>] = <em>d</em><em>p</em>[<em>i</em> − 1][<em>j</em>] + <em>d</em><em>p</em>[<em>i</em>][<em>j</em> − 1]</span></p>
<p>这个公式告诉我们，要计算当前单元格 (i, j)
的路径数，我们只需要它正上方的单元格 (i-1, j) 和它正左方的单元格 (i,
j-1) 的路径数。</p>
<p>这意味着，当我们在<strong>计算第 i
行</strong>的数据时，我们实际上<strong>只用到了第 i-1
行</strong>（上一行）和<strong>当前行但是前一个</strong>的数据。更早的行（如第
i-2 行、第 i-3 行）的数据已经不再需要了。</p>
<p>因此，我们没有必要存储整个 m×n
的二维表格，这造成了空间浪费。我们可以用一个一维数组来“<strong>滚动</strong>”计算，从而将空间复杂度从
O(m×n) 优化到
O(n)。这个一维数组在每次迭代中，都保存着“上一行”的计算结果。</p>
<p>原代码：</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span> </span>{</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(m, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> i,j;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;n;i++){</span><br><span class="line">            dp[<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;m;i++){</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;m;i++){</span><br><span class="line">            <span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;n;j++){</span><br><span class="line">                dp[i][j] = dp[i<span class="number">-1</span>][j] + dp[i][j<span class="number">-1</span>];</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> dp[m<span class="number">-1</span>][n<span class="number">-1</span>];</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></table></figure></div>
<p>优化后：</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span> </span>{</span><br><span class="line">        <span class="comment">// 1. 初始化</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n, <span class="number">1</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 遍历行</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; m; j++) {</span><br><span class="line">            <span class="comment">// 3. 遍历列</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) {</span><br><span class="line">                <span class="comment">// 4. 状态转移</span></span><br><span class="line">                dp[i] += dp[i - <span class="number">1</span>];</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 5. 返回结果</span></span><br><span class="line">        <span class="keyword">return</span> dp[n - <span class="number">1</span>];</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></table></figure></div>
<p>第一步是创建一个大小为 n (网格的列数) 的一维数组
dp，并将其所有元素初始化为 1。</p>
<p>这步操作相当于计算了二维网格中第一行
的所有路径数。对于第一行的任何一个单元格 (0,
j)，都只有一条路径可以到达，那就是从起点 (0, 0) 一直向右走。所以
dp[0][j] 恒为 1。</p>
<p>dp 数组此时的状态是 {1, 1, 1, …, 1}，代表了第一行 m=0
时每个位置的路径数。</p>
<p>接着每一次外层循环的开始，dp 数组里存储的都是 <strong>上一行
(j-1)</strong> 的计算结果。我们的目标是在这次循环中，利用这些结果计算出
当前行 (j) 的结果，并更新 dp 数组。</p>
<p>这一步是核心: dp[i] += dp[i - 1];</p>
<p>在执行 dp[i] += dp[i-1] 这行代码时：</p>
<ul>
<li><p><strong>= 左边的 dp[i]</strong>：它里面存储的还是
<strong>上一行</strong>
的值，因为<strong>它在本次内层循环中还没有被更新</strong>。这正好对应二维公式中的
dp [j−1][i] (来自上方的路径)。</p></li>
<li><p><strong>= 右边的
dp[i-1]</strong>：它在<strong>本次内层循环的上一步</strong> (i 的值还是
i-1 时) 已经被更新了。所以它存储的是
当前行<strong>左边单元格</strong>的值。这正好对应二维公式中的 dp
[j][i−1] (来自左方的路径)。</p></li>
</ul>
<p>因此，dp[i] += dp[i-1] 就等价于： <span class="math display"><em>d</em><em>p</em>[<em>i</em>]<sub>新</sub> = <em>d</em><em>p</em>[<em>i</em>]<sub>旧</sub> + <em>d</em><em>p</em>[<em>i</em> − 1]<sub>新</sub></span></p>
<p>这完美地实现了二维状态转移方程的功能，但只用了一个一维数组。</p>
<h3 id="例题">例题</h3>
<h4 id="例题2-单词拆分">例题2: 单词拆分</h4>
<p>给你一个字符串 s 和一个字符串列表 wordDict
作为字典。如果可以利用字典中出现的一个或多个单词拼接出 s 则返回
true。注意：不要求字典中出现的单词全部都使用，并且字典中的单词可以重复使用。</p>
<p>示例 1： 输入: s = “leetcode”, wordDict = [“leet”, “code”] 输出: true
解释: 返回 true 因为 “leetcode” 可以由 “leet” 和 “code” 拼接成。</p>
<p>示例 2： 输入: s = “applepenapple”, wordDict = [“apple”, “pen”] 输出:
true 解释: 返回 true 因为 “applepenapple” 可以由 “apple” “pen” “apple”
拼接成。</p>
<p>示例 3： 输入: s = “catsandog”, wordDict = [“cats”, “dog”, “sand”,
“and”, “cat”] 输出: false</p>
<details class="green" data-header-exclude>
    <summary><i class="fa-solid fa-chevron-right"></i>思路 1 </summary>
    <div class="content markdown-body">
      <p>采取动态规划的思路, 要解决s能否被组合, 我们得考虑比s更小的子问题,
即s的子串是否能被组合. 基于此, 一个思路便产生了: dp[i]
代表s[0:i]是否能被wordDict中的单词组合而成. 那么为了推导dp[i],
我们需要考虑所有可能的分段方式, 即s[0:j]和s[j+1:i]两部分的组合情况,
只要存在某个j使得dp[j]为true且s[j+1:i]在wordDict中, 那么dp[i]就为true.
当然, 还要考虑s[0:i]本身在wordDict中的情况. 基本代码如下:
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">wordBreak</span><span class="params">(string s, vector&lt;string&gt;&amp; wordDict)</span> </span>{</span><br><span class="line">       <span class="type">size_t</span> n = s.<span class="built_in">length</span>();</span><br><span class="line">       <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">dp</span><span class="params">(n,<span class="literal">false</span>)</span></span>;</span><br><span class="line">       <span class="function">unordered_set&lt;string&gt; <span class="title">set</span><span class="params">(wordDict.begin(), wordDict.end())</span></span>;</span><br><span class="line">       dp[<span class="number">0</span>] = set.<span class="built_in">contains</span>(<span class="built_in">string</span>(<span class="number">1</span>, s[<span class="number">0</span>]))? <span class="literal">true</span>:<span class="literal">false</span>;</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++){</span><br><span class="line">           <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;i;j++){</span><br><span class="line">               <span class="keyword">if</span>(dp[j]&amp;&amp;set.<span class="built_in">contains</span>(s.<span class="built_in">substr</span>(j<span class="number">+1</span>,i-j))){</span><br><span class="line">                   dp[i] = <span class="literal">true</span>;</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">               }</span><br><span class="line">           }</span><br><span class="line">           <span class="keyword">if</span>(set.<span class="built_in">contains</span>(s.<span class="built_in">substr</span>(<span class="number">0</span>,i<span class="number">+1</span>))) dp[i] = <span class="literal">true</span>;</span><br><span class="line">       }</span><br><span class="line">       <span class="keyword">return</span> dp[n<span class="number">-1</span>];</span><br><span class="line">   }</span><br></pre></td></tr></table></figure></div></p>
<p>上面的解法将 dp[i] 含义定义为了下标 i 处的字符包含在内的子串 s[0:i]
是否能被 wordDict 中的单词拼接而成。然而，这种定义导致在计算 dp[i]
时，我们遍历后还需要额外检查 s[0:i] 本身是否在 wordDict
中，这增加了不必要的复杂性。</p>
<p>因此, 我们可以定义一个一维的数组dp[i]表示字符串 s 中，<strong>长度为
i 的前缀</strong>（即子串 s[0…i-1]）是否可以被字典中的单词拼接而成,
而dp[i]拆分为的两部分不必都是dp数组(从而造成冗余),如果满足以下两个条件，那么
dp[i] 就可以是 true：</p>
<ul>
<li>dp[j] 是 true：这说明从字符串开头到 j 点的这一段前缀 s[0…j-1]
已经被成功拼接了。</li>
<li>从 j 到 i 的这一段子串 s.substr(j, i-j)
本身就是字典里的一个单词。</li>
</ul>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">wordBreak</span><span class="params">(string s, vector&lt;string&gt;&amp; wordDict)</span> </span>{</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">length</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 将字典转为哈希集合，提高查询效率</span></span><br><span class="line">        <span class="comment">// std::find 在 vector 上是 O(N)，在 unordered_set 上是 O(1)</span></span><br><span class="line">        <span class="function">unordered_set&lt;string&gt; <span class="title">wordSet</span><span class="params">(wordDict.begin(), wordDict.end())</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 定义 dp 数组，大小为 n+1</span></span><br><span class="line">        <span class="comment">// dp[i] 表示 s 的前 i 个字符能否被拼接</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>, <span class="literal">false</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 初始化初值</span></span><br><span class="line">        <span class="comment">// dp[0] 表示空字符串，是合法的起点</span></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 构建递推</span></span><br><span class="line">        <span class="comment">// 外层循环遍历所有前缀长度 i，从 1 到 n</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) {</span><br><span class="line">            <span class="comment">// 内层循环遍历所有可能的分割点 j</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; ++j) {</span><br><span class="line">                <span class="comment">// 如果 dp[j] 为 true，并且 s[j...i-1] 是一个字典词</span></span><br><span class="line">                <span class="keyword">if</span> (dp[j] &amp;&amp; wordSet.<span class="built_in">count</span>(s.<span class="built_in">substr</span>(j, i - j))) {</span><br><span class="line">                    dp[i] = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>; <span class="comment">// 找到了一个可行方案，无需再检查其他分割点 j</span></span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></table></figure></div>

    </div>
  </details>
<h4 id="例题3-0-1背包问题">例题3: 0-1背包问题</h4>
<blockquote>
<p>背包问题指的是对于有 n 件物品和一个容量为 V 的背包。每件物品 i
有一个重量 w[i] 和一个价值
v[i]。求解在不超过背包容量的前提下，能够装入背包的物品的最大总价值。</p>
</blockquote>
<p>而根据每件物品的数量和是否可以重复选择，背包问题可以分为以下几种类型：
<img lazyload src="/images/loading.svg" data-src="image.png" alt="alt text"></p>
<p>现阶段我们主要考虑的是0-1背包和完全背包,
完全背包又是由0-1背包演化而来, 因此0-1背包是重点</p>
<ol type="1">
<li><p>状态定义: 0-1背包问题的状态定义为: dp[i][j] 代表前 i
件物品可选的情况下, 放入容量为 j 的背包可以获得的最大价值</p></li>
<li><p>初始化: dp[i][0] = 0, dp[0][j] = j&gt;w[0]?value[0]:0</p></li>
<li><p>状态转移方程: <span class="math display"><em>d</em><em>p</em>[<em>i</em>][<em>j</em>] = <em>m</em><em>a</em><em>x</em>(<em>d</em><em>p</em>[<em>i</em> − 1][<em>j</em>], <em>d</em><em>p</em>[<em>i</em> − 1][<em>j</em> − <em>w</em><em>e</em><em>i</em><em>g</em><em>h</em><em>t</em>[<em>i</em>]] + <em>v</em><em>a</em><em>l</em><em>u</em><em>e</em>[<em>i</em>])(<em>j</em> &gt;  = <em>w</em><em>e</em><em>i</em><em>g</em><em>h</em><em>t</em>[<em>i</em>])</span></p></li>
</ol>
<p>以上过程，抽象化如下：对于第 i 件物品和容量为 j
的背包，最大价值有两种选择可以到达： -
<strong>不放物品i</strong>：背包容量为j，里面不放物品i的最大价值是dp[i -
1][j]。 - <strong>放物品i</strong>：背包空出物品i的容量后，背包容量为j -
weight[i]，dp[i - 1][j - weight[i]] 为背包容量为j -
weight[i]且不放物品i的最大价值，那么dp[i - 1][j - weight[i]] + value[i]
（物品i的价值），就是背包放物品i得到的最大价值</p>
<ol start="4" type="1">
<li>遍历顺序: i从1到n-1, j从0到V</li>
</ol>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) {</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= V; ++j) {</span><br><span class="line">        <span class="comment">// 状态转移</span></span><br><span class="line">        <span class="keyword">if</span> (j &gt;= weight[i]) {</span><br><span class="line">            dp[i][j] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][j], dp[i<span class="number">-1</span>][j-weight[i]] + value[i]);</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            dp[i][j] = dp[i<span class="number">-1</span>][j];</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>
<p>举个例子, 假如背包最大重量为4。物品为： <div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">       重量	价值</span><br><span class="line">物品0	1	 15</span><br><span class="line">物品1	3	 20</span><br><span class="line">物品2	4	 30</span><br></pre></td></tr></table></figure></div></p>
<p>求背包能背的物品最大价值是多少？</p>
<p>更新完毕后的示意图如下: <img lazyload src="/images/loading.svg" data-src="image-2.png" alt="alt text"></p>
<h5 id="二维降一维-1">二维降一维</h5>
<p>在0-1背包问题中，二维数组 dp[i][j] 代表前 i 件物品可选的情况下,
放入容量为 j 的背包可以获得的最大价值。我们注意到，计算 dp[i][j]
时，<strong>只依赖于上一行</strong> dp[i-1][…]
的值。因此，我们可以将二维数组降为一维数组。</p>
<blockquote>
<p>需要满足的条件是上一层可以重复利用，直接拷贝到当前层。</p>
</blockquote>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(V + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) {</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = V; j &gt;= weight[i]; --j) {</span><br><span class="line">        dp[j] = <span class="built_in">max</span>(dp[j], dp[j - weight[i]] + value[i]);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>
<ol type="1">
<li><p>dp定义:
在一维dp数组中，dp[j]表示：容量为j的背包，所背的物品价值可以最大为dp[j]。
&gt; 其实dp[j]隐含了一个条件：在计算dp[j]时，物品i是可选的,
只不过我们没有显式地表示i. &gt; 在循环的过程中,
dp[j]的值会随着i的变化而变化, 直到最后一个i,
此时的dp[j]才是最终结果</p></li>
<li><p>初始化: <span class="math inline"><em>d</em><em>p</em>[0] = 0, <em>d</em><em>p</em>[<em>j</em>] = <em>j</em> &gt;  = <em>w</em><em>e</em><em>i</em><em>g</em><em>h</em><em>t</em>[0]?<em>v</em><em>a</em><em>l</em><em>u</em><em>e</em>[0] : 0</span></p></li>
<li><p>状态转移方程: <span class="math inline"><em>d</em><em>p</em>[<em>j</em>] = <em>m</em><em>a</em><em>x</em>(<em>d</em><em>p</em>[<em>j</em>], <em>d</em><em>p</em>[<em>j</em> − <em>w</em><em>e</em><em>i</em><em>g</em><em>h</em><em>t</em>[<em>i</em>]] + <em>v</em><em>a</em><em>l</em><em>u</em><em>e</em>[<em>i</em>])(<em>j</em> &gt;  = <em>w</em><em>e</em><em>i</em><em>g</em><em>h</em><em>t</em>[<em>i</em>])</span></p></li>
<li><p>遍历顺序: i从1到n-1, j从V到weight[i]</p></li>
</ol>
<p>这里的关键在于<strong>内层循环的遍历顺序</strong>。我们必须从<strong>后向前遍历
j</strong>（从 V 到 weight[i]），以确保在计算 dp[j] 时，dp[j -
weight[i]] 仍然是上一行的值（即不包含当前物品 i 的情况）。</p>
<p>假如还是正序遍历, 此时计算 dp[j], 我们需要用到 dp[j−weight[i]]
的值。而根据正序遍历的规则，当程序执行到 j 时，所有<strong>小于 j
的索引</strong>（包括 j -
weight[i]）都已经在<strong>本轮</strong>（即针对物品 i
的循环中）被<strong>更新</strong>过了。此时我们用到的 dp[j−weight[i]]
已经不是 dp[i−1][j−weight[i]]（上一轮的状态），而是
dp[i][j−weight[i]]（本轮更新后的状态）。</p>
<p>这意味着在计算 dp[i][j] 时，我们参考了已经放入过物品 i 的状态
dp[i][j−weight[i]]。这相当于物品 i
在一轮决策中被重复放入了多次(变成了完全背包), 这就违背了 0-1
背包问题中每件物品只能放入一次的原则。</p>
<p>而在二维动态规划中，我们在计算第 i
行（dp[i]）的任何一个值时，所依赖的 全部是 第 i-1
行（dp[i-1]）的数据。无论内层循环（遍历背包容量
j）是正序还是倒序，dp[i][j] 始终从上一行 dp[i-1]
获取数据。本行的更新（例如先计算了 dp[i][j-1]）不会“污染”到计算 dp[i][j]
时所需要的数据源</p>
<p>上述示例的一维示意图: <img lazyload src="/images/loading.svg" data-src="image-1.png" alt="alt text"></p>
<h5 id="二维0-1背包问题">二维0-1背包问题</h5>
<h5 id="完全背包问题">完全背包问题</h5>
<p>有N件物品和一个最多能背重量为W的背包。第i件物品的重量是weight[i]，得到的价值是value[i]
。每件物品都有无限个（也就是可以放入背包多次），求解将哪些物品装入背包里物品价值总和最大。</p>
<p>完全背包和01背包问题唯一不同的地方就是，<strong>每种物品有无限件</strong>。</p>
<p>但做法上和01背包问题非常类似, 只需要在状态转移方程上做出调整即可</p>
<ol type="1">
<li>状态定义: dp[i][j] 代表前 i 件物品可选的情况下, 放入容量为 j
的背包可以获得的最大价值</li>
<li>初始化: dp[i][0] = 0, dp[0][j] =
j&gt;=weight[0]?value[0]*(j/weight[0]):0</li>
<li>状态转移方程: <span class="math display"><em>d</em><em>p</em>[<em>i</em>][<em>j</em>] = <em>m</em><em>a</em><em>x</em>(<em>d</em><em>p</em>[<em>i</em> − 1][<em>j</em>], <em>d</em><em>p</em>[<em>i</em>][<em>j</em> − <em>w</em><em>e</em><em>i</em><em>g</em><em>h</em><em>t</em>[<em>i</em>]] + <em>v</em><em>a</em><em>l</em><em>u</em><em>e</em>[<em>i</em>])(<em>j</em> &gt;  = <em>w</em><em>e</em><em>i</em><em>g</em><em>h</em><em>t</em>[<em>i</em>])</span>
注意到这里的区别, 01背包是dp[i-1][j-weight[i]],
而完全背包是dp[i][j-weight[i]], 也就是说, 在完全背包中,
我们在计算放入物品i时, 允许再次放入物品i</li>
<li>遍历顺序: i从1到n-1, j从0到V <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) {</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= V; ++j) {</span><br><span class="line">        <span class="comment">// 状态转移</span></span><br><span class="line">        <span class="keyword">if</span> (j &gt;= weight[i]) {</span><br><span class="line">            dp[i][j] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][j], dp[i][j-weight[i]] + value[i]);</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            dp[i][j] = dp[i<span class="number">-1</span>][j];</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div></li>
</ol>
<h6 id="完全背包中的排列和组合问题">完全背包中的排列和组合问题</h6>
<p>在完全背包问题中, 我们经常会遇到两种不同的计算方式:
计算组合数和计算排列数. 例如:</p>
<ul>
<li>零钱兑换 II (LeetCode 518): 给你一个整数数组 coins
表示不同面额的硬币，以及一个整数 amount
表示总金额。计算并返回可以<strong>凑成总金额的硬币组合数</strong>。</li>
<li>组合总和 IV (LeetCode 377): 给你一个由不同整数组成的数组
nums，和一个目标整数 target。请你从 nums 中找出并返回总和为 target
的元素组合的个数, <strong>不同顺序认为是不同的组合</strong>。</li>
</ul>
<p>这两道题的唯一区别在于: 前者是组合问题, 后者是排列问题. 也就是说,
在前者中, [1,2] 和 [2,1] 被视为同一种组合; 而在后者中, [1,2] 和 [2,1]
被视为两种不同的组合.</p>
<p>它们的核心在于,
<strong>元素的使用顺序是否影响结果</strong>。这个看似微小的区别，将直接导致我们动态规划解题策略，特别是<strong>遍历顺序</strong>上的根本不同。</p>
<p><strong>组合问题</strong> (Combination)</p>
<ul>
<li>问题本质：不关心元素加入的顺序，只关心最终由哪些元素构成了目标总和。例如，凑成
4，(1, 3) 和 (3, 1) 被视为同一种组合。</li>
<li>DP 定义: dp[j] 表示凑成总和为 j 的组合总数。</li>
<li>核心策略：<strong>固定物品</strong>，<strong>更新背包</strong>。我们依次遍历每一个物品，用这个物品去更新所有它能影响到的背包容量。
<ul>
<li>当我们<strong>外层循环遍历物品</strong>时，我们等于在说：“现在只允许用第一个物品，看看能凑成哪些金额？”、“好了，现在在前者的基础上，再加入第二个物品，看看又能多凑出哪些组合？”。这个过程<strong>人为地固定了物品的考虑顺序</strong>，从而避免了排列的产生。</li>
</ul></li>
</ul>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">combination_2d</span><span class="params">(<span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt;&amp; coins, <span class="type">int</span> amount)</span> </span>{</span><br><span class="line">    <span class="type">int</span> n = coins.<span class="built_in">size</span>();</span><br><span class="line">    <span class="comment">// DP 定义：dp[i][j] 表示使用前 i 种硬币凑成金额 j 的组合数</span></span><br><span class="line">    std::vector&lt;std::vector&lt;<span class="type">long</span> <span class="type">long</span>&gt;&gt; <span class="built_in">dp</span>(n, std::<span class="built_in">vector</span>&lt;<span class="type">long</span> <span class="type">long</span>&gt;(amount + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 步骤说明：初始化基础情况。</span></span><br><span class="line">    <span class="comment">// 凑成金额 0 的组合数永远是 1（即什么都不选）。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) {</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 步骤说明：外层遍历物品（硬币）。</span></span><br><span class="line">    <span class="comment">// 这是组合问题的关键，我们按顺序将物品加入考虑范围。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i) {</span><br><span class="line">        <span class="comment">// 步骤说明：内层遍历背包（金额）。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= amount; ++j) {</span><br><span class="line">            <span class="comment">// 不使用第 i 种硬币的方法数</span></span><br><span class="line">            <span class="type">long</span> <span class="type">long</span> count1 = dp[i - <span class="number">1</span>][j];</span><br><span class="line">            <span class="comment">// 使用第 i 种硬币的方法数</span></span><br><span class="line">            <span class="type">long</span> <span class="type">long</span> count2 = (j &gt;= coins[i]) ? dp[i][j - coins[i]] : <span class="number">0</span>;</span><br><span class="line">            </span><br><span class="line">            dp[i][j] = count1 + count2;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[n<span class="number">-1</span>][amount];</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">combination_1d</span><span class="params">(<span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt;&amp; coins, <span class="type">int</span> amount)</span> </span>{</span><br><span class="line">    <span class="comment">// DP 定义：dp[j] 表示凑成金额 j 的组合数</span></span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">unsigned</span> <span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(amount + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 步骤说明：初始化基础情况。</span></span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 步骤说明：外层遍历物品（硬币）。</span></span><br><span class="line">    <span class="comment">// 这个顺序保证了我们是按物品的种类来计算组合，避免了排列。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> coin : coins) {</span><br><span class="line">        <span class="comment">// 步骤说明：内层遍历背包（金额）。</span></span><br><span class="line">        <span class="comment">// 正序遍历，因为物品可以重复使用（完全背包）。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = coin; j &lt;= amount; ++j) {</span><br><span class="line">            <span class="comment">// 递推公式：dp[j] 的值由不包含当前 coin 的旧 dp[j] 和</span></span><br><span class="line">            <span class="comment">// 包含了当前 coin 的 dp[j-coin] 累加而来。</span></span><br><span class="line">            dp[j] += dp[j - coin];</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[amount];</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>
<blockquote>
<p>这个一维 DP
的循环结构，其第一轮迭代本身就完成了对第一个物品的初始化计算。它把<strong>二维
DP
中对第一行的特殊处理</strong>，自然而然地融合进了<strong>通用的循环逻辑</strong>里。而在二维
DP 中，我们需要对第一行进行特殊初始化, 这是因为递推公式通常是 dp[i][j] =
dp[i-1][j] + …。这意味着计算第 i 行需要依赖第 i-1 行。当 i=1 时，它需要
i=0（即第一行）的数据。因此，我们必须先有第一行的数据，才能递推出后续所有行。所以二维解法常常会有一个单独的循环来填充第一行。</p>
</blockquote>
<p><strong>排列问题</strong> (Permutation)</p>
<ul>
<li>问题本质：元素的加入顺序至关重要，顺序不同即为不同的解。例如，凑成
4，(1, 3) 和 (3, 1) 被视为两种不同的排列。</li>
<li>DP 定义: dp[j] 表示凑成总和为 j 的排列总数。</li>
<li>核心策略：<strong>固定背包</strong>，<strong>尝试物品</strong>。我们依次遍历每一个背包容量（目标总和），然后<strong>考虑用哪个物品可以作为最后一步来达到这个容量</strong>。
<ul>
<li>步骤说明：当我们外层循环遍历背包容量 j 时，我们等于在问：“要凑成
j，最后一步可以是哪个数字？” 它可以是在凑成 j-num1 的基础上加上
num1，也可以是在凑成 j-num2 的基础上加上 num2… 由于我们对每个 j
都尝试了所有 nums
中的数字作为最后一步的可能性，自然就包含了所有的排列情况。</li>
</ul></li>
</ul>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">permutation_1d</span><span class="params">(<span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>{</span><br><span class="line">    <span class="comment">// DP 定义：dp[j] 表示凑成目标 j 的排列数</span></span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>&gt; <span class="title">dp</span><span class="params">(target + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 步骤说明：初始化基础情况。</span></span><br><span class="line">    <span class="comment">// 凑成目标 0 只有一种方法（空排列）。</span></span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 步骤说明：外层遍历背包（目标总和）。</span></span><br><span class="line">    <span class="comment">// 这是排列问题的关键，我们对每个目标值 j，都考虑所有可能的最后一步。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= target; ++j) {</span><br><span class="line">        <span class="comment">// 步骤说明：内层遍历物品（数字）。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) {</span><br><span class="line">            <span class="keyword">if</span> (j &gt;= num) {</span><br><span class="line">                <span class="comment">// 递推公式：凑成 j 的方法数，是所有“凑成 j-num 再加上以 num 结尾”</span></span><br><span class="line">                <span class="comment">// 的方法数之和。</span></span><br><span class="line">                dp[j] += dp[j - num];</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[target];</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>
<p>总之:</p>
<ul>
<li>解决组合问题，应该外层遍历物品，内层遍历背包。这相当于固定物品，看它能对不同容量的背包做什么贡献。</li>
<li>解决排列问题，应该外层遍历背包，内层遍历物品。这相当于固定目标（背包容量），看它可以由哪些物品作为最后一步凑成。</li>
</ul>
<h4 id="二维-dp">二维 DP</h4>
<h4 id="经典序列-dp-lcs-lis">经典序列 DP (LCS &amp; LIS)</h4>
<p>专门处理两个（或一个）序列/字符串之间的关系。 - 最长公共子序列 (LCS,
Longest Common Subsequence) - 最长递增子序列 (LIS, Longest Increasing
Subsequence) - 编辑距离 (Edit Distance)</p>
<p>这类问题的核心在于，<strong>状态定义通常涉及两个维度</strong>，分别对应<strong>两个序列的索引位置</strong>。通过比较这两个位置的元素，我们可以决定如何更新
DP 表格，从而逐步构建出最终的解。</p>
<h5 id="例题-最长公共子序列-lcs">例题: 最长公共子序列 (LCS)</h5>
<p>给定两个字符串 text1 和
text2，返回这两个字符串的最长公共子序列的长度。如果不存在公共子序列，返回
0 。 <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestCommonSubsequence</span><span class="params">(string text1, string text2)</span> </span>{</span><br><span class="line">        <span class="type">int</span> m = text<span class="number">1.</span><span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> n = text<span class="number">2.</span><span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(m<span class="number">+1</span>,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n<span class="number">+1</span>,<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++){</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++){</span><br><span class="line">                <span class="keyword">if</span>(text1[i<span class="number">-1</span>]==text2[j<span class="number">-1</span>]){</span><br><span class="line">                    dp[i][j] = <span class="number">1</span>+dp[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">                }<span class="keyword">else</span>{</span><br><span class="line">                    dp[i][j] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][j],dp[i][j<span class="number">-1</span>]);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></table></figure></div> 状态定义: dp[i][j]. 我们定义 dp[i][j] 表示 text1
的前 i 个字符（即 text1[0…i-1]）与 text2 的前 j 个字符（即
text2[0…j-1]）的最长公共子序列的长度。</p>
<p>重点：</p>
<ul>
<li><p>dp 表的大小：如果 text1 长度为 m，text2 长度为
n，我们需要一个大小为 (m+1) x (n+1) 的 dp 表。</p></li>
<li><p>+1 的目的：dp[0][j] 和 dp[i][0]
用来表示“空字符串”与另一个字符串的 LCS。</p>
<ul>
<li>dp[0][j]：text1 取前 0 个字符（空串）与 text2 前 j 个字符的
LCS，结果显然是 0。</li>
<li>dp[i][0]：text1 取前 i 个字符与 text2 前 0 个字符（空串）的
LCS，结果也显然是 0。</li>
<li>这种定义让我们的base case (基础情况) 变得非常清晰。</li>
</ul></li>
<li><p>状态转移方程: 要计算 dp[i][j]，我们需要观察 text1 的第 i
个字符（即 text1[i-1]）和 text2 的第 j 个字符（即
text2[j-1]）。这里只有两种情况：</p>
<ul>
<li><p>情况一：两个字符相等, if (text1[i-1] == text2[j-1]) -
说明：我们找到了一个新的公共字符！例如，比较 “abc” 和 “adc” 时，我们发现
c == c。 - 操作：这个新的公共字符 c 必然可以被包含在 LCS 中。当前的 LCS
长度，等于 “ab” 和 “ad” 的 LCS 长度 再加 1。 - 对应到 dp 表：dp[i][j]
等于 dp[i-1][j-1] (即 “ab” 和 “ad” 的LCS) + 1。 - 转移方程 (1)：dp[i][j]
= 1 + dp[i-1][j-1]</p></li>
<li><p>情况二：两个字符不相等, if (text1[i-1] != text2[j-1]) -
说明：这两个字符无法同时作为公共子序列的结尾。例如，比较 “abc” 和 “ade”
时，c != e。 - 操作：我们必须在 “abc” 和 “ade”
中“丢弃”一个字符，然后<strong>取两种情况下的最优解</strong>（最大值）。
- 丢弃 text1 的 c：我们去比较 “ab” 和 “ade”。对应 dp 表：dp[i-1][j] -
丢弃 text2 的 e：我们去比较 “abc” 和 “ad”。对应 dp 表：dp[i][j-1] -
例如：LCS(“abc”, “ade”) 应该等于 max(LCS(“ab”, “ade”), LCS(“abc”,
“ad”))。 - 转移方程 (2)：dp[i][j] = max(dp[i-1][j], dp[i][j-1])</p></li>
</ul></li>
</ul>
<p>为什么是一道 DP
问题？我们要找“最长”的公共子序列。这暗示着我们要做出<strong>最优决策</strong>。当我们比较两个字符串
text1 和 text2 时，例如 text1 = “abcde” 和 text2 =
“ace”，我们从头开始看：</p>
<ul>
<li>‘a’ vs ‘a’：它们匹配。很好，LCS 至少为
1。我们接下来该做什么？我们应该去求解 “bcde” 和 “ce” 的 LCS。</li>
<li>‘b’ vs ‘c’：不匹配。我们现在有两个选择：跳过 ‘b’，去比较 “cde” 和
“ce”; 跳过 ‘c’，去比较 “bcde” 和 “e”。</li>
<li>我们发现，原问题 LCS(“abcde”, “ace”) 被分解为了 1 + LCS(“bcde”,
“ce”)，而 LCS(“bcde”, “ce”) 又被分解为求解 LCS(“cde”, “ce”) 和
LCS(“bcde”, “e”) 中的最大值…这就是“最优子结构”和“重叠子问题”，是 DP
的完美应用场景。</li>
</ul>
<p>为什么要用二维 DP？与“最长递增子序列”（一维 DP）不同，LCS
问题有两个变量在同时变化：text1 的索引 i 和 text2 的索引 j。
因此，我们的 <strong>DP
状态必须由这两个变量共同决定</strong>。这自然地导出了一个<strong>二维 dp
表</strong>。</p>
<h5 id="例题-最长递增子序列">例题: 最长递增子序列</h5>
<p>给你一个整数数组 nums
，找到其中最长严格递增子序列的长度。子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7]
是数组 [0,3,1,6,2,2,7] 的子序列。</p>
<p>要计算 dp[i]（以 nums[i] 结尾的 LIS 长度），我们需要考虑 nums[i]
能“接”在哪个子序列的后面。我们必须遍历 i 之前的所有元素 nums[j]（其中 j
从 0 到 i-1）： - 如果 nums[i] &gt; nums[j]： -
说明：这满足“严格递增”的要求。nums[i] 可以接在以 nums[j]
结尾的那个递增子序列的后面。 - 操作：形成了一个新的、更长的、以 nums[i]
结尾的子序列。它的长度是 dp[j] + 1 (即 …nums[j] 的序列长度 dp[j]，加上
nums[i] 这个元素)。</p>
<ul>
<li>如果 nums[i] &lt;= nums[j]：
<ul>
<li>说明：nums[i] 不能接在以 nums[j] 结尾的子序列后面。</li>
</ul></li>
</ul>
<p>dp[i] 的初始值是什么？ 任何一个元素 nums[i] 自身都可以构成一个长度为
1 的子序列。所以 dp[i] 的保底值（基础情况）是 1。</p>
<p>推导方程： dp[i] 应该是所有可能的 dp[j] + 1 (对于 j &lt; i 且 nums[i]
&gt; nums[j]) 和它的保底值 1 之间，取一个最大值。</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">lengthOfLIS</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>{</span><br><span class="line">    <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// dp[i] 表示以 nums[i] 结尾的最长递增子序列的长度</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> global_max_length = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) {</span><br><span class="line">        <span class="comment">// 1. 初始化：</span></span><br><span class="line">        <span class="comment">// 任何子序列的最小长度都是 1 (即 nums[i] 自身)</span></span><br><span class="line">        dp[i] = <span class="number">1</span>; </span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 状态转移：</span></span><br><span class="line">        <span class="comment">// 遍历 i 之前的所有元素 j</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; ++j) {</span><br><span class="line">            <span class="comment">// 如果 nums[i] &gt; nums[j]，说明 nums[i] 可以接在 nums[j] 后面</span></span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; nums[j]) {</span><br><span class="line">                <span class="comment">// 我们要找一个最长的 dp[j] 来接</span></span><br><span class="line">                dp[i] = <span class="built_in">max</span>(dp[i], dp[j] + <span class="number">1</span>);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 3. 更新全局答案：</span></span><br><span class="line">        <span class="comment">// 最终答案是所有 dp[i] 中的最大值</span></span><br><span class="line">        global_max_length = <span class="built_in">max</span>(global_max_length, dp[i]);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> global_max_length;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>
<p>方法2: 二分查找 + 贪心</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">lengthOfLIS</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>{</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; tails;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> num:nums){</span><br><span class="line">        <span class="keyword">auto</span> it = <span class="built_in">lower_bound</span>(tails.<span class="built_in">begin</span>(),tails.<span class="built_in">end</span>(),num);</span><br><span class="line">        <span class="keyword">if</span>(it==tails.<span class="built_in">end</span>()){</span><br><span class="line">            tails.<span class="built_in">push_back</span>(num);</span><br><span class="line">        }<span class="keyword">else</span>{</span><br><span class="line">            *it = num;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> tails.<span class="built_in">size</span>();</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>
<p>核心思想：耐心排序 (Patience Sorting).
这个算法的灵感来自于一种叫做“耐心排序”的纸牌游戏。 游戏规则：
你有一堆乱序的牌（nums
数组），你需要把它们一张张发到桌上的几个牌堆（tails 数组）里。</p>
<ul>
<li>规则 1：你一次拿一张牌 num。</li>
<li>规则 2：你必须把 num 放到某个牌堆的顶部。你只能放在牌堆顶部 &gt;=
num 的牌堆上。</li>
<li>规则 3：如果你有多个选择（例如 num=3，牌堆顶部有 [2, 5,
8]），你必须选择最左边的那个（即 5）。</li>
<li>规则 4：如果 num 比所有牌堆的顶部都大（例如 num=10，牌堆顶部 [2, 5,
8]），你必须在最右边新建一个牌堆。</li>
</ul>
<p>结论：当你发完所有牌后，桌上牌堆的数量就是 LIS 的长度。</p>
<p>tails 数组是什么？tails
数组就是这个游戏中，桌上所有牌堆顶部的牌的集合。</p>
<p>tails[k] 存储的是 “牌堆 k” 的顶部卡片。由于规则 4，tails
数组（即所有牌堆的顶部）必然是严格递增的。</p>
<ul>
<li>tails = [pile1_top, pile2_top, pile3_top, …]</li>
</ul>
<p>因为只有当 num 大于 所有
顶牌时，才允许你新建牌堆（push_back），所以新牌堆的顶牌一定比所有旧顶牌都大。</p>
<p>因为 tails 数组是严格递增的，所以我们可以使用二分查找来应用规则
3。</p>
<p>让我们把“游戏规则”翻译成“代码逻辑”：</p>
<ul>
<li>tails 数组：存储所有牌堆的顶部。</li>
<li>遍历 nums 中每个 num：
<ul>
<li>二分查找：在 tails 数组中，找到第一个大于或等于 num 的位置 it (即
std::lower_bound)。</li>
<li>if (it == tails.end())：
<ul>
<li>游戏翻译：num 比所有牌堆的顶部都大（规则 4）。</li>
<li>代码逻辑：在最右边新建一个牌堆。</li>
<li>操作：tails.push_back(num)。</li>
<li>结果：LIS 的长度增加了 1。</li>
</ul></li>
<li>if (it != tails.end())：
<ul>
<li>游戏翻译：我们找到了一个牌堆 *it (例如 5)，num (例如 3)
可以放在它上面（规则 2 &amp; 3）。</li>
<li>代码逻辑：用 num 替换掉 *it。</li>
<li>操作：*it = num。</li>
<li>结果：LIS 的长度没有变，但这个牌堆的顶部变小了（5 变成了 3）。</li>
</ul></li>
</ul></li>
</ul>
<p>核心就是在更新tails数组时使用了二分查找,
使得整体时间复杂度降为O(nlogn)</p>
<h4 id="状态机-dp">状态机 DP</h4>
<p>这是“入门 DP”中 dp[i] 的自然演进。在一维 DP（如打家劫舍）中，dp[i]
的决策只依赖于 dp[i-1] 和 dp[i-2]。但在更复杂的问题中，dp[i]
的决策不仅依赖于 i-1，还依赖于 <strong>i-1 所处的状态</strong>。</p>
<p>例如“买卖股票(带冷冻期)”，在第 <span class="math inline"><em>i</em></span>
天，你能做的操作（买、卖、持有不动）取决于你在第 <span class="math inline"><em>i</em> − 1</span>
天是“持有股票”还是“未持有股票”, 未持有是在冷冻期还是不在冷冻期。状态机
DP 就是用来解决这种“在不同状态间转换”的最优解问题。</p>
<p>我们不再用一个简单的 dp[i] 来表示“到第 i
天的最大收益”，因为这个信息不够。 我们使用 dp[i][j]，其中：</p>
<ul>
<li>i：代表时间（第 i 天，或考虑第 i 个元素）。</li>
<li>j：代表在 <strong>i 时刻所处的状态</strong>（状态 j）。</li>
<li>dp[i][j] 的值：表示在第 i 天，处于状态 j
时，所能获得的最大收益（或最长长度、最少次数等）。</li>
</ul>
<p>解决状态机 DP 的“四部曲”: 这是一个几乎可以套用在所有状态机 DP
问题上的标准流程。</p>
<ul>
<li>第 1 步：确定状态 (Define States)
<ul>
<li>问自己：“在任何一天 i，我可能处于哪些互斥的状况下？”</li>
<li>例 (LC 122)：
<ul>
<li>状态 0：今天结束时，手里持有股票。</li>
<li>状态 1：今天结束时，手里未持有股票。</li>
</ul></li>
</ul></li>
<li>第 2 步：绘制状态转移图 (Draw the Diagram)
<ul>
<li>这是最关键的一步。画出状态（节点）和事件（带箭头的边）。</li>
<li>例 (LC 122)：
<ul>
<li>状态 0 (未持有) <span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.186ex;" xmlns="http://www.w3.org/2000/svg" width="4.532ex" height="3.262ex" role="img" focusable="false" viewbox="0 -1359.7 2003.2 1441.7"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mover"><g data-mml-node="mstyle"><g data-mml-node="mo"><path data-c="2192" d="M56 237T56 250T70 270H835Q719 357 692 493Q692 494 692 496T691 499Q691 511 708 511H711Q720 511 723 510T729 506T732 497T735 481T743 456Q765 389 816 336T935 261Q944 258 944 250Q944 244 939 241T915 231T877 212Q836 186 806 152T761 85T740 35T732 4Q730 -6 727 -8T711 -11Q691 -11 691 0Q691 7 696 25Q728 151 835 230H70Q56 237 56 250Z" transform="translate(1003.2,0)"/><svg width="1103.2" height="865" x="0" y="-182" viewbox="275.8 -182 1103.2 865"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z" transform="scale(2.127,1)"/></svg></g></g><g data-mml-node="mpadded" transform="translate(0,870.8) scale(0.707)"><g transform="translate(278,-200)"><g data-mml-node="mtext"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">买</text><text data-variant="normal" transform="translate(1000,0) scale(1,-1)" font-size="884px" font-family="serif">入</text></g><g data-mml-node="mspace" transform="translate(2000,0)"/></g></g></g></g></g></svg></mjx-container></span> 状态 1
(持有)</li>
<li>状态 1 (持有) <span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.186ex;" xmlns="http://www.w3.org/2000/svg" width="4.532ex" height="3.262ex" role="img" focusable="false" viewbox="0 -1359.7 2003.2 1441.7"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mover"><g data-mml-node="mstyle"><g data-mml-node="mo"><path data-c="2192" d="M56 237T56 250T70 270H835Q719 357 692 493Q692 494 692 496T691 499Q691 511 708 511H711Q720 511 723 510T729 506T732 497T735 481T743 456Q765 389 816 336T935 261Q944 258 944 250Q944 244 939 241T915 231T877 212Q836 186 806 152T761 85T740 35T732 4Q730 -6 727 -8T711 -11Q691 -11 691 0Q691 7 696 25Q728 151 835 230H70Q56 237 56 250Z" transform="translate(1003.2,0)"/><svg width="1103.2" height="865" x="0" y="-182" viewbox="275.8 -182 1103.2 865"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z" transform="scale(2.127,1)"/></svg></g></g><g data-mml-node="mpadded" transform="translate(0,870.8) scale(0.707)"><g transform="translate(278,-200)"><g data-mml-node="mtext"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">卖</text><text data-variant="normal" transform="translate(1000,0) scale(1,-1)" font-size="884px" font-family="serif">出</text></g><g data-mml-node="mspace" transform="translate(2000,0)"/></g></g></g></g></g></svg></mjx-container></span> 状态 0
(未持有)</li>
<li>状态 0 (未持有) <span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.186ex;" xmlns="http://www.w3.org/2000/svg" width="4.532ex" height="3.262ex" role="img" focusable="false" viewbox="0 -1359.7 2003.2 1441.7"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mover"><g data-mml-node="mstyle"><g data-mml-node="mo"><path data-c="2192" d="M56 237T56 250T70 270H835Q719 357 692 493Q692 494 692 496T691 499Q691 511 708 511H711Q720 511 723 510T729 506T732 497T735 481T743 456Q765 389 816 336T935 261Q944 258 944 250Q944 244 939 241T915 231T877 212Q836 186 806 152T761 85T740 35T732 4Q730 -6 727 -8T711 -11Q691 -11 691 0Q691 7 696 25Q728 151 835 230H70Q56 237 56 250Z" transform="translate(1003.2,0)"/><svg width="1103.2" height="865" x="0" y="-182" viewbox="275.8 -182 1103.2 865"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z" transform="scale(2.127,1)"/></svg></g></g><g data-mml-node="mpadded" transform="translate(0,870.8) scale(0.707)"><g transform="translate(278,-200)"><g data-mml-node="mtext"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">休</text><text data-variant="normal" transform="translate(1000,0) scale(1,-1)" font-size="884px" font-family="serif">息</text></g><g data-mml-node="mspace" transform="translate(2000,0)"/></g></g></g></g></g></svg></mjx-container></span> 状态 0
(未持有)</li>
<li>状态 1 (持有) <span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.186ex;" xmlns="http://www.w3.org/2000/svg" width="4.532ex" height="3.262ex" role="img" focusable="false" viewbox="0 -1359.7 2003.2 1441.7"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mover"><g data-mml-node="mstyle"><g data-mml-node="mo"><path data-c="2192" d="M56 237T56 250T70 270H835Q719 357 692 493Q692 494 692 496T691 499Q691 511 708 511H711Q720 511 723 510T729 506T732 497T735 481T743 456Q765 389 816 336T935 261Q944 258 944 250Q944 244 939 241T915 231T877 212Q836 186 806 152T761 85T740 35T732 4Q730 -6 727 -8T711 -11Q691 -11 691 0Q691 7 696 25Q728 151 835 230H70Q56 237 56 250Z" transform="translate(1003.2,0)"/><svg width="1103.2" height="865" x="0" y="-182" viewbox="275.8 -182 1103.2 865"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z" transform="scale(2.127,1)"/></svg></g></g><g data-mml-node="mpadded" transform="translate(0,870.8) scale(0.707)"><g transform="translate(278,-200)"><g data-mml-node="mtext"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">休</text><text data-variant="normal" transform="translate(1000,0) scale(1,-1)" font-size="884px" font-family="serif">息</text></g><g data-mml-node="mspace" transform="translate(2000,0)"/></g></g></g></g></g></svg></mjx-container></span> 状态 1
(持有)</li>
</ul></li>
</ul></li>
<li>第 3 步：写出状态转移方程 (Write Equations), 把“图”翻译成“数学”。
<ul>
<li>dp[i][j] 的值，等于所有“能转移到 j 状态”的 i-1 状态的最大值。
<ul>
<li>dp[i][0] (今天未持有) = max(昨天就未持有，今天休息：dp[i-1][0],
昨天持有，今天卖了：dp[i-1][1] + prices[i])</li>
<li>dp[i][1] (今天持有) = max(昨天就持有，今天休息：dp[i-1][1],
昨天未持有，今天买了：dp[i-1][0] - prices[i])</li>
</ul></li>
</ul></li>
<li>第 4 步：确定 Base Cases (Initialize)
<ul>
<li>dp[0][0]：第 0 天，未持有 <span class="math inline">→</span> 利润为
0。</li>
<li>dp[0][1]：第 0 天，持有 <span class="math inline">→</span>
意味着在第 0 天买了 <span class="math inline">→</span> 利润为
-prices[0]。</li>
</ul></li>
</ul>
<h5 id="经典示例lc-309-带冷冻期的股票">经典示例：LC 309
(带冷冻期的股票)</h5>
<p>题目：卖出股票后，你必须在第二天（冷冻期）休息，不能买入。</p>
<p>第 1
步：确定状态(这里的状态一定是<strong>采取行动之后</strong>处于的状态) -
状态 0：持有 - 状态 1：未持有（今天刚卖出，处于冷冻期） - 状态
2：未持有（不在冷冻期，可以买入） -
说明：我们必须把“未持有”拆成两种状态，因为它们对明天的决策（能否买入）有影响。</p>
<p>第 2 步：绘制状态转移图 - 状态 0 (持有) <span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.186ex;" xmlns="http://www.w3.org/2000/svg" width="4.532ex" height="3.262ex" role="img" focusable="false" viewbox="0 -1359.7 2003.2 1441.7"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mover"><g data-mml-node="mstyle"><g data-mml-node="mo"><path data-c="2192" d="M56 237T56 250T70 270H835Q719 357 692 493Q692 494 692 496T691 499Q691 511 708 511H711Q720 511 723 510T729 506T732 497T735 481T743 456Q765 389 816 336T935 261Q944 258 944 250Q944 244 939 241T915 231T877 212Q836 186 806 152T761 85T740 35T732 4Q730 -6 727 -8T711 -11Q691 -11 691 0Q691 7 696 25Q728 151 835 230H70Q56 237 56 250Z" transform="translate(1003.2,0)"/><svg width="1103.2" height="865" x="0" y="-182" viewbox="275.8 -182 1103.2 865"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z" transform="scale(2.127,1)"/></svg></g></g><g data-mml-node="mpadded" transform="translate(0,870.8) scale(0.707)"><g transform="translate(278,-200)"><g data-mml-node="mtext"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">卖</text><text data-variant="normal" transform="translate(1000,0) scale(1,-1)" font-size="884px" font-family="serif">出</text></g><g data-mml-node="mspace" transform="translate(2000,0)"/></g></g></g></g></g></svg></mjx-container></span> 状态 1 (冷冻) -
状态 1 (冷冻) <span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.186ex;" xmlns="http://www.w3.org/2000/svg" width="4.532ex" height="3.262ex" role="img" focusable="false" viewbox="0 -1359.7 2003.2 1441.7"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mover"><g data-mml-node="mstyle"><g data-mml-node="mo"><path data-c="2192" d="M56 237T56 250T70 270H835Q719 357 692 493Q692 494 692 496T691 499Q691 511 708 511H711Q720 511 723 510T729 506T732 497T735 481T743 456Q765 389 816 336T935 261Q944 258 944 250Q944 244 939 241T915 231T877 212Q836 186 806 152T761 85T740 35T732 4Q730 -6 727 -8T711 -11Q691 -11 691 0Q691 7 696 25Q728 151 835 230H70Q56 237 56 250Z" transform="translate(1003.2,0)"/><svg width="1103.2" height="865" x="0" y="-182" viewbox="275.8 -182 1103.2 865"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z" transform="scale(2.127,1)"/></svg></g></g><g data-mml-node="mpadded" transform="translate(0,870.8) scale(0.707)"><g transform="translate(278,-200)"><g data-mml-node="mtext"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">休</text><text data-variant="normal" transform="translate(1000,0) scale(1,-1)" font-size="884px" font-family="serif">息</text></g><g data-mml-node="mspace" transform="translate(2000,0)"/></g></g></g></g></g></svg></mjx-container></span> 状态 2 (可买) -
状态 2 (可买) <span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.186ex;" xmlns="http://www.w3.org/2000/svg" width="4.532ex" height="3.262ex" role="img" focusable="false" viewbox="0 -1359.7 2003.2 1441.7"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mover"><g data-mml-node="mstyle"><g data-mml-node="mo"><path data-c="2192" d="M56 237T56 250T70 270H835Q719 357 692 493Q692 494 692 496T691 499Q691 511 708 511H711Q720 511 723 510T729 506T732 497T735 481T743 456Q765 389 816 336T935 261Q944 258 944 250Q944 244 939 241T915 231T877 212Q836 186 806 152T761 85T740 35T732 4Q730 -6 727 -8T711 -11Q691 -11 691 0Q691 7 696 25Q728 151 835 230H70Q56 237 56 250Z" transform="translate(1003.2,0)"/><svg width="1103.2" height="865" x="0" y="-182" viewbox="275.8 -182 1103.2 865"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z" transform="scale(2.127,1)"/></svg></g></g><g data-mml-node="mpadded" transform="translate(0,870.8) scale(0.707)"><g transform="translate(278,-200)"><g data-mml-node="mtext"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">买</text><text data-variant="normal" transform="translate(1000,0) scale(1,-1)" font-size="884px" font-family="serif">入</text></g><g data-mml-node="mspace" transform="translate(2000,0)"/></g></g></g></g></g></svg></mjx-container></span> 状态 0 (持有) -
状态 0 (持有) <span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.186ex;" xmlns="http://www.w3.org/2000/svg" width="4.532ex" height="3.262ex" role="img" focusable="false" viewbox="0 -1359.7 2003.2 1441.7"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mover"><g data-mml-node="mstyle"><g data-mml-node="mo"><path data-c="2192" d="M56 237T56 250T70 270H835Q719 357 692 493Q692 494 692 496T691 499Q691 511 708 511H711Q720 511 723 510T729 506T732 497T735 481T743 456Q765 389 816 336T935 261Q944 258 944 250Q944 244 939 241T915 231T877 212Q836 186 806 152T761 85T740 35T732 4Q730 -6 727 -8T711 -11Q691 -11 691 0Q691 7 696 25Q728 151 835 230H70Q56 237 56 250Z" transform="translate(1003.2,0)"/><svg width="1103.2" height="865" x="0" y="-182" viewbox="275.8 -182 1103.2 865"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z" transform="scale(2.127,1)"/></svg></g></g><g data-mml-node="mpadded" transform="translate(0,870.8) scale(0.707)"><g transform="translate(278,-200)"><g data-mml-node="mtext"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">休</text><text data-variant="normal" transform="translate(1000,0) scale(1,-1)" font-size="884px" font-family="serif">息</text></g><g data-mml-node="mspace" transform="translate(2000,0)"/></g></g></g></g></g></svg></mjx-container></span> 状态 0 (持有) -
状态 2 (可买) <span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.186ex;" xmlns="http://www.w3.org/2000/svg" width="4.532ex" height="3.262ex" role="img" focusable="false" viewbox="0 -1359.7 2003.2 1441.7"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mover"><g data-mml-node="mstyle"><g data-mml-node="mo"><path data-c="2192" d="M56 237T56 250T70 270H835Q719 357 692 493Q692 494 692 496T691 499Q691 511 708 511H711Q720 511 723 510T729 506T732 497T735 481T743 456Q765 389 816 336T935 261Q944 258 944 250Q944 244 939 241T915 231T877 212Q836 186 806 152T761 85T740 35T732 4Q730 -6 727 -8T711 -11Q691 -11 691 0Q691 7 696 25Q728 151 835 230H70Q56 237 56 250Z" transform="translate(1003.2,0)"/><svg width="1103.2" height="865" x="0" y="-182" viewbox="275.8 -182 1103.2 865"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z" transform="scale(2.127,1)"/></svg></g></g><g data-mml-node="mpadded" transform="translate(0,870.8) scale(0.707)"><g transform="translate(278,-200)"><g data-mml-node="mtext"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">休</text><text data-variant="normal" transform="translate(1000,0) scale(1,-1)" font-size="884px" font-family="serif">息</text></g><g data-mml-node="mspace" transform="translate(2000,0)"/></g></g></g></g></g></svg></mjx-container></span> 状态 2 (可买)</p>
<p>第 3 步：状态转移方程 - dp[i][0] (持有) =
max(昨天就持有：dp[i-1][0]昨天是“可买”，今天买了：dp[i-1][2] -
prices[i]) - dp[i][1] (冷冻) = max(昨天持有，今天卖了：dp[i-1][0] +
prices[i]) - dp[i][2] (可买) =
max(昨天就是“可买”，今天休息：dp[i-1][2]昨天是“冷冻”，今天解冻了：dp[i-1][1])</p>
<p>第 4 步：Base Cases - dp[0][0] = -prices[0] - dp[0][1] = 0 (第 0
天不可能处于冷冻期) - dp[0][2] = 0 (第 0 天未持有)</p>
<p>最终答案：max(dp[n-1][1], dp[n-1][2])
(因为最后一天持有股票利润肯定不是最大的)。 <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>{</span><br><span class="line">    <span class="type">int</span> n = prices.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span>(n&lt;=<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">3</span>,<span class="number">0</span>));</span><br><span class="line">    <span class="comment">// dp[i][0]: 第 i 天, 处于 "持有" 状态的最大利润</span></span><br><span class="line">    <span class="comment">// dp[i][1]: 第 i 天, 处于 "可买" (非冷冻期、未持有) 状态的最大利润</span></span><br><span class="line">    <span class="comment">// dp[i][2]: 第 i 天, 处于 "冷冻" 状态的最大利润</span></span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = -prices[<span class="number">0</span>];   <span class="comment">// 持有</span></span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0</span>;       <span class="comment">// 可买</span></span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">2</span>] = <span class="number">0</span>;   <span class="comment">// 冷冻期</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++){</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">0</span>], dp[i<span class="number">-1</span>][<span class="number">1</span>]-prices[i]);</span><br><span class="line">        dp[i][<span class="number">1</span>] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">2</span>], dp[i<span class="number">-1</span>][<span class="number">1</span>]);</span><br><span class="line">        dp[i][<span class="number">2</span>] = dp[i<span class="number">-1</span>][<span class="number">0</span>]+prices[i];</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(dp[n<span class="number">-1</span>][<span class="number">1</span>],dp[n<span class="number">-1</span>][<span class="number">2</span>]);</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div></p>
<h4 id="划分型-dp-partition-dp">划分型 DP (Partition DP)</h4>
<p>核心思想：解决“将一个序列（数组/字符串）<strong>分割</strong>成若干段，以求最优解”的问题。例如：“将字符串分割为最少的美丽子字符串”、“将数组分割为
k 段使最大和最小”。</p>
<p>状态定义（递推）：通常有两种状态定义： - 不限段数 (如 LC 139)：dp[i]
= 考虑前 <span class="math inline"><em>i</em></span> 个元素
a[0…i-1]，将其分割的最优解（如 bool 能否分割，int 最小代价）。 - 限制
<span class="math inline"><em>k</em></span> 段 (如 LC 410)：dp[k][i] =
将前 <span class="math inline"><em>i</em></span> 个元素 a[0…i-1]
分割成<strong>恰好</strong> <span class="math inline"><em>k</em></span>
段的最优解。</p>
<p>状态转移：枚举最后一段！这是划分型 DP 的灵魂。</p>
<p>dp[i] 的值，是通过枚举<strong>最后一段的起点</strong> <span class="math inline"><em>j</em></span> 来确定的: <span class="math inline"><em>d</em><em>p</em>[<em>i</em>] = 最优(<em>d</em><em>p</em>[<em>j</em>] + cost(<em>j</em>, <em>i</em> − 1))</span>
(其中 <span class="math inline">0 ≤ <em>j</em> &lt; <em>i</em></span>) -
dp[j]：前 <span class="math inline"><em>j</em></span>
个元素的最优解（子问题）。 - cost(j, i-1)：将 a[j…i-1]
作为一个<strong>整体</strong>（最后一段）的代价/合法性。</p>
<h4 id="区间-dp-interval-dp">区间 DP (Interval DP)</h4>
<p>区间 DP
主要用于解决“区间”或“子区间”相关的问题，通常涉及对一个序列（数组或字符串）进行划分、合并或计算某种属性。区间
DP
的核心在于<strong>状态定义</strong>和<strong>状态转移方程</strong>，它们通常基于区间的起点和终点。</p>
<ul>
<li>核心思想：当一个大区间 [i, j]
的最优解，依赖于它内部的、更小的<strong>子区间</strong>（如 [i+1,
j]、[i, j-1]、[i, k] 和 [k+1, j]）的最优解时，使用区间
DP。这通常用于“合并”或“消除”问题，例如戳气球、合并石头、最长回文子序列。</li>
<li>状态定义（递推）： dp[i][j] = 在闭区间[i, j] 上能获得的最优解。</li>
<li>状态转移： 你需要思考<strong>最后一步操作</strong>。
<ul>
<li>情况 1 (<strong>两端</strong>相关)：如“最长回文子序列”，dp[i][j]
的值依赖 dp[i+1][j-1]。</li>
<li>情况 2 (<strong>枚举分割点</strong>)：如“戳气球”，dp[i][j] 的值依赖
dp[i][k] + dp[k+1][j]。</li>
</ul></li>
<li>关键：遍历顺序 dp[i][j]
依赖于更短的区间。所以你不能<code>for i ... for j ...</code>。
你必须按照<strong>区间长度</strong> (len)来遍历： <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> len = <span class="number">1</span>; len &lt;= n; ++len) {</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n - len; ++i) {</span><br><span class="line">        <span class="type">int</span> j = i + len - <span class="number">1</span>; <span class="comment">// 区间右端点</span></span><br><span class="line">        <span class="comment">// ... 计算 dp[i][j] ...</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div></li>
</ul>
<p>例如, 对于最大回文子序列问题: <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">longestPalindromeSubseq</span><span class="params">(string s)</span> </span>{</span><br><span class="line">    <span class="type">int</span> n = s.<span class="built_in">length</span>();</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 状态定义: dp[i][j] = s[i...j] 上的 LPS 长度</span></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 递推顺序: 按照区间长度 len 从 1 到 n 遍历</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> len = <span class="number">1</span>; len &lt;= n; ++len) {</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 遍历所有可能的起始点 i</span></span><br><span class="line">        <span class="comment">// j 是由 i 和 len 决定的</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n - len; ++i) {</span><br><span class="line">            <span class="type">int</span> j = i + len - <span class="number">1</span>; <span class="comment">// 区间的结束点</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3. Base Case: len = 1</span></span><br><span class="line">            <span class="keyword">if</span> (len == <span class="number">1</span>) {</span><br><span class="line">                dp[i][j] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">continue</span>; <span class="comment">// 计算下一个区间</span></span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 4. 状态转移: len &gt; 1</span></span><br><span class="line">            <span class="keyword">if</span> (s[i] == s[j]) {</span><br><span class="line">                <span class="comment">// 情况一: s[i] == s[j]</span></span><br><span class="line">                <span class="comment">// dp[i][j] = dp[i+1][j-1] + 2</span></span><br><span class="line">                <span class="comment">// 注意: 当 len=2 时 (例如 "aa"), i+1 &gt; j-1</span></span><br><span class="line">                <span class="comment">// 此时 dp[i+1][j-1] (例如 dp[1][0]) 是 0 (因为 j &lt; i)</span></span><br><span class="line">                <span class="comment">// 所以 dp[i][j] = 0 + 2 = 2，是正确的。</span></span><br><span class="line">                dp[i][j] = dp[i + <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                <span class="comment">// 情况二: s[i] != s[j]</span></span><br><span class="line">                dp[i][j] = <span class="built_in">max</span>(dp[i + <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. 最终答案: dp[0][n-1]</span></span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>][n - <span class="number">1</span>];</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div> 第 1 步：状态定义</p>
<ul>
<li>dp[i][j]：表示字符串 s 在区间 [i, j]（即子串
s[i…j]）上的最长回文子序列的长度。</li>
<li>i 是区间的起始索引，j 是区间的结束索引。</li>
</ul>
<p>第 2 步：最终答案</p>
<ul>
<li>我们要求的是整个字符串 s 的 LPS，即 s[0…n-1] 的解。</li>
<li>答案：dp[0][n-1]</li>
</ul>
<p>第 3 步：Base Case (递推的起点)</p>
<ul>
<li>我们需要从“最短的区间”开始。</li>
<li>区间长度 len = 1：即 i == j 时，例如 dp[0][0] (“b”), dp[1][1]
(“b”)。</li>
<li>任何单个字符本身就是回文，长度为 1。</li>
<li>Base Case: dp[i][i] = 1</li>
</ul>
<p>第 4 步：状态转移 (灵魂)</p>
<ul>
<li>我们要计算 dp[i][j]，此时区间长度 len &gt;
1。我们只看这个区间的两个端点：s[i] 和 s[j]。</li>
<li>情况一：两端字符相等 s[i] == s[j], 例如 s[i…j] = “a…a”
<ul>
<li>分析：太好了！s[i] 和 s[j] 可以作为回文序列的“外壳”。</li>
<li>操作：LPS 的长度至少为 2（s[i] 和 s[j]）。</li>
<li>子问题：我们只需要再知道内部区间 [i+1, j-1] 的 LPS 长度（即
dp[i+1][j-1]）即可。</li>
<li>转移方程 (1)：dp[i][j] = dp[i+1][j-1] + 2</li>
</ul></li>
<li>情况二：两端字符不等 s[i] != s[j]
<ul>
<li>例如：s[i…j] = “a…b”</li>
<li>分析：s[i] 和 s[j] 不能同时作为回文的“外壳”。我们必须丢弃一个。</li>
<li>操作：我们有两个选择，取其中能得到最长回文的那一个：
<ul>
<li>丢弃 s[i]：我们在区间 [i+1, j] 中寻找 LPS。解是 dp[i+1][j]。</li>
<li>丢弃 s[j]：我们在区间 [i, j-1] 中寻找 LPS。解是 dp[i][j-1]。</li>
</ul></li>
<li>转移方程 (2)：dp[i][j] = max(dp[i+1][j], dp[i][j-1])</li>
</ul></li>
</ul>
<h4 id="树形dp">树形DP</h4>
<p>树形DP是一类特殊的动态规划问题，通常用于解决树结构上的最优子结构问题。与传统的线性动态规划不同，树形DP需要考虑节点之间的层级关系和子树结构。</p>
<p>且树形DP通常采用后序遍历的方式进行状态转移，因为每个节点的状态依赖于其子节点的状态。这样还会导致树形DP通常依旧使用递归实现，而不是迭代保存dp表这样的做法.</p>
<p>例题: 在二叉树上“打家劫舍”，不能偷相邻（父子）的。 分析：对于一个节点
root，它的最优解依赖于 root-&gt;left 和 root-&gt;right
的最优解。(Leetcode 337题) <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">unordered_map&lt;TreeNode*,<span class="type">int</span>&gt; map;  <span class="comment">// 来缓存已经计算过的节点结果</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">rob</span><span class="params">(TreeNode* root)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(map.<span class="built_in">contains</span>(root)) <span class="keyword">return</span> map[root];  <span class="comment">// 如果已经计算过，直接返回缓存结果</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> max1 = <span class="built_in">rob</span>(root-&gt;left)+<span class="built_in">rob</span>(root-&gt;right);    <span class="comment">// 不偷 root, 取左右子树的和</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 偷 root, 则不能偷左右子节点, 转而偷左右子节点的子节点</span></span><br><span class="line">    <span class="type">int</span> max2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(root-&gt;left!=<span class="literal">nullptr</span>) max2+=<span class="built_in">rob</span>(root-&gt;left-&gt;left)+<span class="built_in">rob</span>(root-&gt;left-&gt;right);</span><br><span class="line">    <span class="keyword">if</span>(root-&gt;right!=<span class="literal">nullptr</span>) max2+=<span class="built_in">rob</span>(root-&gt;right-&gt;left)+<span class="built_in">rob</span>(root-&gt;right-&gt;right);</span><br><span class="line">    max2 += root-&gt;val;  <span class="comment">// 加上 root 的值</span></span><br><span class="line"></span><br><span class="line">    map[root] = <span class="built_in">max</span>(max1,max2);  <span class="comment">// 缓存结果</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(max1,max2);  <span class="comment">// 返回结果</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure></div></p>

		</div>

		

		
		<ul class="post-tags-box text-lg mt-1.5 flex-wrap justify-center flex md:hidden">
			
			<li class="tag-item mx-0.5">
				<a href="/tags/algorithms/">#algorithms</a>&nbsp;
			</li>
			
			<li class="tag-item mx-0.5">
				<a href="/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/">#动态规划</a>&nbsp;
			</li>
			
		</ul>
		

		

		
		<div class="article-nav my-8 flex justify-between items-center px-2 sm:px-6 md:px-8">
			
			<div class="article-prev border-border-color shadow-redefine-flat shadow-shadow-color-2 rounded-medium px-4 py-2 hover:shadow-redefine-flat-hover hover:shadow-shadow-color-2">
				<a class="prev" rel="prev" href="/2025/09/03/lang/CPP/STL%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%AD%97%E7%AC%A6%E4%B8%B2/">
					<span class="left arrow-icon flex justify-center items-center">
						<i class="fa-solid fa-chevron-left"></i>
					</span>
					<span class="title flex justify-center items-center">
						<span class="post-nav-title-item truncate max-w-48">字符串</span>
						<span class="post-nav-item">Prev posts</span>
					</span>
				</a>
			</div>
			
			
			<div class="article-next border-border-color shadow-redefine-flat shadow-shadow-color-2 rounded-medium px-4 py-2 hover:shadow-redefine-flat-hover hover:shadow-shadow-color-2">
				<a class="next" rel="next" href="/2025/09/01/web/Computer%20Network/OSI/2.%20OSI/">
					<span class="title flex justify-center items-center">
						<span class="post-nav-title-item truncate max-w-48">OSI model</span>
						<span class="post-nav-item">Next posts</span>
					</span>
					<span class="right arrow-icon flex justify-center items-center">
						<i class="fa-solid fa-chevron-right"></i>
					</span>
				</a>
			</div>
			
		</div>
		


		
	</div>

	
	<div class="toc-content-container">
		<div class="post-toc-wrap">
	<div class="post-toc">
		<div class="toc-title">On this page</div>
		<div class="page-title">动态规划(Dynamic Programming)</div>
		<ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%82%E7%94%A8%E6%9D%A1%E4%BB%B6"><span class="nav-text">适用条件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E6%AD%A5%E9%AA%A4"><span class="nav-text">解题步骤</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%A4%E7%A7%8D%E6%A8%A1%E5%BC%8F"><span class="nav-text">两种模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E7%BB%B4%E9%99%8D%E4%B8%80%E7%BB%B4"><span class="nav-text">二维降一维</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BE%8B%E9%A2%98"><span class="nav-text">例题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BE%8B%E9%A2%982-%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86"><span class="nav-text">例题2: 单词拆分</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BE%8B%E9%A2%983-0-1%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98"><span class="nav-text">例题3: 0-1背包问题</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BA%8C%E7%BB%B4%E9%99%8D%E4%B8%80%E7%BB%B4-1"><span class="nav-text">二维降一维</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BA%8C%E7%BB%B40-1%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98"><span class="nav-text">二维0-1背包问题</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98"><span class="nav-text">完全背包问题</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85%E4%B8%AD%E7%9A%84%E6%8E%92%E5%88%97%E5%92%8C%E7%BB%84%E5%90%88%E9%97%AE%E9%A2%98"><span class="nav-text">完全背包中的排列和组合问题</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8C%E7%BB%B4-dp"><span class="nav-text">二维 DP</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%8F%E5%85%B8%E5%BA%8F%E5%88%97-dp-lcs-lis"><span class="nav-text">经典序列 DP (LCS &amp; LIS)</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BE%8B%E9%A2%98-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97-lcs"><span class="nav-text">例题: 最长公共子序列 (LCS)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BE%8B%E9%A2%98-%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97"><span class="nav-text">例题: 最长递增子序列</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%8A%B6%E6%80%81%E6%9C%BA-dp"><span class="nav-text">状态机 DP</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BB%8F%E5%85%B8%E7%A4%BA%E4%BE%8Blc-309-%E5%B8%A6%E5%86%B7%E5%86%BB%E6%9C%9F%E7%9A%84%E8%82%A1%E7%A5%A8"><span class="nav-text">经典示例：LC 309
(带冷冻期的股票)</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%92%E5%88%86%E5%9E%8B-dp-partition-dp"><span class="nav-text">划分型 DP (Partition DP)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8C%BA%E9%97%B4-dp-interval-dp"><span class="nav-text">区间 DP (Interval DP)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%91%E5%BD%A2dp"><span class="nav-text">树形DP</span></a></li></ol></li></ol>

	</div>
</div>
	</div>
	
</div>
			</div>

			
		</div>

		<div class="main-content-footer">
			<footer class="footer mt-5 py-5 h-auto text-base text-third-text-color relative border-t-2 border-t-border-color">
    <div class="info-container py-3 text-center">
        
            <div class="customize-info my-1">AI是新时代的灯塔</div>
        
        <div class="text-center">
            &copy;
            
              <span>2025</span>
              -
            
            2025&nbsp;&nbsp;<i class="fa-solid fa-heart fa-beat" style="--fa-animation-duration: 0.5s; color: #f54545"></i>&nbsp;&nbsp;<a href="/">ZaynPei</a>
            
                
                <p class="post-count space-x-0.5">
                    <span>
                        193 posts in total
                    </span>
                    
                        <span>
                            609.9k words in total
                        </span>
                    
                </p>
            
        </div>
        
        <div class="relative text-center lg:absolute lg:left-[20px] lg:top-1/2 lg:-translate-y-1/2 lg:text-left">
            <span class="lg:block text-sm">POWERED BY <?xml version="1.0" encoding="utf-8"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg class="relative top-[2px] inline-block align-baseline" version="1.1" id="圖層_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="1rem" height="1rem" viewBox="0 0 512 512" enable-background="new 0 0 512 512" xml:space="preserve"><path fill="#0E83CD" d="M256.4,25.8l-200,115.5L56,371.5l199.6,114.7l200-115.5l0.4-230.2L256.4,25.8z M349,354.6l-18.4,10.7l-18.6-11V275H200v79.6l-18.4,10.7l-18.6-11v-197l18.5-10.6l18.5,10.8V237h112v-79.6l18.5-10.6l18.5,10.8V354.6z"/></svg><a target="_blank" class="text-base" href="https://hexo.io">Hexo</a></span>
            <span class="text-sm lg:block">THEME&nbsp;<a class="text-base" target="_blank" href="https://github.com/EvanNotFound/hexo-theme-redefine">Redefine v2.8.5</a></span>
        </div>
        
        
            <div>
                Blog up for <span class="odometer" id="runtime_days" ></span> days <span class="odometer" id="runtime_hours"></span> hrs <span class="odometer" id="runtime_minutes"></span> Min <span class="odometer" id="runtime_seconds"></span> Sec
            </div>
        
        
            <script data-swup-reload-script>
                try {
                    function odometer_init() {
                    const elements = document.querySelectorAll('.odometer');
                    elements.forEach(el => {
                        new Odometer({
                            el,
                            format: '( ddd).dd',
                            duration: 200
                        });
                    });
                    }
                    odometer_init();
                } catch (error) {}
            </script>
        
        
            
                
        
                
        
        
    </div>  
</footer>
		</div>
	</div>

	
	<div class="post-tools">
		<div class="post-tools-container">
	<ul class="article-tools-list">
		<!-- TOC aside toggle -->
		
		<li class="right-bottom-tools page-aside-toggle">
			<i class="fa-regular fa-outdent"></i>
		</li>
		

		<!-- go comment -->
		
	</ul>
</div>
	</div>
	

	<div class="right-side-tools-container">
		<div class="side-tools-container">
	<ul class="hidden-tools-list">
		<li class="right-bottom-tools tool-font-adjust-plus flex justify-center items-center">
			<i class="fa-regular fa-magnifying-glass-plus"></i>
		</li>

		<li class="right-bottom-tools tool-font-adjust-minus flex justify-center items-center">
			<i class="fa-regular fa-magnifying-glass-minus"></i>
		</li>

		<li class="right-bottom-tools tool-dark-light-toggle flex justify-center items-center">
			<i class="fa-regular fa-moon"></i>
		</li>

		<!-- rss -->
		

		

		<li class="right-bottom-tools tool-scroll-to-bottom flex justify-center items-center">
			<i class="fa-regular fa-arrow-down"></i>
		</li>
	</ul>

	<ul class="visible-tools-list">
		<li class="right-bottom-tools toggle-tools-list flex justify-center items-center">
			<i class="fa-regular fa-cog fa-spin"></i>
		</li>
		
		<li class="right-bottom-tools tool-scroll-to-top flex justify-center items-center">
			<i class="arrow-up fas fa-arrow-up"></i>
			<span class="percent"></span>
		</li>
		
		
	</ul>
</div>
	</div>

	<div class="image-viewer-container">
	<img src="">
</div>

	
	<div class="search-pop-overlay">
	<div class="popup search-popup">
		<div class="search-header">
			<span class="search-input-field-pre">
				<i class="fa-solid fa-keyboard"></i>
			</span>
			<div class="search-input-container">
				<input autocomplete="off" autocorrect="off" autocapitalize="off" placeholder="Search..." spellcheck="false" type="search" class="search-input">
			</div>
			<span class="popup-btn-close">
				<i class="fa-solid fa-times"></i>
			</span>
		</div>
		<div id="search-result">
			<div id="no-result">
				<i class="fa-solid fa-spinner fa-spin-pulse fa-5x fa-fw"></i>
			</div>
		</div>
	</div>
</div>
	

</main>



<script src="/js/build/libs/Swup.min.js"></script>

<script src="/js/build/libs/SwupSlideTheme.min.js"></script>

<script src="/js/build/libs/SwupScriptsPlugin.min.js"></script>

<script src="/js/build/libs/SwupProgressPlugin.min.js"></script>

<script src="/js/build/libs/SwupScrollPlugin.min.js"></script>

<script src="/js/build/libs/SwupPreloadPlugin.min.js"></script>

<script>
    const swup = new Swup({
        plugins: [
            new SwupScriptsPlugin({
                optin: true,
            }),
            new SwupProgressPlugin(),
            new SwupScrollPlugin({
                offset: 80,
            }),
            new SwupSlideTheme({
                mainElement: ".main-content-body",
            }),
            new SwupPreloadPlugin(),
        ],
        containers: ["#swup"],
    });
</script>




	
<script src="/js/build/tools/imageViewer.js" type="module"></script>

<script src="/js/build/utils.js" type="module"></script>

<script src="/js/build/main.js" type="module"></script>

<script src="/js/build/layouts/navbarShrink.js" type="module"></script>

<script src="/js/build/tools/scrollTopBottom.js" type="module"></script>

<script src="/js/build/tools/lightDarkSwitch.js" type="module"></script>

<script src="/js/build/layouts/categoryList.js" type="module"></script>



    
<script src="/js/build/tools/localSearch.js" type="module"></script>




    
<script src="/js/build/tools/codeBlock.js" type="module"></script>




    
<script src="/js/build/layouts/lazyload.js" type="module"></script>




    
<script src="/js/build/tools/runtime.js"></script>

    
<script src="/js/build/libs/odometer.min.js"></script>

    
<link rel="stylesheet" href="/assets/odometer-theme-minimal.css">




  
<script src="/js/build/libs/Typed.min.js"></script>

  
<script src="/js/build/plugins/typed.js" type="module"></script>








    
<script src="/js/build/libs/anime.min.js"></script>





    
<script src="/js/build/tools/tocToggle.js" type="module" data-swup-reload-script=""></script>

<script src="/js/build/layouts/toc.js" type="module" data-swup-reload-script=""></script>

<script src="/js/build/plugins/tabs.js" type="module" data-swup-reload-script=""></script>




<script src="/js/build/libs/moment-with-locales.min.js" data-swup-reload-script=""></script>


<script src="/js/build/layouts/essays.js" type="module" data-swup-reload-script=""></script>





	
</body>

</html>