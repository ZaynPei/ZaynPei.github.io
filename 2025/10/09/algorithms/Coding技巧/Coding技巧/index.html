<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="keywords" content="Hexo Theme Redefine">
    
    <meta name="author" content="ZaynPei">
    
    <!-- Completely eliminate flash of wrong theme -->
    <script>
        (function() {
            const THEME_KEY = "REDEFINE-THEME-STATUS";
            const DARK = "dark", LIGHT = "light";
            
            // Get preferred theme
            function getTheme() {
                try {
                    const saved = localStorage.getItem(THEME_KEY);
                    if (saved) {
                        const { isDark } = JSON.parse(saved);
                        return isDark ? DARK : LIGHT;
                    }
                } catch (e) {}
                
                return matchMedia("(prefers-color-scheme: dark)").matches ? DARK : LIGHT;
            }
            
            // Apply theme to document
            function applyTheme(theme) {
                const isDark = theme === DARK;
                const root = document.documentElement;
                
                // Set data attribute for CSS variables
                root.setAttribute("data-theme", theme);
                
                // Set classes for compatibility
                root.classList.add(theme);
                root.classList.remove(isDark ? LIGHT : DARK);
                root.style.colorScheme = theme;
            }
            
            // Initial application
            const theme = getTheme();
            applyTheme(theme);
            
            // Listen for system preference changes
            matchMedia("(prefers-color-scheme: dark)").addEventListener("change", ({ matches }) => {
                // Only update if using system preference (no localStorage entry)
                if (!localStorage.getItem(THEME_KEY)) {
                    applyTheme(matches ? DARK : LIGHT);
                }
            });
            
            // Set body classes once DOM is ready
            if (document.readyState !== "loading") {
                document.body.classList.add(theme + "-mode");
            } else {
                document.addEventListener("DOMContentLoaded", () => {
                    document.body.classList.add(theme + "-mode");
                    document.body.classList.remove((theme === DARK ? LIGHT : DARK) + "-mode");
                });
            }
        })();
    </script>
    
    <!-- Critical CSS to prevent flash -->
    <style>
        :root[data-theme="dark"] {
            --background-color: #202124;
            --background-color-transparent: rgba(32, 33, 36, 0.6);
            --second-background-color: #2d2e32;
            --third-background-color: #34353a;
            --third-background-color-transparent: rgba(32, 33, 36, 0.6);
            --primary-color: #0066CC;
            --first-text-color: #ffffff;
            --second-text-color: #eeeeee;
            --third-text-color: #bebec6;
            --fourth-text-color: #999999;
            --default-text-color: #bebec6;
            --invert-text-color: #373D3F;
            --border-color: rgba(255, 255, 255, 0.08);
            --selection-color: #0066CC;
            --shadow-color-1: rgba(255, 255, 255, 0.08);
            --shadow-color-2: rgba(255, 255, 255, 0.05);
        }
        
        :root[data-theme="light"] {
            --background-color: #fff;
            --background-color-transparent: rgba(255, 255, 255, 0.6);
            --second-background-color: #f8f8f8;
            --third-background-color: #f2f2f2;
            --third-background-color-transparent: rgba(241, 241, 241, 0.6);
            --primary-color: #0066CC;
            --first-text-color: #16171a;
            --second-text-color: #2f3037;
            --third-text-color: #5e5e5e;
            --fourth-text-color: #eeeeee;
            --default-text-color: #373D3F;
            --invert-text-color: #bebec6;
            --border-color: rgba(0, 0, 0, 0.08);
            --selection-color: #0066CC;
            --shadow-color-1: rgba(0, 0, 0, 0.08);
            --shadow-color-2: rgba(0, 0, 0, 0.05);
        }
        
        body {
            background-color: var(--background-color);
            color: var(--default-text-color);
        }
        
        /* Apply body classes as soon as DOM is ready */
        :root[data-theme="dark"] body {
            background-color: var(--background-color);
            color: var(--default-text-color);
        }
    </style>
    
    <!-- preconnect -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>

    
    <!--- Seo Part-->
    
    <link rel="canonical" href="https://zaynpei.github.io/2025/10/09/algorithms/coding技巧/coding技巧/"/>
    <meta name="robots" content="index,follow">
    <meta name="googlebot" content="index,follow">
    <meta name="revisit-after" content="1 days">
    
    
    
        
        <meta name="description" content="Hexo Theme Redefine, Redefine Your Hexo Journey.">
<meta property="og:type" content="article">
<meta property="og:title" content="Coding技巧">
<meta property="og:url" content="https://zaynpei.github.io/2025/10/09/algorithms/Coding%E6%8A%80%E5%B7%A7/Coding%E6%8A%80%E5%B7%A7/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="Hexo Theme Redefine, Redefine Your Hexo Journey.">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://zaynpei.github.io/images/redefine-og.webp">
<meta property="article:published_time" content="2025-10-09T14:00:00.000Z">
<meta property="article:modified_time" content="2025-10-29T14:23:08.755Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="algorithms">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://zaynpei.github.io/images/redefine-og.webp">
    
    
    <!--- Icon Part-->
    <link rel="icon" type="image/png" href="/images/icons%E7%81%AF%E5%A1%94.png" sizes="192x192">
    <link rel="apple-touch-icon" sizes="180x180" href="/images/icons%E7%81%AF%E5%A1%94.png">
    <meta name="theme-color" content="#A31F34">
    <link rel="shortcut icon" href="/images/icons%E7%81%AF%E5%A1%94.png">
    <!--- Page Info-->
    
    <title>
        
            Coding技巧 | ZaynPei&#39;s Base
        
    </title>

    
<link rel="stylesheet" href="/fonts/Chillax/chillax.css">


    <!--- Inject Part-->
    
        
            
    
            
    
            
                
                    <link rel="stylesheet" href="/css/custom.css">
                
    

    
<link rel="stylesheet" href="/css/style.css">


    
        
<link rel="stylesheet" href="/css/build/tailwind.css">

    

    
<link rel="stylesheet" href="/fonts/GeistMono/geist-mono.css">

    
<link rel="stylesheet" href="/fonts/Geist/geist.css">

    <!--- Font Part-->
    
    
        <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;700&display=swap" rel="stylesheet">
    
    
        <link href="https://cdn.jsdelivr.net/npm/@callmebill/lxgw-wenkai-web@1.320/style.css" rel="stylesheet">
    
    
    
    

    <script id="hexo-configurations">
    window.config = {"hostname":"zaynpei.github.io","root":"/","language":"en","path":"search.json"};
    window.theme = {"articles":{"style":{"font_size":"16px","line_height":1.5,"image_border_radius":"14px","image_alignment":"center","image_caption":false,"link_icon":true,"delete_mask":false,"title_alignment":"left","headings_top_spacing":{"h1":"3.2rem","h2":"2.4rem","h3":"1.9rem","h4":"1.6rem","h5":"1.4rem","h6":"1.3rem"}},"word_count":{"enable":true,"count":true,"min2read":true},"author_label":{"enable":true,"auto":false,"list":[]},"code_block":{"copy":true,"style":"mac","highlight_theme":{"light":"default","dark":"a11y-dark"},"font":{"enable":true,"family":"'JetBrains Mono', monospace","url":"https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;700&display=swap"}},"toc":{"enable":true,"max_depth":6,"number":false,"expand":true,"init_open":true},"copyright":{"enable":false,"default":"cc_by_nc_sa"},"lazyload":true,"pangu_js":false,"recommendation":{"enable":false,"title":"推荐阅读","limit":3,"mobile_limit":2,"placeholder":"/images/wallhaven-wqery6-light.webp","skip_dirs":[]},"font":{"enable":true,"url":"https://cdn.jsdelivr.net/npm/@callmebill/lxgw-wenkai-web@1.320/style.css","family":"'LXGW WenKai', sans-serif"}},"colors":{"primary":"#A31F34","secondary":null,"default_mode":"light"},"global":{"fonts":{"chinese":{"enable":true,"family":"'LXGW WenKai', sans-serif","url":"https://cdn.jsdelivr.net/npm/@callmebill/lxgw-wenkai-web@1.320/style.css"},"english":{"enable":false,"family":null,"url":null},"title":{"enable":false,"family":null,"url":null}},"content_max_width":"1000px","sidebar_width":"210px","hover":{"shadow":true,"scale":false},"scroll_progress":{"bar":false,"percentage":true},"website_counter":{"url":"https://cn.vercount.one/js","enable":false,"site_pv":true,"site_uv":true,"post_pv":true},"single_page":true,"preloader":{"enable":false,"custom_message":null},"side_tools":{"gear_rotation":true,"auto_expand":false},"open_graph":{"enable":true,"image":"/images/redefine-og.webp","description":"Hexo Theme Redefine, Redefine Your Hexo Journey."},"google_analytics":{"enable":false,"id":null}},"home_banner":{"enable":true,"style":"fixed","image":{"light":"/images/wallhaven-wqery6-light.webp","dark":"/images/wallhaven-wqery6-dark.webp"},"title":"For ourselves","subtitle":{"text":["For yourself"],"hitokoto":{"enable":false,"show_author":false,"api":"https://v1.hitokoto.cn"},"typing_speed":100,"backing_speed":80,"starting_delay":500,"backing_delay":1500,"loop":true,"smart_backspace":true},"text_color":{"light":"#fff","dark":"#d1d1b6"},"text_style":{"title_size":"2.8rem","subtitle_size":"1.5rem","line_height":1.2},"custom_font":{"enable":false,"family":null,"url":null},"social_links":{"enable":false,"style":"default","links":{"github":null,"instagram":null,"zhihu":null,"twitter":null,"email":null},"qrs":{"weixin":null}}},"plugins":{"feed":{"enable":false},"aplayer":{"enable":false,"type":"fixed","audios":[{"name":null,"artist":null,"url":null,"cover":null,"lrc":null}]},"mermaid":{"enable":false,"version":"11.4.1"}},"version":"2.8.5","navbar":{"auto_hide":false,"color":{"left":"#f78736","right":"#367df7","transparency":35},"width":{"home":"1200px","pages":"1000px"},"links":{"Home":{"path":"/","icon":"fa-regular fa-house"},"ai":{"path":"docs/ai/","icon":"fa-regular fa-robot"},"algorithms":{"path":"docs/algorithms/","icon":"fa-regular fa-code"},"language":{"path":"docs/lang/","icon":"fa-regular fa-language"},"system":{"path":"docs/system/","icon":"fa-regular fa-desktop"},"web":{"path":"docs/web/","icon":"fa-regular fa-globe"},"misc":{"path":"docs/misc/","icon":"fa-regular fa-boxes-stacked"},"tools":{"path":"docs/tools/","icon":"fa-regular fa-wrench"}},"search":{"enable":true,"preload":true}},"page_templates":{"friends_column":2,"tags_style":"blur"},"home":{"sidebar":{"enable":true,"position":"left","first_item":"menu","announcement":null,"show_on_mobile":true,"links":null},"article_date_format":"auto","excerpt_length":200,"categories":{"enable":true,"limit":3},"tags":{"enable":true,"limit":3}},"footerStart":"2025/6/25 13:20:00"};
    window.lang_ago = {"second":"%s seconds ago","minute":"%s minutes ago","hour":"%s hours ago","day":"%s days ago","week":"%s weeks ago","month":"%s months ago","year":"%s years ago"};
    window.data = {"masonry":false};
  </script>
    
    <!--- Fontawesome Part-->
    
<link rel="stylesheet" href="/fontawesome/fontawesome.min.css">

    
<link rel="stylesheet" href="/fontawesome/brands.min.css">

    
<link rel="stylesheet" href="/fontawesome/solid.min.css">

    
<link rel="stylesheet" href="/fontawesome/regular.min.css">

    
    
    
    
<meta name="generator" content="Hexo 7.3.0"><style>mjx-container[jax="SVG"] {
  direction: ltr;
}

mjx-container[jax="SVG"] > svg {
  overflow: visible;
}

mjx-container[jax="SVG"][display="true"] {
  display: block;
  text-align: center;
  margin: 1em 0;
}

mjx-container[jax="SVG"][justify="left"] {
  text-align: left;
}

mjx-container[jax="SVG"][justify="right"] {
  text-align: right;
}

g[data-mml-node="merror"] > g {
  fill: red;
  stroke: red;
}

g[data-mml-node="merror"] > rect[data-background] {
  fill: yellow;
  stroke: none;
}

g[data-mml-node="mtable"] > line[data-line] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > rect[data-frame] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > .mjx-dashed {
  stroke-dasharray: 140;
}

g[data-mml-node="mtable"] > .mjx-dotted {
  stroke-linecap: round;
  stroke-dasharray: 0,140;
}

g[data-mml-node="mtable"] > svg {
  overflow: visible;
}

[jax="SVG"] mjx-tool {
  display: inline-block;
  position: relative;
  width: 0;
  height: 0;
}

[jax="SVG"] mjx-tool > mjx-tip {
  position: absolute;
  top: 0;
  left: 0;
}

mjx-tool > mjx-tip {
  display: inline-block;
  padding: .2em;
  border: 1px solid #888;
  font-size: 70%;
  background-color: #F8F8F8;
  color: black;
  box-shadow: 2px 2px 5px #AAAAAA;
}

g[data-mml-node="maction"][data-toggle] {
  cursor: pointer;
}

mjx-status {
  display: block;
  position: fixed;
  left: 1em;
  bottom: 1em;
  min-width: 25%;
  padding: .2em .4em;
  border: 1px solid #888;
  font-size: 90%;
  background-color: #F8F8F8;
  color: black;
}

foreignObject[data-mjx-xml] {
  font-family: initial;
  line-height: normal;
  overflow: visible;
}

.MathJax path {
  stroke-width: 3;
}

mjx-container[display="true"] {
  overflow: auto hidden;
}

mjx-container[display="true"] + br {
  display: none;
}
</style></head>



<body>
	<div class="progress-bar-container">
	

	
	<span class="pjax-progress-bar"></span>
	<!--        <span class="swup-progress-icon">-->
	<!--            <i class="fa-solid fa-circle-notch fa-spin"></i>-->
	<!--        </span>-->
	
</div>

<main class="page-container" id="swup">

	

	<div class="main-content-container flex flex-col justify-between min-h-dvh">
		<div class="main-content-header">
			<header class="navbar-container px-6 md:px-12">
    <div class="navbar-content transition-navbar ">
        <div class="left">
            
                <a class="logo-image h-8 w-8 sm:w-10 sm:h-10 mr-3" href="/">
                    <img src="/images/icons%E7%81%AF%E5%A1%94.png" class="w-full h-full rounded-xs">
                </a>
            
            <a class="logo-title" href="/">
                
                ZaynPei&#39;s Base
                
            </a>
        </div>

        <div class="right">
            <!-- PC -->
            <div class="desktop">
                <ul class="navbar-list">
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class=""
                                   href="/"
                                        >
                                    <i class="fa-regular fa-house fa-fw"></i>
                                    HOME
                                    
                                </a>

                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class=""
                                   href="/docs/ai/"
                                        >
                                    <i class="fa-regular fa-robot fa-fw"></i>
                                    AI
                                    
                                </a>

                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class=""
                                   href="/docs/algorithms/"
                                        >
                                    <i class="fa-regular fa-code fa-fw"></i>
                                    ALGORITHMS
                                    
                                </a>

                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class=""
                                   href="/docs/lang/"
                                        >
                                    <i class="fa-regular fa-language fa-fw"></i>
                                    LANGUAGE
                                    
                                </a>

                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class=""
                                   href="/docs/system/"
                                        >
                                    <i class="fa-regular fa-desktop fa-fw"></i>
                                    SYSTEM
                                    
                                </a>

                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class=""
                                   href="/docs/web/"
                                        >
                                    <i class="fa-regular fa-globe fa-fw"></i>
                                    WEB
                                    
                                </a>

                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class=""
                                   href="/docs/misc/"
                                        >
                                    <i class="fa-regular fa-boxes-stacked fa-fw"></i>
                                    MISC
                                    
                                </a>

                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class=""
                                   href="/docs/tools/"
                                        >
                                    <i class="fa-regular fa-wrench fa-fw"></i>
                                    TOOLS
                                    
                                </a>

                                <!-- Submenu -->
                                
                            </li>
                    
                    
                        <li class="navbar-item search search-popup-trigger">
                            <i class="fa-solid fa-magnifying-glass"></i>
                        </li>
                    
                </ul>
            </div>
            <!-- Mobile -->
            <div class="mobile">
                
                    <div class="icon-item search search-popup-trigger"><i class="fa-solid fa-magnifying-glass"></i>
                    </div>
                
                <div class="icon-item navbar-bar">
                    <div class="navbar-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Mobile sheet -->
    <div class="navbar-drawer h-dvh w-full absolute top-0 left-0 bg-background-color flex flex-col justify-between">
        <ul class="drawer-navbar-list flex flex-col px-4 justify-center items-start">
            
                
                    

                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                           href="/"
                        >
                            <span>
                                HOME
                            </span>
                            
                                <i class="fa-regular fa-house fa-sm fa-fw"></i>
                            
                        </a>
                        

                        
                    </li>
            
                
                    

                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                           href="/docs/ai/"
                        >
                            <span>
                                AI
                            </span>
                            
                                <i class="fa-regular fa-robot fa-sm fa-fw"></i>
                            
                        </a>
                        

                        
                    </li>
            
                
                    

                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                           href="/docs/algorithms/"
                        >
                            <span>
                                ALGORITHMS
                            </span>
                            
                                <i class="fa-regular fa-code fa-sm fa-fw"></i>
                            
                        </a>
                        

                        
                    </li>
            
                
                    

                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                           href="/docs/lang/"
                        >
                            <span>
                                LANGUAGE
                            </span>
                            
                                <i class="fa-regular fa-language fa-sm fa-fw"></i>
                            
                        </a>
                        

                        
                    </li>
            
                
                    

                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                           href="/docs/system/"
                        >
                            <span>
                                SYSTEM
                            </span>
                            
                                <i class="fa-regular fa-desktop fa-sm fa-fw"></i>
                            
                        </a>
                        

                        
                    </li>
            
                
                    

                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                           href="/docs/web/"
                        >
                            <span>
                                WEB
                            </span>
                            
                                <i class="fa-regular fa-globe fa-sm fa-fw"></i>
                            
                        </a>
                        

                        
                    </li>
            
                
                    

                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                           href="/docs/misc/"
                        >
                            <span>
                                MISC
                            </span>
                            
                                <i class="fa-regular fa-boxes-stacked fa-sm fa-fw"></i>
                            
                        </a>
                        

                        
                    </li>
            
                
                    

                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                           href="/docs/tools/"
                        >
                            <span>
                                TOOLS
                            </span>
                            
                                <i class="fa-regular fa-wrench fa-sm fa-fw"></i>
                            
                        </a>
                        

                        
                    </li>
            

            
            
        </ul>

        <div class="statistics flex justify-around my-2.5">
    <a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/tags">
        <div class="number text-2xl sm:text-xl text-second-text-color font-semibold">19</div>
        <div class="label text-third-text-color text-sm">Tags</div>
    </a>
    <a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/categories">
        <div class="number text-2xl sm:text-xl text-second-text-color font-semibold">21</div>
        <div class="label text-third-text-color text-sm">Categories</div>
    </a>
    <a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/archives">
        <div class="number text-2xl sm:text-xl text-second-text-color font-semibold">186</div>
        <div class="label text-third-text-color text-sm">Posts</div>
    </a>
</div>
    </div>

    <div class="window-mask"></div>

</header>


		</div>

		<div class="main-content-body transition-fade-up">
			

			<div class="main-content">
				<div class="post-page-container flex relative justify-between box-border w-full h-full">
	<div class="article-content-container">

		<div class="article-title relative w-full">
			
			<div class="w-full flex items-center pt-6 justify-start">
				<h1 class="article-title-regular text-second-text-color tracking-tight text-4xl md:text-6xl font-semibold px-2 sm:px-6 md:px-8 py-3">Coding技巧</h1>
			</div>
			
		</div>

		
		<div class="article-header flex flex-row gap-2 items-center px-2 sm:px-6 md:px-8">
			<div class="avatar w-[46px] h-[46px] flex-shrink-0 rounded-medium border border-border-color p-[1px]">
				<img src="/images/redefine-avatar.svg">
			</div>
			<div class="info flex flex-col justify-between">
				<div class="author flex items-center">
					<span class="name text-default-text-color text-lg font-semibold">ZaynPei</span>
					
					<span class="author-label ml-1.5 text-xs px-2 py-0.5 rounded-small text-third-text-color border border-shadow-color-1">Lv6</span>
					
				</div>
				<div class="meta-info">
					<div class="article-meta-info">
    <span class="article-date article-meta-item">
        <i class="fa-regular fa-pen-fancy"></i>&nbsp;
        <span class="desktop">2025-10-09 22:00</span>
        <span class="mobile">2025-10-09 22:00</span>
        <span class="hover-info">Created</span>
    </span>
    
        <span class="article-date article-meta-item">
            <i class="fa-regular fa-wrench"></i>&nbsp;
            <span class="desktop">2025-10-29 22:23:08</span>
            <span class="mobile">2025-10-29 22:23:08</span>
            <span class="hover-info">Updated</span>
        </span>
    

    
        <span class="article-categories article-meta-item">
            <i class="fa-regular fa-folders"></i>&nbsp;
            <ul>
                
                
                    
                        
                        <li>
                            <a href="/categories/algorithms/">algorithms</a>&nbsp;
                        </li>
                    
                    
                
            </ul>
        </span>
    
    
        <span class="article-tags article-meta-item">
            <i class="fa-regular fa-tags"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/tags/algorithms/">algorithms</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    

    
    
        <span class="article-wordcount article-meta-item">
            <i class="fa-regular fa-typewriter"></i>&nbsp;<span>9k Words</span>
        </span>
    
    
        <span class="article-min2read article-meta-item">
            <i class="fa-regular fa-clock"></i>&nbsp;<span>35 Mins</span>
        </span>
    
    
</div>

				</div>
			</div>
		</div>
		

		


		<div class="article-content markdown-body px-2 sm:px-6 md:px-8 pb-8">
			<h2 id="二分查找">二分查找</h2>
<p>二分查找 (Binary Search)
是一种高效的查找算法，适用于在<strong>有序数组或列表</strong>中查找特定元素。它通过<strong>不断将搜索范围减半</strong>来快速定位目标元素，从而大大减少了查找的时间复杂度。</p>
<p>代码实现如下: <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">binarySearch</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>{</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) {</span><br><span class="line">        <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;  <span class="comment">// 防止溢出</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) {</span><br><span class="line">            <span class="keyword">return</span> mid;  <span class="comment">// 找到目标元素，返回其索引</span></span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) {</span><br><span class="line">            left = mid + <span class="number">1</span>;  <span class="comment">// 目标在右半部分</span></span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            right = mid - <span class="number">1</span>;  <span class="comment">// 目标在左半部分</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;  <span class="comment">// 未找到目标元素</span></span><br><span class="line">    <span class="comment">// return left;  // 如果需要返回插入位置, 可以返回 left</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure></div> &gt; 最后的 left 指向第一个大于等于
target 的位置, 也就是插入位置.</p>
<h2 id="滑动窗口">滑动窗口</h2>
<p>滑动窗口是一种用于处理<strong>数组或字符串</strong>中<strong>子序列</strong>问题的高效算法技巧。它通过维护一个<strong>动态调整的窗口</strong>来遍历数据结构，从而避免了重复计算，提高了算法的效率。</p>
<h3 id="固定长度与可变长度滑动窗口">固定长度与可变长度滑动窗口</h3>
<p>按照窗口的长度是否固定，滑动窗口可以分为两种类型： 1.
固定长度滑动窗口 (Fixed-size Sliding
Window)：窗口的大小在整个过程中保持不变。适用于寻找满足某种条件的<strong>固定长度子序列</strong>的问题。例如，寻找数组中所有长度为k的子数组的最大和。
2. 可变长度滑动窗口 (Variable-size Sliding
Window)：窗口的大小可以根据需要动态调整。适用于寻找满足某种条件的<strong>任意长度子序列</strong>的问题。例如，寻找字符串中包含所有目标字符的最短子串。</p>
<h4 id="固定长度滑动窗口">固定长度滑动窗口</h4>
<p>固定长度滑动窗口的基本思想是维护一个<strong>固定大小的窗口</strong>，并通过移动窗口来遍历数组或字符串。
-
初始化时，窗口覆盖数据结构的<strong>前k个元素</strong>，计算初始窗口的相关信息（如和、最大值等）。
- 循环遍历,
逐步向右移动窗口，每次移动一位，通过<strong>加入新元素</strong>并<strong>移除旧元素</strong>来更新窗口的信息。</p>
<p>例如, 寻找数组中所有长度为k的子数组的最大和: <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxSumSubarray</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>{</span><br><span class="line">    <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (n &lt; k) <span class="keyword">return</span> <span class="number">-1</span>;  <span class="comment">// 不合法的输入</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> maxSum = <span class="number">0</span>;  <span class="comment">// 记录最大和</span></span><br><span class="line">    <span class="type">int</span> cur = <span class="number">0</span>;  <span class="comment">// 记录当前窗口和</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化窗口</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; i++) {</span><br><span class="line">        cur += nums[i];</span><br><span class="line">    }</span><br><span class="line">    maxSum = cur;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环移动窗口</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n-k; i++) {</span><br><span class="line">        cur += nums[i+k<span class="number">-1</span>] - nums[i<span class="number">-1</span>];  <span class="comment">// 更新窗口和</span></span><br><span class="line">        maxSum = <span class="built_in">max</span>(maxSum, cur);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> maxSum;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>
对于其他问题, 只要窗口大小固定, 都可以使用类似的方法进行处理,
基本套路都是两步走: 初始化窗口 -&gt; 移动窗口并更新结果.</p>
<h5 id="示例">示例</h5>
<p>有这样一道题(leetcode239): 给你一个整数数组 nums，有一个大小为 k
的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k
个数字。滑动窗口每次只向右移动一位。返回滑动窗口中的最大值。</p>
<p>看起来是固定长度滑动窗口问题,
但是如果直接用上面的固定长度滑动窗口方法, 每次移动窗口都需要遍历窗口内的
k 个元素来找最大值, 时间复杂度是 O(n*k), 会超时.</p>
<p>为什么呢? 因为上面的其他固定长度滑动窗口问题, 每次移动窗口时,
只需要<strong>加上新元素, 减去旧元素</strong>, 窗口内的信息更新是 O(1)
的, 但是求最大值就不行了, 每次移动窗口时,
上一次的最大值可能被移出了窗口, 而我们又没有记录其他元素的信息,
只能遍历窗口内的 k 个元素来找最大值, 这样时间复杂度就是 O(n*k) 了.</p>
<p>为了解决这个问题,
我们需要使用一种特殊的数据结构——<strong>单调队列</strong>，来维护窗口内的元素顺序,
使得我们可以在 O(1) 时间内获取窗口的最大值.
具体代码可以参考队列部分的笔记.</p>
<h4 id="可变长度滑动窗口">可变长度滑动窗口</h4>
<p>可变长度滑动窗口的核心思想是通过<strong>调整窗口的左右边界</strong>来满足特定条件。通常使用<strong>两个指针/索引</strong>（left
和 right）来表示窗口的边界。 - 初始化时，left 和 right
指针都指向数据结构的<strong>起始</strong>位置。 - 循环遍历,
通过<strong>移动 right
指针</strong>来扩展窗口，直到窗口<strong>满足某种条件</strong>（如包含所有目标字符）。
- 然后通过<strong>移动 left
指针来收缩窗口</strong>，直到窗口<strong>不再满足条件</strong>。在这个过程中，<strong>记录</strong>满足条件的窗口信息（如最短长度、最大长度等）。
- 重复上述过程，直到 <strong>right 指针遍历完整个数据结构</strong>。</p>
<blockquote>
<p>注意:
可变长度滑动窗口通常需要一个<strong>辅助数据结构</strong>（如哈希表）来记录窗口内的元素信息，以便<strong>快速判断窗口是否满足条件</strong>。</p>
</blockquote>
<p>一般可变长度滑动窗口的题型有三种: 1.
找出满足某种条件的<strong>最小子数组/子字符串</strong>。 2.
找出满足某种条件的<strong>最大子数组/子字符串</strong>。 3.
计算满足某种条件的<strong>子数组/子字符串的数量</strong>。</p>
<p>例如, 给定一个含有 n 个正整数的数组和一个正整数 target ,
找出该数组中满足其和 ≥ target
的<strong>长度最小的连续子数组</strong>的长度: (最小长度子数组问题)
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="type">int</span> target, vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>{</span><br><span class="line">    <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span>(target&gt;<span class="built_in">accumulate</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>(),<span class="number">0</span>)) <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">// 特殊情况处理</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> left=<span class="number">0</span>, right=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> minlen = INT_MAX;</span><br><span class="line">    <span class="type">int</span> cur = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(right=<span class="number">0</span>;right&lt;n;right++){  <span class="comment">// 扩展窗口</span></span><br><span class="line"></span><br><span class="line">        cur += nums[right];  <span class="comment">// 增加当前窗口和</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(cur&gt;=target){  <span class="comment">// 收缩窗口</span></span><br><span class="line">            minlen = <span class="built_in">min</span>(right-left<span class="number">+1</span>, minlen);</span><br><span class="line">            cur -= nums[left];  <span class="comment">// 一定注意先减去left位置的元素, 再left++!!!!!</span></span><br><span class="line">            left++;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> minlen;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div></p>
<p>又例如, 给定一个字符串 s ,
求每个字符最多出现两次的<strong>最长子字符串的长度</strong>:
(最大长度子字符串问题) <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">lengthOfLongestSubstringTwoDistinct</span><span class="params">(string s)</span> </span>{</span><br><span class="line">    <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">3</span>) <span class="keyword">return</span> n;  <span class="comment">// 特殊情况处理</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> maxLen = <span class="number">2</span>;</span><br><span class="line">    unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; charCount;  <span class="comment">// 记录窗口内字符的出现次数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (right = <span class="number">0</span>; right &lt; n; right++) {  <span class="comment">// 扩展窗口</span></span><br><span class="line">        charCount[s[right]]++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (charCount.<span class="built_in">size</span>() &gt; <span class="number">2</span>) {  <span class="comment">// 收缩窗口, 直到左边界到达和右边界相同字符的位置</span></span><br><span class="line"></span><br><span class="line">            charCount[s[left]]--;</span><br><span class="line">            left++;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        maxLen = <span class="built_in">max</span>(maxLen, right - left + <span class="number">1</span>);  <span class="comment">// 更新最大长度</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> maxLen;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div> &gt; 其实, 之所以可以滑动窗口解决,
一个必不可少的条件就是<strong>连续性</strong>,
也就是说问题本质上是求一个<strong>连续子数组</strong>或者<strong>连续子字符串</strong>的问题,
这样才能用滑动窗口来解决.</p>
<p>下一个示例则是求子数组个数的问题: 给你一个整数数组 nums 和一个 正整数
k , 请你统计有多少满足 「 nums 中的最大 元素」<strong>至少出现 k
次</strong>(越多越行)的子数组，并返回满足这一条件的子数组的数目。</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">countSubarrays</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>{</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> left=<span class="number">0</span>, right=<span class="number">0</span>;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> sum=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> max_num=<span class="number">0</span>;  </span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> max_sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">            max_num = <span class="built_in">max</span>(nums[i], max_num);  <span class="comment">// 找到数组中的最大值</span></span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(right=<span class="number">0</span>;right&lt;n;right++){</span><br><span class="line">            <span class="keyword">if</span>(nums[right]==max_num) max_sum++;  <span class="comment">// 记录当前窗口内最大值的个数</span></span><br><span class="line">            <span class="keyword">while</span>(max_sum&gt;=k){  <span class="comment">// 收缩窗口, 不过是满足条件时</span></span><br><span class="line">                sum+=n-right;   <span class="comment">// 因为要求子数组个数, 所以每次符合条件进入收缩窗口时, 这个数组右边界到数组末尾的所有子数组都是符合条件的</span></span><br><span class="line">                <span class="keyword">if</span>(nums[left]==max_num) max_sum--;  <span class="comment">// 先减去left位置的元素对最大值个数的影响</span></span><br><span class="line">                left++;  <span class="comment">// 再移动左指针</span></span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></table></figure></div>
<p>还有一个经典问题:
给一个数组的分数定义为数组之和乘以数组的长度。比方说，[1, 2, 3, 4, 5]
的分数为 (1 + 2 + 3 + 4 + 5) * 5 = 75 。给你一个正整数数组 nums
和一个整数 k ，请你返回 nums 中分数 严格小于 k 的
非空整数子数组数目。(越小越行)</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">countSubarrays</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">long</span> <span class="type">long</span> k)</span> </span>{</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> cur_sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(right=<span class="number">0</span>;right&lt;n;right++){</span><br><span class="line">            cur_sum += nums[right];  <span class="comment">// 增加当前窗口和</span></span><br><span class="line">            <span class="keyword">while</span>(cur_sum*(right-left<span class="number">+1</span>)&gt;=k){  <span class="comment">// 收缩窗口, 如果不满足条件时</span></span><br><span class="line">                cur_sum -= nums[left];  <span class="comment">// 先减去left位置的元素对窗口和的影响</span></span><br><span class="line">                left++;  <span class="comment">// 再移动左指针</span></span><br><span class="line">            }</span><br><span class="line">            sum += (right-left<span class="number">+1</span>);  <span class="comment">// 增加符合条件的子数组个数, 这里因为求的是小于k的子数组个数, 所以所有以right结尾的子数组都是符合条件的</span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></table></figure></div>
<p>回顾上面两道题, 可以发现, 求子数组个数的问题, 每次满足条件时,
以right结尾的所有子数组, 或者是以left开头的所有子数组, 都是符合条件的,
这样就可以快速统计子数组个数. 也就是当窗口 [left, right]
满足某个条件时，其<strong>内部的某些子数组</strong>（或<strong>外部的某些超数组</strong>）也必然满足条件。我们利用这个性质来<strong>批量计数</strong>。</p>
<p>而且还可以发现,
第一题收缩窗口时是<strong>满足条件时</strong>收缩窗口,
第二题则是<strong>不满足条件时</strong>收缩窗口,
这取决于你要统计的<strong>子数组</strong>是“<strong>以 left
开头</strong>”还是“<strong>以 right 结尾</strong>”。</p>
<table>
<colgroup>
<col style="width: 15%">
<col style="width: 40%">
<col style="width: 44%">
</colgroup>
<thead>
<tr>
<th>策略</th>
<th>策略一：满足时收缩</th>
<th>策略二：不满足时收缩</th>
</tr>
</thead>
<tbody>
<tr>
<td>条件类型</td>
<td>“至少”型 (如 sum ≥ k)</td>
<td>“至多”型 (如 sum &lt;= k)</td>
</tr>
<tr>
<td>统计对象</td>
<td>所有以 left 为起点的达标数组</td>
<td>所有以 right 为终点的达标数组</td>
</tr>
<tr>
<td>while 循环条件</td>
<td>while (条件满足)</td>
<td>while (条件不满足)</td>
</tr>
<tr>
<td>收缩 left 的目的</td>
<td>统计完 left 后，移动到下一个起点</td>
<td>修复窗口，使其重新满足条件</td>
</tr>
<tr>
<td>计数公式</td>
<td><code>total += n - right;</code> (在 while 内部)</td>
<td><code>total += right - left + 1;</code> (在 for 循环内, while
外部)</td>
</tr>
</tbody>
</table>
<p>除此之外, 还有一种是”恰好”型的问题, 例如求恰好包含 k
个不同字符的最长子字符串,
这种问题可以<strong>转化</strong>为”至多”型问题来解决, 即: 恰好包含 k
个不同字符的最长子字符串 = 包含 至多 k 个不同字符的最长子字符串 - 包含
至多 (k-1) 个不同字符的最长子字符串.</p>
<p>或者也可以转换w为”至少”型问题来解决, 即: 恰好包含 k
个不同字符的最长子字符串 = 包含 至少 k 个不同字符的最长子字符串 - 包含
至少 (k+1) 个不同字符的最长子字符串.</p>
<p>例如给你一个二元数组 nums ，和一个整数 goal
，请你统计并返回有多少个和为 goal 的 非空 子数组。 <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">mostk</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> goal)</span></span>{</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> left=<span class="number">0</span>, right=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> level=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(right=<span class="number">0</span>;right&lt;n;right++){</span><br><span class="line">            level+=nums[right];</span><br><span class="line">            <span class="keyword">while</span>(level&gt;=goal&amp;&amp;left&lt;=right){  <span class="comment">// 符合条件时收缩</span></span><br><span class="line">                sum+=n-right;</span><br><span class="line">                level-=nums[left];</span><br><span class="line">                left++;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numSubarraysWithSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> goal)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">mostk</span>(nums, goal)-<span class="built_in">mostk</span>(nums, goal<span class="number">+1</span>);  <span class="comment">// 转换为"至少"型问题, 包含 至少 k 个不同字符的最长子字符串 - 包含 至少 (k+1) 个不同字符的最长子字符串</span></span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></table></figure></div></p>
<h2 id="枚举技巧">枚举技巧</h2>
<p>侧重于解决问题的通用思维方式，特别是如何<strong>优化循环和遍历</strong>。</p>
<ul>
<li>枚举右，维护左：一种将 <span class="math inline"><em>O</em>(<em>n</em><sup>2</sup>)</span>
复杂度（双变量）问题优化到 <span class="math inline"><em>O</em>(<em>n</em>)</span>（单变量）的常用技巧，通常与哈希表结合使用。-
枚举中间：处理三元组或四元组问题（如 <span class="math inline"><em>i</em> &lt; <em>j</em> &lt; <em>k</em></span>）的有效策略，通过固定中间变量
<span class="math inline"><em>j</em></span>，将问题分解为两个独立的子问题（处理
<span class="math inline"><em>i</em></span> 和 <span class="math inline"><em>k</em></span>）。</li>
<li>遍历对角线：针对矩阵问题的特定遍历方式。</li>
</ul>
<h2 id="序列与区间处理-sequence-range-processing">序列与区间处理
(Sequence &amp; Range Processing)</h2>
<p>这种方法用于将一个“朴素”的 <span class="math inline"><em>O</em>(<em>n</em><sup>2</sup>)</span> 解法优化到
<span class="math inline"><em>O</em>(<em>n</em>)</span>。</p>
<p>在我们的算法题中, 可能会遇到两类问题： - <strong>区间查询</strong>
(Range Query)：频繁地询问“数组 <span class="math inline"><em>i</em></span> 到 <span class="math inline"><em>j</em></span>
之间的<strong>和/积/异或值是多少</strong>？” - <strong>区间更新</strong>
(Range Update)：频繁地操作“把数组 <span class="math inline"><em>i</em></span> 到 <span class="math inline"><em>j</em></span> 之间的<strong>所有数都加上 <span class="math inline"><em>k</em></span></strong>。”</p>
<p>如果你对每一次“查询”或“更新”都老老实实地跑一个 for
循环，那么每次操作都是 <span class="math inline"><em>O</em>(<em>n</em>)</span>， <span class="math inline"><em>q</em></span> 次操作就是 <span class="math inline"><em>O</em>(<em>n</em><em>q</em>)</span>，这通常会超时。</p>
<p>下面是两种常见且互逆的优化技巧：</p>
<h3 id="前缀和">前缀和</h3>
<p>前缀和 (Prefix Sum)一般用于快速<strong>区间查询</strong>。 -
原理：花费 <span class="math inline"><em>O</em>(<em>n</em>)</span>
时间预处理一个<strong>prefixSum数组</strong>。 -
效果：之后每一次<strong>区间查询</strong>都降为 <strong><span class="math inline"><em>O</em>(1)</span></strong> 时间。</p>
<p>例如, 给定一个数组 nums，假如题目要求你频繁地计算子数组
nums[i…j]（闭区间）的和或者相关信息, 此时不急着直接入手,
我们可以构建一个<strong>前缀和数组 prefixSum 来预处理</strong>，其中
prefixSum[i] 存储 nums[0…i-1]（从第0个到第 <span class="math inline"><em>i</em> − 1</span> 个元素）的总和。</p>
<p>那么，nums[i…j]（闭区间）的和 <span class="math inline"><em>s</em><em>u</em><em>m</em>(<em>i</em>, <em>j</em>)</span>
是多少？ - <span class="math inline"><em>s</em><em>u</em><em>m</em>(<em>i</em>, <em>j</em>) = (前
<em>j</em> 个元素的和) − (前 <em>i</em> − 1 个元素的和)</span> - <span class="math inline"><em>s</em><em>u</em><em>m</em>(<em>i</em>, <em>j</em>) = <em>p</em><em>r</em><em>e</em><em>f</em><em>i</em><em>x</em><em>S</em><em>u</em><em>m</em>[<em>j</em> + 1] − <em>p</em><em>r</em><em>e</em><em>f</em><em>i</em><em>x</em><em>S</em><em>u</em><em>m</em>[<em>i</em>]</span></p>
<p>这样，我们用 <span class="math inline"><em>O</em>(<em>n</em>)</span>
预处理，换来了 <span class="math inline"><em>O</em>(1)</span>
的查询。</p>
<p>再比如, 问题变为“和为 <span class="math inline"><em>K</em></span>
的子数组有多少个？” 这个问题等价于：找到多少对 <span class="math inline">(<em>i</em>, <em>j</em>)</span> 使得 <span class="math inline"><em>s</em><em>u</em><em>m</em>(<em>i</em>, <em>j</em>) = <em>K</em></span>。</p>
<p>用前缀和公式代入：<span class="math inline"><em>p</em><em>r</em><em>e</em><em>f</em><em>i</em><em>x</em><em>S</em><em>u</em><em>m</em>[<em>j</em> + 1] − <em>p</em><em>r</em><em>e</em><em>f</em><em>i</em><em>x</em><em>S</em><em>u</em><em>m</em>[<em>i</em>] = <em>K</em></span>。
变换一下：<span class="math inline"><em>p</em><em>r</em><em>e</em><em>f</em><em>i</em><em>x</em><em>S</em><em>u</em><em>m</em>[<em>i</em>] = <em>p</em><em>r</em><em>e</em><em>f</em><em>i</em><em>x</em><em>S</em><em>u</em><em>m</em>[<em>j</em> + 1] − <em>K</em></span>。</p>
<p>这成为了一个“两数之和”问题！这就是“枚举右，维护左”的完美应用： -
枚举右 (j)：我们遍历数组，计算出当前的 prefixSum[j+1]（记为
current_sum）。 - 提问：我们需要在 <span class="math inline"><em>j</em></span> 的左边找到一个 <span class="math inline"><em>i</em></span>，使得 prefixSum[i] = current_sum -
K。 - 维护左：我们使用一个哈希表 memo 来存储所有历史上的 prefixSum
值及其出现的次数。</p>
<p>例题: 给定一个整数数组 nums 和一个整数 <span class="math inline"><em>K</em></span>，请你统计并返回该数组中和为 <span class="math inline"><em>K</em></span> 的子数组的个数。(LC 560 和为 K
的子数组个数)</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">subarraySum</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>{</span><br><span class="line">    <span class="comment">// 步骤 1: 初始化哈希表</span></span><br><span class="line">    <span class="comment">// 键(Key): 某个前缀和</span></span><br><span class="line">    <span class="comment">// 值(Value): 该前缀和出现的次数</span></span><br><span class="line">    std::unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; memo;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 步骤 2: 关键初始化</span></span><br><span class="line">    <span class="comment">// 放入 (0, 1) 来处理从索引 0 开始的子数组</span></span><br><span class="line">    <span class="comment">// 解释: 如果 nums[0...j] 的和恰好为 k,</span></span><br><span class="line">    <span class="comment">// 那么 current_sum = k, needed = k - k = 0。</span></span><br><span class="line">    <span class="comment">// 我们需要 memo.count(0) 为 true。</span></span><br><span class="line">    memo[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> current_sum = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> total_count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 步骤 3 &amp; 4: 一次循环 - 提问、查找、维护</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : nums) {</span><br><span class="line">        <span class="comment">// a. 更新状态: (枚举右)</span></span><br><span class="line">        current_sum += num;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// b. 提问: 我们需要找的左侧前缀和是什么？</span></span><br><span class="line">        <span class="type">int</span> needed = current_sum - k;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// c. 查找: 左侧存在吗？</span></span><br><span class="line">        <span class="comment">// 我们在 map 中查找是否存在键(key)为 needed</span></span><br><span class="line">        <span class="keyword">if</span> (memo.<span class="built_in">count</span>(needed)) {</span><br><span class="line">            <span class="comment">// 如果存在，说明找到了一个或多个以 num 结尾的</span></span><br><span class="line">            <span class="comment">// 且和为 k 的子数组。</span></span><br><span class="line">            total_count += memo[needed];</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// d. 维护: (维护左)</span></span><br><span class="line">        <span class="comment">// 把当前的前缀和存入 map，供后续的元素查找</span></span><br><span class="line">        memo[current_sum]++;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> total_count;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>
<p>如果更一般的, 我们会两次遍历 (Two-pass)，提前预处理 - 第一次遍历
(预处理)：创建一个 std::vector<int> prefixSum，prefixSum[i] 存储
nums[0…i-1] 的和。 - 第二次遍历 (求解)： - 创建一个
<code>std::unordered_map&lt;int, int&gt; memo</code>。 - 遍历这个
prefixSum 数组（从 prefixSum[0] 到 prefixSum[n]）。 - 在 memo 中查找
prefixSum[j] - k，累加答案。 - 将 prefixSum[j] 存入 memo。 例如:
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">subarraySum</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>{</span><br><span class="line">    <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="comment">// 步骤 1: 预处理前缀和数组</span></span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">prefixSum</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) {</span><br><span class="line">        prefixSum[i] = prefixSum[i - <span class="number">1</span>] + nums[i - <span class="number">1</span>];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 步骤 2: 初始化哈希表</span></span><br><span class="line">    std::unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; memo;</span><br><span class="line">    memo[<span class="number">0</span>] = <span class="number">1</span>;  <span class="comment">// 处理从索引 0 开始的子数组</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> total_count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 步骤 3: 遍历前缀和数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) {</span><br><span class="line">        <span class="type">int</span> needed = prefixSum[j] - k;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 查找左侧存在吗？</span></span><br><span class="line">        <span class="keyword">if</span> (memo.<span class="built_in">count</span>(needed)) {</span><br><span class="line">            total_count += memo[needed];</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 维护哈希表</span></span><br><span class="line">        memo[prefixSum[j]]++;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> total_count;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div></int></p>
<p>常见题型包括: - 基础（一维）与二维前缀和 - 前缀和 +
哈希表：解决特定和（如和为 <span class="math inline"><em>k</em></span>）的子数组问题的经典组合。 -
距离和（绝对值问题） - 状态压缩前缀和（处理位运算或小状态集）</p>
<h3 id="差分数组">差分数组</h3>
<p>差分数组 (Difference Array) 一般用于高效<strong>区间更新</strong>。 -
原理：通过维护一个<strong>差分数组
diff</strong>，使得每次<strong>区间更新</strong>操作都降为 <strong><span class="math inline"><em>O</em>(1)</span></strong> 时间。 -
效果：之后可以通过<strong>一次前缀和计算</strong>，得到<strong>最终的数组状态</strong>。</p>
<p>给你一个数组 nums，我们定义它的差分数组 diff 如下： - diff[0] =
nums[0] - diff[i] = nums[i] - nums[i-1] (对于 <span class="math inline"><em>i</em> &gt; 0</span>) - 惊人的特性：从 diff
数组还原 nums 数组，只需要对 diff 求前缀和即可。 - <span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.777ex;" xmlns="http://www.w3.org/2000/svg" width="23.469ex" height="2.914ex" role="img" focusable="false" viewbox="0 -944.5 10373.3 1287.8"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mi" transform="translate(600,0)"><path data-c="1D462" d="M21 287Q21 295 30 318T55 370T99 420T158 442Q204 442 227 417T250 358Q250 340 216 246T182 105Q182 62 196 45T238 27T291 44T328 78L339 95Q341 99 377 247Q407 367 413 387T427 416Q444 431 463 431Q480 431 488 421T496 402L420 84Q419 79 419 68Q419 43 426 35T447 26Q469 29 482 57T512 145Q514 153 532 153Q551 153 551 144Q550 139 549 130T540 98T523 55T498 17T462 -8Q454 -10 438 -10Q372 -10 347 46Q345 45 336 36T318 21T296 6T267 -6T233 -11Q189 -11 155 7Q103 38 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mi" transform="translate(1172,0)"><path data-c="1D45A" d="M21 287Q22 293 24 303T36 341T56 388T88 425T132 442T175 435T205 417T221 395T229 376L231 369Q231 367 232 367L243 378Q303 442 384 442Q401 442 415 440T441 433T460 423T475 411T485 398T493 385T497 373T500 364T502 357L510 367Q573 442 659 442Q713 442 746 415T780 336Q780 285 742 178T704 50Q705 36 709 31T724 26Q752 26 776 56T815 138Q818 149 821 151T837 153Q857 153 857 145Q857 144 853 130Q845 101 831 73T785 17T716 -10Q669 -10 648 17T627 73Q627 92 663 193T700 345Q700 404 656 404H651Q565 404 506 303L499 291L466 157Q433 26 428 16Q415 -11 385 -11Q372 -11 364 -4T353 8T350 18Q350 29 384 161L420 307Q423 322 423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 181Q151 335 151 342Q154 357 154 369Q154 405 129 405Q107 405 92 377T69 316T57 280Q55 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mi" transform="translate(2050,0)"><path data-c="1D460" d="M131 289Q131 321 147 354T203 415T300 442Q362 442 390 415T419 355Q419 323 402 308T364 292Q351 292 340 300T328 326Q328 342 337 354T354 372T367 378Q368 378 368 379Q368 382 361 388T336 399T297 405Q249 405 227 379T204 326Q204 301 223 291T278 274T330 259Q396 230 396 163Q396 135 385 107T352 51T289 7T195 -10Q118 -10 86 19T53 87Q53 126 74 143T118 160Q133 160 146 151T160 120Q160 94 142 76T111 58Q109 57 108 57T107 55Q108 52 115 47T146 34T201 27Q237 27 263 38T301 66T318 97T323 122Q323 150 302 164T254 181T195 196T148 231Q131 256 131 289Z"/></g><g data-mml-node="mo" transform="translate(2519,0)"><path data-c="5B" d="M118 -250V750H255V710H158V-210H255V-250H118Z"/></g><g data-mml-node="mi" transform="translate(2797,0)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(3142,0)"><path data-c="5D" d="M22 710V750H159V-250H22V-210H119V710H22Z"/></g><g data-mml-node="mo" transform="translate(3697.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/></g><g data-mml-node="munderover" transform="translate(4753.6,0)"><g data-mml-node="mo"><path data-c="2211" d="M61 748Q64 750 489 750H913L954 640Q965 609 976 579T993 533T999 516H979L959 517Q936 579 886 621T777 682Q724 700 655 705T436 710H319Q183 710 183 709Q186 706 348 484T511 259Q517 250 513 244L490 216Q466 188 420 134T330 27L149 -187Q149 -188 362 -188Q388 -188 436 -188T506 -189Q679 -189 778 -162T936 -43Q946 -27 959 6H999L913 -249L489 -250Q65 -250 62 -248Q56 -246 56 -239Q56 -234 118 -161Q186 -81 245 -11L428 206Q428 207 242 462L57 717L56 728Q56 744 61 748Z"/></g><g data-mml-node="TeXAtom" transform="translate(1089,477.1) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mi"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"/></g></g><g data-mml-node="TeXAtom" transform="translate(1089,-285.4) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mi"><path data-c="1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"/></g><g data-mml-node="mo" transform="translate(521,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/></g><g data-mml-node="mn" transform="translate(1299,0)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g></g><g data-mml-node="mi" transform="translate(7331.3,0)"><path data-c="1D451" d="M366 683Q367 683 438 688T511 694Q523 694 523 686Q523 679 450 384T375 83T374 68Q374 26 402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487H491Q506 153 506 145Q506 140 503 129Q490 79 473 48T445 8T417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157Q33 205 53 255T101 341Q148 398 195 420T280 442Q336 442 364 400Q369 394 369 396Q370 400 396 505T424 616Q424 629 417 632T378 637H357Q351 643 351 645T353 664Q358 683 366 683ZM352 326Q329 405 277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q233 26 290 98L298 109L352 326Z"/></g><g data-mml-node="mi" transform="translate(7851.3,0)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mi" transform="translate(8196.3,0)"><path data-c="1D453" d="M118 -162Q120 -162 124 -164T135 -167T147 -168Q160 -168 171 -155T187 -126Q197 -99 221 27T267 267T289 382V385H242Q195 385 192 387Q188 390 188 397L195 425Q197 430 203 430T250 431Q298 431 298 432Q298 434 307 482T319 540Q356 705 465 705Q502 703 526 683T550 630Q550 594 529 578T487 561Q443 561 443 603Q443 622 454 636T478 657L487 662Q471 668 457 668Q445 668 434 658T419 630Q412 601 403 552T387 469T380 433Q380 431 435 431Q480 431 487 430T498 424Q499 420 496 407T491 391Q489 386 482 386T428 385H372L349 263Q301 15 282 -47Q255 -132 212 -173Q175 -205 139 -205Q107 -205 81 -186T55 -132Q55 -95 76 -78T118 -61Q162 -61 162 -103Q162 -122 151 -136T127 -157L118 -162Z"/></g><g data-mml-node="mi" transform="translate(8746.3,0)"><path data-c="1D453" d="M118 -162Q120 -162 124 -164T135 -167T147 -168Q160 -168 171 -155T187 -126Q197 -99 221 27T267 267T289 382V385H242Q195 385 192 387Q188 390 188 397L195 425Q197 430 203 430T250 431Q298 431 298 432Q298 434 307 482T319 540Q356 705 465 705Q502 703 526 683T550 630Q550 594 529 578T487 561Q443 561 443 603Q443 622 454 636T478 657L487 662Q471 668 457 668Q445 668 434 658T419 630Q412 601 403 552T387 469T380 433Q380 431 435 431Q480 431 487 430T498 424Q499 420 496 407T491 391Q489 386 482 386T428 385H372L349 263Q301 15 282 -47Q255 -132 212 -173Q175 -205 139 -205Q107 -205 81 -186T55 -132Q55 -95 76 -78T118 -61Q162 -61 162 -103Q162 -122 151 -136T127 -157L118 -162Z"/></g><g data-mml-node="mo" transform="translate(9296.3,0)"><path data-c="5B" d="M118 -250V750H255V710H158V-210H255V-250H118Z"/></g><g data-mml-node="mi" transform="translate(9574.3,0)"><path data-c="1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"/></g><g data-mml-node="mo" transform="translate(10095.3,0)"><path data-c="5D" d="M22 710V750H159V-250H22V-210H119V710H22Z"/></g></g></g></svg></mjx-container></span></p>
<p>关键操作：如果我们要对 nums 的区间 [i,
j]（闭区间）上的<strong>所有元素都加上 val</strong>： - nums[i] 增加了
val，而 nums[i-1] 不变，所以 diff[i]（即 nums[i] - nums[i-1]）增加了
val。 - nums[i+1] 到 nums[j] 这一段，由于 nums[k] 和 nums[k-1] 都增加了
val，它们的差 diff[k] 不变 - nums[j] 增加了 val，而 nums[j+1] 不变，所以
diff[j+1]（即 nums[j+1] - nums[j]）减少了 val。</p>
<p>结论：一次 <span class="math inline"><em>O</em>(<em>n</em>)</span>
的<strong>区间更新</strong> [i, j] 被转化为了<strong>两次 <span class="math inline"><em>O</em>(1)</span> 的单点更新</strong>！ -
<code>diff[i] += val; if (j + 1 &lt; n) { diff[j + 1] -= val; }</code></p>
<p>例题: LC 1109. 航班预订统计. 有 n 个航班，编号从 1 到 n。有一个预订表
bookings，其中 bookings[i] = [first, last, seats] 表示从 first 到 last
的航班都预订了 seats 个座位。请返回一个长度为 n 的数组 answer，其中
answer[i] 是第 i 个航班的总预订座位数。</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">corpFlightBookings</span><span class="params">(std::vector&lt;std::vector&lt;<span class="type">int</span>&gt;&gt;&amp; bookings, <span class="type">int</span> n)</span> </span>{</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 步骤 1: 初始化差分数组</span></span><br><span class="line">    <span class="comment">// 我们使用 n 个元素，对应 0 到 n-1 下标</span></span><br><span class="line">    <span class="comment">// diff[i] 对应第 i+1 号航班</span></span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">diff</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 步骤 2: 处理所有更新 (O(1) / query)</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; booking : bookings) {</span><br><span class="line">        <span class="comment">// 题目编号从 1 开始，数组下标从 0 开始</span></span><br><span class="line">        <span class="type">int</span> first = booking[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> last = booking[<span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> seats = booking[<span class="number">2</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 转换为 0-based 下标</span></span><br><span class="line">        <span class="type">int</span> i = first - <span class="number">1</span>; </span><br><span class="line">        <span class="type">int</span> j = last - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 应用差分</span></span><br><span class="line">        <span class="comment">// 1. 在区间的起始点 i 加上 val</span></span><br><span class="line">        diff[i] += seats;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 在区间的结束点 j 的下一个位置 j+1 减去 val</span></span><br><span class="line">        <span class="comment">// 注意检查边界</span></span><br><span class="line">        <span class="keyword">if</span> (j + <span class="number">1</span> &lt; n) {</span><br><span class="line">            diff[j + <span class="number">1</span>] -= seats;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 步骤 3: 还原结果 (O(n))</span></span><br><span class="line">    <span class="comment">// 通过对差分数组求前缀和，来还原出最终的航班座位数</span></span><br><span class="line">    <span class="comment">// 还原后的数组可以直接用 diff 自身来存储</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i) {</span><br><span class="line">        <span class="comment">// 第 i 个航班的座位 = 第 i-1 个航班的座位 + 第 i 个航班的“变化量”</span></span><br><span class="line">        diff[i] += diff[i - <span class="number">1</span>];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 步骤 4: 返回</span></span><br><span class="line">    <span class="comment">// 此时 diff 数组已经变成了我们想要的 answer 数组</span></span><br><span class="line">    <span class="keyword">return</span> diff;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>
<p>常见题型包括: -
一维差分：用于高效处理区间更新、单点查询的问题，常与扫描线思想结合。 -
二维差分：用于处理子矩阵的批量更新。</p>
<h2 id="栈">栈</h2>
<p>栈是一种后进先出（LIFO）的数据结构，支持基本操作：入栈（<strong>push</strong>）、出栈（<strong>pop</strong>）和查看栈顶元素（<strong>top</strong>）。栈的应用场景包括表达式求值、括号匹配、深度优先搜索等。</p>
<h3 id="邻项消除-合法括号字符串">邻项消除 &amp; 合法括号字符串</h3>
<p>这两个是栈的最经典应用，因为它们的思想完全一致。</p>
<p>核心思想：</p>
<ul>
<li><strong>遍历</strong>你的输入（如一个字符串）。</li>
<li>使用一个<strong>栈</strong>来维护一个“<strong>尚未被消除/匹配</strong>”的元素序列。</li>
<li>当你遇到一个新元素 current 时，你去看它和“栈顶”元素
stack.top()（即最近一个尚未被消除的元素）是否能“配对”。
<ul>
<li>如果能配对：说明 current 和 stack.top() 互相消除了。你执行
stack.pop()，并且不将 current 入栈。</li>
<li>如果不能配对：说明 current 暂时无法被消除，你将它
stack.push()，等待它未来的“配对者”出现</li>
</ul></li>
<li>遍历结束后，栈内剩下的元素就是“无法被消除/匹配”的元素。
<ul>
<li>对于邻项消除问题，栈内剩下的元素就是最终结果。</li>
<li>对于括号匹配问题，栈内剩下的元素数量就是无法被匹配的括号数量。</li>
</ul></li>
</ul>
<h3 id="单调栈">单调栈</h3>
<p>单调栈是一种特殊的栈数据结构，它在入栈和出栈操作时保持栈内元素的<strong>单调性</strong>（从栈底到栈顶递增或递减）。其核心思想，是在
<strong><span class="math inline"><em>O</em>(<em>n</em>)</span>
的一次遍历中</strong>，为数组中的<strong>每一个元素</strong>，快速找到它<strong>左侧或右侧</strong>(取决于遍历方向)的<strong>第一个比它“大”（或“小”）的元素</strong>。</p>
<p>它是如何工作的？ 以“单调递增栈”（栈底到栈顶）为例，当一个新元素 x
准备入栈时：</p>
<ol type="1">
<li>比较：x 会和栈顶 st.top() 比较。</li>
<li>“清洗”：
<ul>
<li>如果 x &lt; st.top()，说明栈顶元素 st.top()
“没用了”。为什么？因为它比 x 大，而且比 x 旧（在 x
左侧）。如果将来有一个元素 y（在 x
右侧）在寻找它“左侧第一个更小的元素”，y 会先看到 x，而永远不会看到
st.top()。</li>
<li>因此，我们弹出 (pop) st.top()，然后 x 继续和新的栈顶比较。</li>
<li>这个过程会一直持续，直到 st.top() &lt;= x。</li>
</ul></li>
<li>入栈：x 入栈。</li>
</ol>
<p>通过这个“清洗”过程，栈内始终维护了一个单调递增的序列，这个序列里的元素都是“有潜力”的（它们都还在等待右侧第一个比自己小的元素）。</p>
<p>单调栈目前主要有四大应用场景:</p>
<h4 id="基础寻找下一个更大更小元素-ngense">1.
基础：寻找下一个更大/更小元素 (NGE/NSE)</h4>
<p>问题：为数组中每个 nums[i]，找到它右侧第一个比它大的元素
nums[j]（<span class="math inline"><em>j</em> &gt; <em>i</em>, <em>n</em><em>u</em><em>m</em><em>s</em>[<em>j</em>] &gt; <em>n</em><em>u</em><em>m</em><em>s</em>[<em>i</em>]</span>）。
解法：使用一个单调递减的栈（栈内存放下标）。 - 遍历数组 i 从左到右。 -
while (!st.empty() &amp;&amp; nums[i] &gt; nums[st.top()])： -
这说明，nums[i] 是 st.top()
所代表的那个元素的<strong>“右侧第一个更大元素”</strong>。 -
找到了！ans[st.top()] = nums[i] (或 j - i，根据题目要求)。 - st.pop()。
- st.push(i)：nums[i] 入栈，等待它“右侧第一个更大元素”的出现。</p>
<p>例如每日温度: 给定一个整数数组 temperatures
，表示每天的温度，返回一个数组 answer ，其中 answer[i] 是指对于第 i
天，下一个更高温度出现在几天后。如果不存在更高温度，答案为 0 。(LC
739)</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dailyTemperatures</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; temperatures)</span> </span>{</span><br><span class="line">        <span class="type">int</span> n = temperatures.<span class="built_in">size</span>();</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; indexes;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ans</span><span class="params">(n,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">            <span class="type">int</span> cur = temperatures[i];</span><br><span class="line">            <span class="keyword">while</span>(!indexes.<span class="built_in">empty</span>()&amp;&amp; temperatures[indexes.<span class="built_in">top</span>()]&lt;cur){</span><br><span class="line">                <span class="type">int</span> index = indexes.<span class="built_in">top</span>();</span><br><span class="line">                ans[index] = i-index;</span><br><span class="line">                indexes.<span class="built_in">pop</span>();</span><br><span class="line">            }</span><br><span class="line">            indexes.<span class="built_in">push</span>(i);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></table></figure></div>
<h4 id="进阶柱状图中的最大矩形面积">2. 进阶：柱状图中的最大矩形面积</h4>
<p>这是单调栈最经典的应用。问题描述: 给定 n
个非负整数表示每个柱子的高度图，宽度均为
1，计算在该柱状图中，能够勾勒出来的矩形的最大面积(LC 84)。</p>
<p>解法：</p>
<ul>
<li>遍历每一个柱子 h[i]，并假设它就是矩形的最终高度。</li>
<li>我们需要找到这个矩形能向左和向右延伸的最大宽度。</li>
<li>向左：找到 h[i] <strong>左侧第一个小于</strong> h[i] 的柱子
h[l]。</li>
<li>向右：找到 h[i] <strong>右侧第一个小于</strong> h[i] 的柱子
h[r]。</li>
<li>这个 h[i] 的矩形面积就是 h[i] * (r - l - 1)。</li>
</ul>
<p>这就是“寻找下一个更小元素”(NSE)
问题。你可以通过两次遍历（一次找左侧，一次找右侧）来解决。
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">largestRectangleArea</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; heights)</span> </span>{</span><br><span class="line">        <span class="type">int</span> n = heights.<span class="built_in">size</span>();</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; left_s;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">left_vec</span><span class="params">(n,<span class="number">-1</span>)</span></span>;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; right_s;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">right_vec</span><span class="params">(n,n)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> max_aera = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">            <span class="type">int</span> cur = heights[i];</span><br><span class="line">            <span class="keyword">while</span>(!right_s.<span class="built_in">empty</span>()&amp;&amp; cur&lt;heights[right_s.<span class="built_in">top</span>()]){</span><br><span class="line">                right_vec[right_s.<span class="built_in">top</span>()] = i;</span><br><span class="line">                right_s.<span class="built_in">pop</span>();</span><br><span class="line">            }</span><br><span class="line">            right_s.<span class="built_in">push</span>(i);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--){</span><br><span class="line">            <span class="type">int</span> cur = heights[i];</span><br><span class="line">            <span class="keyword">while</span>(!left_s.<span class="built_in">empty</span>()&amp;&amp; cur&lt;heights[left_s.<span class="built_in">top</span>()]){</span><br><span class="line">                left_vec[left_s.<span class="built_in">top</span>()] = i;</span><br><span class="line">                left_s.<span class="built_in">pop</span>();</span><br><span class="line">            }</span><br><span class="line">            left_s.<span class="built_in">push</span>(i);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">                <span class="type">int</span> cur_aera = heights[i]*(right_vec[i]-left_vec[i]<span class="number">-1</span>);</span><br><span class="line">                max_aera = <span class="built_in">max</span>(max_aera, cur_aera);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> max_aera;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></table></figure></div></p>
<h4 id="贡献法子数组的最小值之和">贡献法：子数组的最小值之和</h4>
<p>这是单调栈最精妙的应用。问题描述: 给定一个整数数组 nums
，返回所有非空子数组的最小值之和。(由于答案可能很大，因此返回答案对 10^9
+ 7 取余后的结果)(LC 907)</p>
<p>核心思想（贡献法）：我们不遍历子数组，我们<strong>遍历每一个元素
nums[i]</strong>。 - 我们问：nums[i]
作为最小值，在多少个子数组中出现过？ - 同样，我们需要找到 nums[i]
的左侧第一个更小元素 (下标 l) 和右侧第一个更小元素 (下标 r)。 - 这说明
nums[i] 是<strong>开区间 (l, r) 内的唯一最小值</strong>。任何一个起点在
<code>(l, i]</code> 之间（共 <strong>i - l</strong> 种选择）且终点在
<code>[i, r)</code> 之间（共 <strong>r - i</strong>
种选择）组成的子数组，其最小值都是 nums[i]。 - nums[i] 的总贡献 =
nums[i] * (i - l) * (r - i)。 - 用单调栈求出所有 l 和 r，然后 <span class="math inline"><em>O</em>(<em>n</em>)</span> 累加总贡献。
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">sumSubarrayMins</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr)</span> </span>{</span><br><span class="line">        <span class="type">int</span> n = arr.<span class="built_in">size</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 1. 计算左边界 left[i]</span></span><br><span class="line">        <span class="comment">// left[i] = l, 其中 l 是 arr[i] 左侧第一个“严格小于” arr[i] 的元素下标</span></span><br><span class="line">        <span class="comment">// 我们使用一个单调递增栈</span></span><br><span class="line">        <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">left</span><span class="params">(n)</span></span>;</span><br><span class="line">        std::stack&lt;<span class="type">int</span>&gt; st_left;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) {</span><br><span class="line">            <span class="comment">// 解释: 栈顶元素如果 &gt;= 当前元素，说明它不是 arr[i] 的左边界</span></span><br><span class="line">            <span class="comment">// (我们在找严格小于的)</span></span><br><span class="line">            <span class="comment">// 并且它也不是它右侧任何元素的左边界了，弹出</span></span><br><span class="line">            <span class="keyword">while</span> (!st_left.<span class="built_in">empty</span>() &amp;&amp; arr[st_left.<span class="built_in">top</span>()] &gt;= arr[i]) {</span><br><span class="line">                st_left.<span class="built_in">pop</span>();</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// 解释: 栈为空，说明左侧没有更小元素；否则，栈顶就是左边界</span></span><br><span class="line">            left[i] = st_left.<span class="built_in">empty</span>() ? <span class="number">-1</span> : st_left.<span class="built_in">top</span>();</span><br><span class="line">            st_left.<span class="built_in">push</span>(i);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 计算右边界 right[i]</span></span><br><span class="line">        <span class="comment">// right[i] = r, 其中 r 是 arr[i] 右侧第一个“小于或等于” arr[i] 的元素下标</span></span><br><span class="line">        <span class="comment">// 我们也使用一个单调递增栈 (但从右往左遍历)</span></span><br><span class="line">        <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">right</span><span class="params">(n)</span></span>;</span><br><span class="line">        std::stack&lt;<span class="type">int</span>&gt; st_right;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) {</span><br><span class="line">            <span class="comment">// 解释: 栈顶元素如果 &gt; 当前元素，说明它不是 arr[i] 的右边界</span></span><br><span class="line">            <span class="comment">// (我们在找小于或等于的)</span></span><br><span class="line">            <span class="keyword">while</span> (!st_right.<span class="built_in">empty</span>() &amp;&amp; arr[st_right.<span class="built_in">top</span>()] &gt; arr[i]) {   <span class="comment">// 注意这里是严格大于, 因为要避免两个栈都是大于等于导致重复计算</span></span><br><span class="line">                st_right.<span class="built_in">pop</span>();</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// 解释: 栈为空，说明右侧没有更小或相等元素；否则，栈顶就是右边界</span></span><br><span class="line">            right[i] = st_right.<span class="built_in">empty</span>() ? n : st_right.<span class="built_in">top</span>();</span><br><span class="line">            st_right.<span class="built_in">push</span>(i);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 累加贡献</span></span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> total_sum = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> MOD = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) {</span><br><span class="line">            <span class="comment">// 解释: l = left[i], r = right[i]</span></span><br><span class="line">            <span class="comment">// 左侧的起点选择数: i - l</span></span><br><span class="line">            <span class="comment">// (j 可以在 (l, i] 范围内, 即 l+1, l+2, ..., i)</span></span><br><span class="line">            <span class="type">long</span> <span class="type">long</span> left_span = i - left[i];</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 解释: 右侧的终点选择数: r - i</span></span><br><span class="line">            <span class="comment">// (k 可以在 [i, r) 范围内, 即 i, i+1, ..., r-1)</span></span><br><span class="line">            <span class="type">long</span> <span class="type">long</span> right_span = right[i] - i;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 贡献 = arr[i] * (左侧选择数) * (右侧选择数)</span></span><br><span class="line">            <span class="type">long</span> <span class="type">long</span> contribution = (arr[i] * left_span * right_span);</span><br><span class="line">            </span><br><span class="line">            total_sum = (total_sum + contribution) % MOD;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (<span class="type">int</span>)total_sum;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></table></figure></div></p>
<h4 id="最小字典序移掉-k-位数字">最小字典序：移掉 K 位数字</h4>
<p>这是单调栈结合贪心思想的应用。问题描述:
给你一个以字符串表示的非负整数 num ，移除这个数中的 k
位数字，使得剩下的数字最小。返回移除 k
位数字后得到的最小整数，以字符串形式表示。(LC 402)</p>
<p>核心思想：</p>
<ul>
<li>为了让数字尽可能小，我们希望高位（左侧）的数字尽可能小。
<ul>
<li>因为高位数字权重更大，假如有两个数字 a 和 b，如果 a &lt; b，那么把 a
放在高位比把 b 放在高位更能减小整体数值。</li>
</ul></li>
<li>我们使用一个单调递增的栈来维护我们“<strong>保留”的数字</strong>。</li>
<li>遍历数字字符串，for (char c : num)：
<ul>
<li>while (!st.empty() &amp;&amp; k &gt; 0 &amp;&amp; c &lt; st.top())：
<ul>
<li>解释：新来的 c
比栈顶元素（已保留的数字）更小，并且我们还有删除的名额 (k &gt; 0)。</li>
<li>贪心：我们应该“扔掉”栈顶那个更大的数字，换成 c。</li>
<li>st.pop(); k–;</li>
</ul></li>
<li>st.push(c);</li>
</ul></li>
<li>最终，栈中就保留了最小的序列。</li>
</ul>
<h2 id="队列">队列</h2>
<p>队列是一种先进先出（FIFO）的数据结构，支持基本操作：入队（<strong>enqueue</strong>）、出队（<strong>dequeue</strong>）和查看队首元素（<strong>front</strong>）。队列的应用场景包括广度优先搜索、任务调度等。</p>
<p>我们可以使用容器适配器 <code>std::queue</code> 来实现队列, 也可以使用
<code>std::deque</code> 来实现双端队列。</p>
<p>对于 <code>queue</code>, 主要用到的接口有: push(), pop(), front(),
back(), empty(), size(). 并且需要注意的是, queue 没有迭代器,
不能使用范围for循环来遍历queue中的元素, 只能通过不断 pop
出队列的方式来访问每个元素.</p>
<p>而对于 <code>deque</code>,
由于它是双端队列，可以分别操作两端，因此在入队和出队时要加以说明,
主要用到的接口有: push_back(), push_front(), pop_back(), pop_front(),
front(), back(), empty(), size().</p>
<h3 id="单调队列">单调队列</h3>
<p>单调队列是一种特殊的队列数据结构，它在入队和出队操作时保持队列内元素的<strong>单调性</strong>（从队头到队尾递增或递减）。其核心思想，是在
<strong><span class="math inline"><em>O</em>(<em>n</em>)</span>
的一次遍历中</strong>，为数组中的<strong>每一个元素</strong>，快速找到它<strong>左侧或右侧</strong>(取决于遍历方向)的<strong>第一个比它“大”（或“小”）的元素</strong>。</p>
<p>单调队列的应用场景包括滑动窗口问题、最大值/最小值查询等。</p>
<h2 id="堆">堆</h2>
<p>当你需要在一个<strong>动态的集合中</strong>（元素不断在增加或减少）快速地查找并（或）移除“<strong>最值</strong>”（最大值或最小值）时，堆就是你的不二之选。</p>
<h3 id="top-k-问题-第-k-小大">Top-K 问题 / 第 K 小/大</h3>
<p>这是堆最基础、最直接的应用。核心思想是：维护一个<strong>大小固定为
K</strong> 的堆。这个堆里存储了你到目前为止见过的 “Top K” 个元素。</p>
<p>问题模型： - 静态数组：在 <span class="math inline"><em>N</em></span>
个元素中找到第 <span class="math inline"><em>K</em></span> 大的元素 (LC
215)。 - 数据流：在不断加入的数据流中，始终保持对第 <span class="math inline"><em>K</em></span> 大元素的快速访问 (LC 703)。</p>
<p>解题思路 (以“<strong>第 K
大</strong>”为例)：你需要一个<strong>最小堆</strong>（Min-Heap）。为什么？
最小堆的堆顶 <code>min_pq.top()</code>
永远是堆中最小的元素。如果我们的堆里有 <span class="math inline"><em>K</em></span> 个元素，那么堆顶就是<strong>这
<span class="math inline"><em>K</em></span> 个元素中的第 <span class="math inline"><em>K</em></span> 大</strong>的那个。 -
初始化：创建一个大小为 <span class="math inline"><em>K</em></span>
的最小堆 min_pq。 - 遍历数据：for (int num : nums) -
入堆：min_pq.push(num); - 维护大小：if (min_pq.size() &gt;
k)：min_pq.pop(); - (将堆中最小的元素——即“第 K+1 大”的元素——扔掉) -
获取答案：当所有数据都处理完毕后，堆中剩下的 <span class="math inline"><em>K</em></span> 个元素就是最大的 <span class="math inline"><em>K</em></span> 个，而 min_pq.top()
就是我们想要的第 K 大元素。</p>
<h3 id="对顶堆动态中位数">对顶堆（动态中位数）</h3>
<p>一个极其精妙的技巧,
使用<strong>两个堆</strong>来将一个<strong>动态数据流</strong>“从<strong>中间劈开</strong>”，从而
<span class="math inline"><em>O</em>(1)</span> 访问中位数。</p>
<p>数据结构配置： - small
(最大堆)：存储数据流中较小的一半元素。small.top() 是“小半”中的最大值。 -
large (最小堆)：存储数据流中较大的一半元素。large.top()
是“大半”中的最小值。</p>
<p>核心规则（不变式）： - small.size() 永远等于
large.size()（当总数为偶） - 或 small.size() 等于 large.size() +
1（当总数为奇）中位数：如果总数为奇，</p>
<p>中位数就是 small.top()。如果总数为偶，中位数就是 (small.top() +
large.top()) / 2。</p>
<h3 id="重排元素贪心">重排元素（贪心）</h3>
<h3 id="反悔堆反悔贪心">反悔堆（反悔贪心）</h3>
<h2 id="二叉树">二叉树</h2>
<p>二叉树是一种非常适合<strong>递归</strong>处理的数据结构,
因为<strong>每个节点</strong>都可以看作是一个<strong>子树的根节点</strong>.
处理二叉树问题时, 通常需要定义一个递归函数, 该函数接受一个节点作为参数,
并返回该节点为根的子树的某种属性(如高度, 节点数, 最大路径和等).
递归函数的终止条件通常是<strong>节点为空</strong>时返回一个默认值(如0或null).
在递归函数中, 需要递归调用左右子节点,
并根据返回值计算当前节点的属性.</p>
<h3 id="二叉树的遍历">二叉树的遍历</h3>
<p>二叉树的遍历主要有三种方式: 前序遍历 (Preorder), 中序遍历 (Inorder),
后序遍历 (Postorder). 这三种遍历方式的区别在于访问节点的顺序不同,
名称反映的是访问根节点的时机</p>
<p>三种遍历都可以使用递归实现, 较为简单 ` 使用迭代实现时,
通常需要借助<strong>栈 (Stack)</strong>
来<strong>手动模拟递归</strong>调用栈的行为.</p>
<p>还有一种遍历是层序遍历 (Level-order), 也称为广度优先遍历 (BFS).
层序遍历通常使用<strong>队列 (Queue)</strong> 来实现,
通过逐层访问节点来实现. 实现代码如下: <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">levelOrder</span>(TreeNode* root) {</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; results;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> results;</span><br><span class="line"></span><br><span class="line">        queue&lt;TreeNode*&gt; que;  <span class="comment">// 使用队列来辅助层序遍历</span></span><br><span class="line">        que.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(!que.<span class="built_in">empty</span>()){  <span class="comment">// 每层循环处理一层节点, 由上一层节点入队列</span></span><br><span class="line">            <span class="type">int</span> size = que.<span class="built_in">size</span>();</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;size;i++){</span><br><span class="line">                TreeNode* node = que.<span class="built_in">front</span>();</span><br><span class="line">                path.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span>(node-&gt;left) que.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(node-&gt;right) que.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">            }</span><br><span class="line">            results.<span class="built_in">push_back</span>(path);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> results;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></table></figure></div></p>
<h2 id="其余">其余</h2>
<h3 id="递归">递归</h3>
<p>这里帮助大家确定下来递归算法的三个要素。每次写递归，都按照这三要素来写，可以保证大家写出正确的递归算法！</p>
<ul>
<li><p>确定递归函数的<strong>参数</strong>和<strong>返回值</strong>：
确定哪些参数是递归的过程中需要处理的，那么就在递归函数里加上这个参数，
并且还要明确每次递归的返回值是什么进而确定递归函数的返回类型。</p></li>
<li><p>确定<strong>终止条件</strong>： 写完了递归算法,
运行的时候，经常会遇到栈溢出的错误，就是没写终止条件或者终止条件写的不对，操作系统也是用一个栈的结构来保存每一层递归的信息，如果递归没有终止，操作系统的内存栈必然就会溢出。</p></li>
<li><p>确定<strong>单层递归的逻辑</strong>：
确定每一层递归需要处理的信息。在这里也就会重复调用自己来实现递归的过程。</p></li>
</ul>
<p>递归的实现就是：每一次递归调用都会把函数的局部变量、参数值和返回地址等压入调用栈中，然后递归返回的时候，从栈顶弹出上一次递归的各项参数，所以这就是递归为什么可以返回上一层位置的原因。</p>
<p>另一种算法, 回溯, 其实是递归的副产品，只要有递归就会有回溯。</p>
<p>递归时如果超时, 可能是递归时<strong>对某些元素重复计算</strong>了,
这时可以考虑用<strong>记忆化搜索</strong>(Memoization)来优化递归算法,
即可以用一个<strong>哈希表</strong>来<strong>缓存已经计算过的结果,</strong>
避免重复计算.</p>
<p>在函数的开始先检查哈希表中是否已经存在该结果,
如果存在则直接返回该结果, 否则继续计算并将结果存入哈希表中.</p>
<p>例如LeetCode 337</p>

		</div>

		

		
		<ul class="post-tags-box text-lg mt-1.5 flex-wrap justify-center flex md:hidden">
			
			<li class="tag-item mx-0.5">
				<a href="/tags/algorithms/">#algorithms</a>&nbsp;
			</li>
			
		</ul>
		

		

		
		<div class="article-nav my-8 flex justify-between items-center px-2 sm:px-6 md:px-8">
			
			<div class="article-prev border-border-color shadow-redefine-flat shadow-shadow-color-2 rounded-medium px-4 py-2 hover:shadow-redefine-flat-hover hover:shadow-shadow-color-2">
				<a class="prev" rel="prev" href="/2025/10/10/system/linux/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/%E9%AB%98%E5%B9%B6%E5%8F%91/Ractor/">
					<span class="left arrow-icon flex justify-center items-center">
						<i class="fa-solid fa-chevron-left"></i>
					</span>
					<span class="title flex justify-center items-center">
						<span class="post-nav-title-item truncate max-w-48">Ractor</span>
						<span class="post-nav-item">Prev posts</span>
					</span>
				</a>
			</div>
			
			
			<div class="article-next border-border-color shadow-redefine-flat shadow-shadow-color-2 rounded-medium px-4 py-2 hover:shadow-redefine-flat-hover hover:shadow-shadow-color-2">
				<a class="next" rel="next" href="/2025/10/08/system/computer-architecture/RISC-V%20%E7%9A%84%E8%B0%83%E7%94%A8%E7%BA%A6%E5%AE%9A/">
					<span class="title flex justify-center items-center">
						<span class="post-nav-title-item truncate max-w-48">RISC-V 的调用约定</span>
						<span class="post-nav-item">Next posts</span>
					</span>
					<span class="right arrow-icon flex justify-center items-center">
						<i class="fa-solid fa-chevron-right"></i>
					</span>
				</a>
			</div>
			
		</div>
		


		
	</div>

	
	<div class="toc-content-container">
		<div class="post-toc-wrap">
	<div class="post-toc">
		<div class="toc-title">On this page</div>
		<div class="page-title">Coding技巧</div>
		<ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE"><span class="nav-text">二分查找</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3"><span class="nav-text">滑动窗口</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%BA%E5%AE%9A%E9%95%BF%E5%BA%A6%E4%B8%8E%E5%8F%AF%E5%8F%98%E9%95%BF%E5%BA%A6%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3"><span class="nav-text">固定长度与可变长度滑动窗口</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9B%BA%E5%AE%9A%E9%95%BF%E5%BA%A6%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3"><span class="nav-text">固定长度滑动窗口</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B"><span class="nav-text">示例</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%AF%E5%8F%98%E9%95%BF%E5%BA%A6%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3"><span class="nav-text">可变长度滑动窗口</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9E%9A%E4%B8%BE%E6%8A%80%E5%B7%A7"><span class="nav-text">枚举技巧</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BA%8F%E5%88%97%E4%B8%8E%E5%8C%BA%E9%97%B4%E5%A4%84%E7%90%86-sequence-range-processing"><span class="nav-text">序列与区间处理
(Sequence &amp; Range Processing)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%89%8D%E7%BC%80%E5%92%8C"><span class="nav-text">前缀和</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B7%AE%E5%88%86%E6%95%B0%E7%BB%84"><span class="nav-text">差分数组</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%88"><span class="nav-text">栈</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%82%BB%E9%A1%B9%E6%B6%88%E9%99%A4-%E5%90%88%E6%B3%95%E6%8B%AC%E5%8F%B7%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-text">邻项消除 &amp; 合法括号字符串</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%95%E8%B0%83%E6%A0%88"><span class="nav-text">单调栈</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9F%BA%E7%A1%80%E5%AF%BB%E6%89%BE%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E6%9B%B4%E5%B0%8F%E5%85%83%E7%B4%A0-ngense"><span class="nav-text">1.
基础：寻找下一个更大&#x2F;更小元素 (NGE&#x2F;NSE)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%9B%E9%98%B6%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E7%9F%A9%E5%BD%A2%E9%9D%A2%E7%A7%AF"><span class="nav-text">2. 进阶：柱状图中的最大矩形面积</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%B4%A1%E7%8C%AE%E6%B3%95%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC%E4%B9%8B%E5%92%8C"><span class="nav-text">贡献法：子数组的最小值之和</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%80%E5%B0%8F%E5%AD%97%E5%85%B8%E5%BA%8F%E7%A7%BB%E6%8E%89-k-%E4%BD%8D%E6%95%B0%E5%AD%97"><span class="nav-text">最小字典序：移掉 K 位数字</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%98%9F%E5%88%97"><span class="nav-text">队列</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97"><span class="nav-text">单调队列</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A0%86"><span class="nav-text">堆</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#top-k-%E9%97%AE%E9%A2%98-%E7%AC%AC-k-%E5%B0%8F%E5%A4%A7"><span class="nav-text">Top-K 问题 &#x2F; 第 K 小&#x2F;大</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%B9%E9%A1%B6%E5%A0%86%E5%8A%A8%E6%80%81%E4%B8%AD%E4%BD%8D%E6%95%B0"><span class="nav-text">对顶堆（动态中位数）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%87%8D%E6%8E%92%E5%85%83%E7%B4%A0%E8%B4%AA%E5%BF%83"><span class="nav-text">重排元素（贪心）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%8D%E6%82%94%E5%A0%86%E5%8F%8D%E6%82%94%E8%B4%AA%E5%BF%83"><span class="nav-text">反悔堆（反悔贪心）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-text">二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86"><span class="nav-text">二叉树的遍历</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B6%E4%BD%99"><span class="nav-text">其余</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%92%E5%BD%92"><span class="nav-text">递归</span></a></li></ol></li></ol>

	</div>
</div>
	</div>
	
</div>
			</div>

			
		</div>

		<div class="main-content-footer">
			<footer class="footer mt-5 py-5 h-auto text-base text-third-text-color relative border-t-2 border-t-border-color">
    <div class="info-container py-3 text-center">
        
            <div class="customize-info my-1">AI是新时代的灯塔</div>
        
        <div class="text-center">
            &copy;
            
              <span>2025</span>
              -
            
            2025&nbsp;&nbsp;<i class="fa-solid fa-heart fa-beat" style="--fa-animation-duration: 0.5s; color: #f54545"></i>&nbsp;&nbsp;<a href="/">ZaynPei</a>
            
                
                <p class="post-count space-x-0.5">
                    <span>
                        186 posts in total
                    </span>
                    
                        <span>
                            578.6k words in total
                        </span>
                    
                </p>
            
        </div>
        
        <div class="relative text-center lg:absolute lg:left-[20px] lg:top-1/2 lg:-translate-y-1/2 lg:text-left">
            <span class="lg:block text-sm">POWERED BY <?xml version="1.0" encoding="utf-8"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg class="relative top-[2px] inline-block align-baseline" version="1.1" id="圖層_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="1rem" height="1rem" viewBox="0 0 512 512" enable-background="new 0 0 512 512" xml:space="preserve"><path fill="#0E83CD" d="M256.4,25.8l-200,115.5L56,371.5l199.6,114.7l200-115.5l0.4-230.2L256.4,25.8z M349,354.6l-18.4,10.7l-18.6-11V275H200v79.6l-18.4,10.7l-18.6-11v-197l18.5-10.6l18.5,10.8V237h112v-79.6l18.5-10.6l18.5,10.8V354.6z"/></svg><a target="_blank" class="text-base" href="https://hexo.io">Hexo</a></span>
            <span class="text-sm lg:block">THEME&nbsp;<a class="text-base" target="_blank" href="https://github.com/EvanNotFound/hexo-theme-redefine">Redefine v2.8.5</a></span>
        </div>
        
        
            <div>
                Blog up for <span class="odometer" id="runtime_days" ></span> days <span class="odometer" id="runtime_hours"></span> hrs <span class="odometer" id="runtime_minutes"></span> Min <span class="odometer" id="runtime_seconds"></span> Sec
            </div>
        
        
            <script data-swup-reload-script>
                try {
                    function odometer_init() {
                    const elements = document.querySelectorAll('.odometer');
                    elements.forEach(el => {
                        new Odometer({
                            el,
                            format: '( ddd).dd',
                            duration: 200
                        });
                    });
                    }
                    odometer_init();
                } catch (error) {}
            </script>
        
        
            
                
        
                
        
        
    </div>  
</footer>
		</div>
	</div>

	
	<div class="post-tools">
		<div class="post-tools-container">
	<ul class="article-tools-list">
		<!-- TOC aside toggle -->
		
		<li class="right-bottom-tools page-aside-toggle">
			<i class="fa-regular fa-outdent"></i>
		</li>
		

		<!-- go comment -->
		
	</ul>
</div>
	</div>
	

	<div class="right-side-tools-container">
		<div class="side-tools-container">
	<ul class="hidden-tools-list">
		<li class="right-bottom-tools tool-font-adjust-plus flex justify-center items-center">
			<i class="fa-regular fa-magnifying-glass-plus"></i>
		</li>

		<li class="right-bottom-tools tool-font-adjust-minus flex justify-center items-center">
			<i class="fa-regular fa-magnifying-glass-minus"></i>
		</li>

		<li class="right-bottom-tools tool-dark-light-toggle flex justify-center items-center">
			<i class="fa-regular fa-moon"></i>
		</li>

		<!-- rss -->
		

		

		<li class="right-bottom-tools tool-scroll-to-bottom flex justify-center items-center">
			<i class="fa-regular fa-arrow-down"></i>
		</li>
	</ul>

	<ul class="visible-tools-list">
		<li class="right-bottom-tools toggle-tools-list flex justify-center items-center">
			<i class="fa-regular fa-cog fa-spin"></i>
		</li>
		
		<li class="right-bottom-tools tool-scroll-to-top flex justify-center items-center">
			<i class="arrow-up fas fa-arrow-up"></i>
			<span class="percent"></span>
		</li>
		
		
	</ul>
</div>
	</div>

	<div class="image-viewer-container">
	<img src="">
</div>

	
	<div class="search-pop-overlay">
	<div class="popup search-popup">
		<div class="search-header">
			<span class="search-input-field-pre">
				<i class="fa-solid fa-keyboard"></i>
			</span>
			<div class="search-input-container">
				<input autocomplete="off" autocorrect="off" autocapitalize="off" placeholder="Search..." spellcheck="false" type="search" class="search-input">
			</div>
			<span class="popup-btn-close">
				<i class="fa-solid fa-times"></i>
			</span>
		</div>
		<div id="search-result">
			<div id="no-result">
				<i class="fa-solid fa-spinner fa-spin-pulse fa-5x fa-fw"></i>
			</div>
		</div>
	</div>
</div>
	

</main>



<script src="/js/build/libs/Swup.min.js"></script>

<script src="/js/build/libs/SwupSlideTheme.min.js"></script>

<script src="/js/build/libs/SwupScriptsPlugin.min.js"></script>

<script src="/js/build/libs/SwupProgressPlugin.min.js"></script>

<script src="/js/build/libs/SwupScrollPlugin.min.js"></script>

<script src="/js/build/libs/SwupPreloadPlugin.min.js"></script>

<script>
    const swup = new Swup({
        plugins: [
            new SwupScriptsPlugin({
                optin: true,
            }),
            new SwupProgressPlugin(),
            new SwupScrollPlugin({
                offset: 80,
            }),
            new SwupSlideTheme({
                mainElement: ".main-content-body",
            }),
            new SwupPreloadPlugin(),
        ],
        containers: ["#swup"],
    });
</script>




	
<script src="/js/build/tools/imageViewer.js" type="module"></script>

<script src="/js/build/utils.js" type="module"></script>

<script src="/js/build/main.js" type="module"></script>

<script src="/js/build/layouts/navbarShrink.js" type="module"></script>

<script src="/js/build/tools/scrollTopBottom.js" type="module"></script>

<script src="/js/build/tools/lightDarkSwitch.js" type="module"></script>

<script src="/js/build/layouts/categoryList.js" type="module"></script>



    
<script src="/js/build/tools/localSearch.js" type="module"></script>




    
<script src="/js/build/tools/codeBlock.js" type="module"></script>




    
<script src="/js/build/layouts/lazyload.js" type="module"></script>




    
<script src="/js/build/tools/runtime.js"></script>

    
<script src="/js/build/libs/odometer.min.js"></script>

    
<link rel="stylesheet" href="/assets/odometer-theme-minimal.css">




  
<script src="/js/build/libs/Typed.min.js"></script>

  
<script src="/js/build/plugins/typed.js" type="module"></script>








    
<script src="/js/build/libs/anime.min.js"></script>





    
<script src="/js/build/tools/tocToggle.js" type="module" data-swup-reload-script=""></script>

<script src="/js/build/layouts/toc.js" type="module" data-swup-reload-script=""></script>

<script src="/js/build/plugins/tabs.js" type="module" data-swup-reload-script=""></script>




<script src="/js/build/libs/moment-with-locales.min.js" data-swup-reload-script=""></script>


<script src="/js/build/layouts/essays.js" type="module" data-swup-reload-script=""></script>





	
</body>

</html>