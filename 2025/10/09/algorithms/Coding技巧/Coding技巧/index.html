<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="keywords" content="Hexo Theme Redefine">
    
    <meta name="author" content="ZaynPei">
    
    <!-- Completely eliminate flash of wrong theme -->
    <script>
        (function() {
            const THEME_KEY = "REDEFINE-THEME-STATUS";
            const DARK = "dark", LIGHT = "light";
            
            // Get preferred theme
            function getTheme() {
                try {
                    const saved = localStorage.getItem(THEME_KEY);
                    if (saved) {
                        const { isDark } = JSON.parse(saved);
                        return isDark ? DARK : LIGHT;
                    }
                } catch (e) {}
                
                return matchMedia("(prefers-color-scheme: dark)").matches ? DARK : LIGHT;
            }
            
            // Apply theme to document
            function applyTheme(theme) {
                const isDark = theme === DARK;
                const root = document.documentElement;
                
                // Set data attribute for CSS variables
                root.setAttribute("data-theme", theme);
                
                // Set classes for compatibility
                root.classList.add(theme);
                root.classList.remove(isDark ? LIGHT : DARK);
                root.style.colorScheme = theme;
            }
            
            // Initial application
            const theme = getTheme();
            applyTheme(theme);
            
            // Listen for system preference changes
            matchMedia("(prefers-color-scheme: dark)").addEventListener("change", ({ matches }) => {
                // Only update if using system preference (no localStorage entry)
                if (!localStorage.getItem(THEME_KEY)) {
                    applyTheme(matches ? DARK : LIGHT);
                }
            });
            
            // Set body classes once DOM is ready
            if (document.readyState !== "loading") {
                document.body.classList.add(theme + "-mode");
            } else {
                document.addEventListener("DOMContentLoaded", () => {
                    document.body.classList.add(theme + "-mode");
                    document.body.classList.remove((theme === DARK ? LIGHT : DARK) + "-mode");
                });
            }
        })();
    </script>
    
    <!-- Critical CSS to prevent flash -->
    <style>
        :root[data-theme="dark"] {
            --background-color: #202124;
            --background-color-transparent: rgba(32, 33, 36, 0.6);
            --second-background-color: #2d2e32;
            --third-background-color: #34353a;
            --third-background-color-transparent: rgba(32, 33, 36, 0.6);
            --primary-color: #0066CC;
            --first-text-color: #ffffff;
            --second-text-color: #eeeeee;
            --third-text-color: #bebec6;
            --fourth-text-color: #999999;
            --default-text-color: #bebec6;
            --invert-text-color: #373D3F;
            --border-color: rgba(255, 255, 255, 0.08);
            --selection-color: #0066CC;
            --shadow-color-1: rgba(255, 255, 255, 0.08);
            --shadow-color-2: rgba(255, 255, 255, 0.05);
        }
        
        :root[data-theme="light"] {
            --background-color: #fff;
            --background-color-transparent: rgba(255, 255, 255, 0.6);
            --second-background-color: #f8f8f8;
            --third-background-color: #f2f2f2;
            --third-background-color-transparent: rgba(241, 241, 241, 0.6);
            --primary-color: #0066CC;
            --first-text-color: #16171a;
            --second-text-color: #2f3037;
            --third-text-color: #5e5e5e;
            --fourth-text-color: #eeeeee;
            --default-text-color: #373D3F;
            --invert-text-color: #bebec6;
            --border-color: rgba(0, 0, 0, 0.08);
            --selection-color: #0066CC;
            --shadow-color-1: rgba(0, 0, 0, 0.08);
            --shadow-color-2: rgba(0, 0, 0, 0.05);
        }
        
        body {
            background-color: var(--background-color);
            color: var(--default-text-color);
        }
        
        /* Apply body classes as soon as DOM is ready */
        :root[data-theme="dark"] body {
            background-color: var(--background-color);
            color: var(--default-text-color);
        }
    </style>
    
    <!-- preconnect -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>

    
    <!--- Seo Part-->
    
    <link rel="canonical" href="https://zaynpei.github.io/2025/10/09/algorithms/coding技巧/coding技巧/"/>
    <meta name="robots" content="index,follow">
    <meta name="googlebot" content="index,follow">
    <meta name="revisit-after" content="1 days">
    
    
    
        
        <meta name="description" content="Hexo Theme Redefine, Redefine Your Hexo Journey.">
<meta property="og:type" content="article">
<meta property="og:title" content="Coding技巧">
<meta property="og:url" content="https://zaynpei.github.io/2025/10/09/algorithms/Coding%E6%8A%80%E5%B7%A7/Coding%E6%8A%80%E5%B7%A7/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="Hexo Theme Redefine, Redefine Your Hexo Journey.">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://zaynpei.github.io/images/redefine-og.webp">
<meta property="article:published_time" content="2025-10-09T14:00:00.000Z">
<meta property="article:modified_time" content="2025-11-03T12:20:53.065Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="algorithms">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://zaynpei.github.io/images/redefine-og.webp">
    
    
    <!--- Icon Part-->
    <link rel="icon" type="image/png" href="/images/icons%E7%81%AF%E5%A1%94.png" sizes="192x192">
    <link rel="apple-touch-icon" sizes="180x180" href="/images/icons%E7%81%AF%E5%A1%94.png">
    <meta name="theme-color" content="#A31F34">
    <link rel="shortcut icon" href="/images/icons%E7%81%AF%E5%A1%94.png">
    <!--- Page Info-->
    
    <title>
        
            Coding技巧 | ZaynPei&#39;s Base
        
    </title>

    
<link rel="stylesheet" href="/fonts/Chillax/chillax.css">


    <!--- Inject Part-->
    
        
            
    
            
    
            
                
                    <link rel="stylesheet" href="/css/custom.css">
                
    

    
<link rel="stylesheet" href="/css/style.css">


    
        
<link rel="stylesheet" href="/css/build/tailwind.css">

    

    
<link rel="stylesheet" href="/fonts/GeistMono/geist-mono.css">

    
<link rel="stylesheet" href="/fonts/Geist/geist.css">

    <!--- Font Part-->
    
    
        <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;700&display=swap" rel="stylesheet">
    
    
        <link href="https://cdn.jsdelivr.net/npm/@callmebill/lxgw-wenkai-web@1.320/style.css" rel="stylesheet">
    
    
    
    

    <script id="hexo-configurations">
    window.config = {"hostname":"zaynpei.github.io","root":"/","language":"en","path":"search.json"};
    window.theme = {"articles":{"style":{"font_size":"16px","line_height":1.5,"image_border_radius":"14px","image_alignment":"center","image_caption":false,"link_icon":true,"delete_mask":false,"title_alignment":"left","headings_top_spacing":{"h1":"3.2rem","h2":"2.4rem","h3":"1.9rem","h4":"1.6rem","h5":"1.4rem","h6":"1.3rem"}},"word_count":{"enable":true,"count":true,"min2read":true},"author_label":{"enable":true,"auto":false,"list":[]},"code_block":{"copy":true,"style":"mac","highlight_theme":{"light":"default","dark":"a11y-dark"},"font":{"enable":true,"family":"'JetBrains Mono', monospace","url":"https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;700&display=swap"}},"toc":{"enable":true,"max_depth":6,"number":false,"expand":true,"init_open":true},"copyright":{"enable":false,"default":"cc_by_nc_sa"},"lazyload":true,"pangu_js":false,"recommendation":{"enable":false,"title":"推荐阅读","limit":3,"mobile_limit":2,"placeholder":"/images/wallhaven-wqery6-light.webp","skip_dirs":[]},"font":{"enable":true,"url":"https://cdn.jsdelivr.net/npm/@callmebill/lxgw-wenkai-web@1.320/style.css","family":"'LXGW WenKai', sans-serif"}},"colors":{"primary":"#A31F34","secondary":null,"default_mode":"light"},"global":{"fonts":{"chinese":{"enable":true,"family":"'LXGW WenKai', sans-serif","url":"https://cdn.jsdelivr.net/npm/@callmebill/lxgw-wenkai-web@1.320/style.css"},"english":{"enable":false,"family":null,"url":null},"title":{"enable":false,"family":null,"url":null}},"content_max_width":"1000px","sidebar_width":"210px","hover":{"shadow":true,"scale":false},"scroll_progress":{"bar":false,"percentage":true},"website_counter":{"url":"https://cn.vercount.one/js","enable":false,"site_pv":true,"site_uv":true,"post_pv":true},"single_page":true,"preloader":{"enable":false,"custom_message":null},"side_tools":{"gear_rotation":true,"auto_expand":false},"open_graph":{"enable":true,"image":"/images/redefine-og.webp","description":"Hexo Theme Redefine, Redefine Your Hexo Journey."},"google_analytics":{"enable":false,"id":null}},"home_banner":{"enable":true,"style":"fixed","image":{"light":"/images/wallhaven-wqery6-light.webp","dark":"/images/wallhaven-wqery6-dark.webp"},"title":"For ourselves","subtitle":{"text":["For yourself"],"hitokoto":{"enable":false,"show_author":false,"api":"https://v1.hitokoto.cn"},"typing_speed":100,"backing_speed":80,"starting_delay":500,"backing_delay":1500,"loop":true,"smart_backspace":true},"text_color":{"light":"#fff","dark":"#d1d1b6"},"text_style":{"title_size":"2.8rem","subtitle_size":"1.5rem","line_height":1.2},"custom_font":{"enable":false,"family":null,"url":null},"social_links":{"enable":false,"style":"default","links":{"github":null,"instagram":null,"zhihu":null,"twitter":null,"email":null},"qrs":{"weixin":null}}},"plugins":{"feed":{"enable":false},"aplayer":{"enable":false,"type":"fixed","audios":[{"name":null,"artist":null,"url":null,"cover":null,"lrc":null}]},"mermaid":{"enable":false,"version":"11.4.1"}},"version":"2.8.5","navbar":{"auto_hide":false,"color":{"left":"#f78736","right":"#367df7","transparency":35},"width":{"home":"1200px","pages":"1000px"},"links":{"Home":{"path":"/","icon":"fa-regular fa-house"},"ai":{"path":"docs/ai/","icon":"fa-regular fa-robot"},"algorithms":{"path":"docs/algorithms/","icon":"fa-regular fa-code"},"language":{"path":"docs/lang/","icon":"fa-regular fa-language"},"system":{"path":"docs/system/","icon":"fa-regular fa-desktop"},"web":{"path":"docs/web/","icon":"fa-regular fa-globe"},"misc":{"path":"docs/misc/","icon":"fa-regular fa-boxes-stacked"},"tools":{"path":"docs/tools/","icon":"fa-regular fa-wrench"}},"search":{"enable":true,"preload":true}},"page_templates":{"friends_column":2,"tags_style":"blur"},"home":{"sidebar":{"enable":true,"position":"left","first_item":"menu","announcement":null,"show_on_mobile":true,"links":null},"article_date_format":"auto","excerpt_length":200,"categories":{"enable":true,"limit":3},"tags":{"enable":true,"limit":3}},"footerStart":"2025/6/25 13:20:00"};
    window.lang_ago = {"second":"%s seconds ago","minute":"%s minutes ago","hour":"%s hours ago","day":"%s days ago","week":"%s weeks ago","month":"%s months ago","year":"%s years ago"};
    window.data = {"masonry":false};
  </script>
    
    <!--- Fontawesome Part-->
    
<link rel="stylesheet" href="/fontawesome/fontawesome.min.css">

    
<link rel="stylesheet" href="/fontawesome/brands.min.css">

    
<link rel="stylesheet" href="/fontawesome/solid.min.css">

    
<link rel="stylesheet" href="/fontawesome/regular.min.css">

    
    
    
    
<meta name="generator" content="Hexo 7.3.0"><style>mjx-container[jax="SVG"] {
  direction: ltr;
}

mjx-container[jax="SVG"] > svg {
  overflow: visible;
}

mjx-container[jax="SVG"][display="true"] {
  display: block;
  text-align: center;
  margin: 1em 0;
}

mjx-container[jax="SVG"][justify="left"] {
  text-align: left;
}

mjx-container[jax="SVG"][justify="right"] {
  text-align: right;
}

g[data-mml-node="merror"] > g {
  fill: red;
  stroke: red;
}

g[data-mml-node="merror"] > rect[data-background] {
  fill: yellow;
  stroke: none;
}

g[data-mml-node="mtable"] > line[data-line] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > rect[data-frame] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > .mjx-dashed {
  stroke-dasharray: 140;
}

g[data-mml-node="mtable"] > .mjx-dotted {
  stroke-linecap: round;
  stroke-dasharray: 0,140;
}

g[data-mml-node="mtable"] > svg {
  overflow: visible;
}

[jax="SVG"] mjx-tool {
  display: inline-block;
  position: relative;
  width: 0;
  height: 0;
}

[jax="SVG"] mjx-tool > mjx-tip {
  position: absolute;
  top: 0;
  left: 0;
}

mjx-tool > mjx-tip {
  display: inline-block;
  padding: .2em;
  border: 1px solid #888;
  font-size: 70%;
  background-color: #F8F8F8;
  color: black;
  box-shadow: 2px 2px 5px #AAAAAA;
}

g[data-mml-node="maction"][data-toggle] {
  cursor: pointer;
}

mjx-status {
  display: block;
  position: fixed;
  left: 1em;
  bottom: 1em;
  min-width: 25%;
  padding: .2em .4em;
  border: 1px solid #888;
  font-size: 90%;
  background-color: #F8F8F8;
  color: black;
}

foreignObject[data-mjx-xml] {
  font-family: initial;
  line-height: normal;
  overflow: visible;
}

.MathJax path {
  stroke-width: 3;
}

mjx-container[display="true"] {
  overflow: auto hidden;
}

mjx-container[display="true"] + br {
  display: none;
}
</style></head>



<body>
	<div class="progress-bar-container">
	

	
	<span class="pjax-progress-bar"></span>
	<!--        <span class="swup-progress-icon">-->
	<!--            <i class="fa-solid fa-circle-notch fa-spin"></i>-->
	<!--        </span>-->
	
</div>

<main class="page-container" id="swup">

	

	<div class="main-content-container flex flex-col justify-between min-h-dvh">
		<div class="main-content-header">
			<header class="navbar-container px-6 md:px-12">
    <div class="navbar-content transition-navbar ">
        <div class="left">
            
                <a class="logo-image h-8 w-8 sm:w-10 sm:h-10 mr-3" href="/">
                    <img src="/images/icons%E7%81%AF%E5%A1%94.png" class="w-full h-full rounded-xs">
                </a>
            
            <a class="logo-title" href="/">
                
                ZaynPei&#39;s Base
                
            </a>
        </div>

        <div class="right">
            <!-- PC -->
            <div class="desktop">
                <ul class="navbar-list">
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class=""
                                   href="/"
                                        >
                                    <i class="fa-regular fa-house fa-fw"></i>
                                    HOME
                                    
                                </a>

                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class=""
                                   href="/docs/ai/"
                                        >
                                    <i class="fa-regular fa-robot fa-fw"></i>
                                    AI
                                    
                                </a>

                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class=""
                                   href="/docs/algorithms/"
                                        >
                                    <i class="fa-regular fa-code fa-fw"></i>
                                    ALGORITHMS
                                    
                                </a>

                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class=""
                                   href="/docs/lang/"
                                        >
                                    <i class="fa-regular fa-language fa-fw"></i>
                                    LANGUAGE
                                    
                                </a>

                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class=""
                                   href="/docs/system/"
                                        >
                                    <i class="fa-regular fa-desktop fa-fw"></i>
                                    SYSTEM
                                    
                                </a>

                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class=""
                                   href="/docs/web/"
                                        >
                                    <i class="fa-regular fa-globe fa-fw"></i>
                                    WEB
                                    
                                </a>

                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class=""
                                   href="/docs/misc/"
                                        >
                                    <i class="fa-regular fa-boxes-stacked fa-fw"></i>
                                    MISC
                                    
                                </a>

                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class=""
                                   href="/docs/tools/"
                                        >
                                    <i class="fa-regular fa-wrench fa-fw"></i>
                                    TOOLS
                                    
                                </a>

                                <!-- Submenu -->
                                
                            </li>
                    
                    
                        <li class="navbar-item search search-popup-trigger">
                            <i class="fa-solid fa-magnifying-glass"></i>
                        </li>
                    
                </ul>
            </div>
            <!-- Mobile -->
            <div class="mobile">
                
                    <div class="icon-item search search-popup-trigger"><i class="fa-solid fa-magnifying-glass"></i>
                    </div>
                
                <div class="icon-item navbar-bar">
                    <div class="navbar-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Mobile sheet -->
    <div class="navbar-drawer h-dvh w-full absolute top-0 left-0 bg-background-color flex flex-col justify-between">
        <ul class="drawer-navbar-list flex flex-col px-4 justify-center items-start">
            
                
                    

                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                           href="/"
                        >
                            <span>
                                HOME
                            </span>
                            
                                <i class="fa-regular fa-house fa-sm fa-fw"></i>
                            
                        </a>
                        

                        
                    </li>
            
                
                    

                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                           href="/docs/ai/"
                        >
                            <span>
                                AI
                            </span>
                            
                                <i class="fa-regular fa-robot fa-sm fa-fw"></i>
                            
                        </a>
                        

                        
                    </li>
            
                
                    

                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                           href="/docs/algorithms/"
                        >
                            <span>
                                ALGORITHMS
                            </span>
                            
                                <i class="fa-regular fa-code fa-sm fa-fw"></i>
                            
                        </a>
                        

                        
                    </li>
            
                
                    

                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                           href="/docs/lang/"
                        >
                            <span>
                                LANGUAGE
                            </span>
                            
                                <i class="fa-regular fa-language fa-sm fa-fw"></i>
                            
                        </a>
                        

                        
                    </li>
            
                
                    

                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                           href="/docs/system/"
                        >
                            <span>
                                SYSTEM
                            </span>
                            
                                <i class="fa-regular fa-desktop fa-sm fa-fw"></i>
                            
                        </a>
                        

                        
                    </li>
            
                
                    

                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                           href="/docs/web/"
                        >
                            <span>
                                WEB
                            </span>
                            
                                <i class="fa-regular fa-globe fa-sm fa-fw"></i>
                            
                        </a>
                        

                        
                    </li>
            
                
                    

                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                           href="/docs/misc/"
                        >
                            <span>
                                MISC
                            </span>
                            
                                <i class="fa-regular fa-boxes-stacked fa-sm fa-fw"></i>
                            
                        </a>
                        

                        
                    </li>
            
                
                    

                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                           href="/docs/tools/"
                        >
                            <span>
                                TOOLS
                            </span>
                            
                                <i class="fa-regular fa-wrench fa-sm fa-fw"></i>
                            
                        </a>
                        

                        
                    </li>
            

            
            
        </ul>

        <div class="statistics flex justify-around my-2.5">
    <a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/tags">
        <div class="number text-2xl sm:text-xl text-second-text-color font-semibold">19</div>
        <div class="label text-third-text-color text-sm">Tags</div>
    </a>
    <a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/categories">
        <div class="number text-2xl sm:text-xl text-second-text-color font-semibold">21</div>
        <div class="label text-third-text-color text-sm">Categories</div>
    </a>
    <a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/archives">
        <div class="number text-2xl sm:text-xl text-second-text-color font-semibold">193</div>
        <div class="label text-third-text-color text-sm">Posts</div>
    </a>
</div>
    </div>

    <div class="window-mask"></div>

</header>


		</div>

		<div class="main-content-body transition-fade-up">
			

			<div class="main-content">
				<div class="post-page-container flex relative justify-between box-border w-full h-full">
	<div class="article-content-container">

		<div class="article-title relative w-full">
			
			<div class="w-full flex items-center pt-6 justify-start">
				<h1 class="article-title-regular text-second-text-color tracking-tight text-4xl md:text-6xl font-semibold px-2 sm:px-6 md:px-8 py-3">Coding技巧</h1>
			</div>
			
		</div>

		
		<div class="article-header flex flex-row gap-2 items-center px-2 sm:px-6 md:px-8">
			<div class="avatar w-[46px] h-[46px] flex-shrink-0 rounded-medium border border-border-color p-[1px]">
				<img src="/images/redefine-avatar.svg">
			</div>
			<div class="info flex flex-col justify-between">
				<div class="author flex items-center">
					<span class="name text-default-text-color text-lg font-semibold">ZaynPei</span>
					
					<span class="author-label ml-1.5 text-xs px-2 py-0.5 rounded-small text-third-text-color border border-shadow-color-1">Lv6</span>
					
				</div>
				<div class="meta-info">
					<div class="article-meta-info">
    <span class="article-date article-meta-item">
        <i class="fa-regular fa-pen-fancy"></i>&nbsp;
        <span class="desktop">2025-10-09 22:00</span>
        <span class="mobile">2025-10-09 22:00</span>
        <span class="hover-info">Created</span>
    </span>
    
        <span class="article-date article-meta-item">
            <i class="fa-regular fa-wrench"></i>&nbsp;
            <span class="desktop">2025-11-03 20:20:53</span>
            <span class="mobile">2025-11-03 20:20:53</span>
            <span class="hover-info">Updated</span>
        </span>
    

    
        <span class="article-categories article-meta-item">
            <i class="fa-regular fa-folders"></i>&nbsp;
            <ul>
                
                
                    
                        
                        <li>
                            <a href="/categories/algorithms/">algorithms</a>&nbsp;
                        </li>
                    
                    
                
            </ul>
        </span>
    
    
        <span class="article-tags article-meta-item">
            <i class="fa-regular fa-tags"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/tags/algorithms/">algorithms</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    

    
    
        <span class="article-wordcount article-meta-item">
            <i class="fa-regular fa-typewriter"></i>&nbsp;<span>12.5k Words</span>
        </span>
    
    
        <span class="article-min2read article-meta-item">
            <i class="fa-regular fa-clock"></i>&nbsp;<span>50 Mins</span>
        </span>
    
    
</div>

				</div>
			</div>
		</div>
		

		


		<div class="article-content markdown-body px-2 sm:px-6 md:px-8 pb-8">
			<h2 id="二分查找">二分查找</h2>
<p>二分查找 (Binary Search)
是一种高效的查找算法，适用于在<strong>有序数组或列表</strong>中查找特定元素。它通过<strong>不断将搜索范围减半</strong>来快速定位目标元素，从而大大减少了查找的时间复杂度。</p>
<p>代码实现如下: <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">binarySearch</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>{</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) {</span><br><span class="line">        <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;  <span class="comment">// 防止溢出</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) {</span><br><span class="line">            <span class="keyword">return</span> mid;  <span class="comment">// 找到目标元素，返回其索引</span></span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) {</span><br><span class="line">            left = mid + <span class="number">1</span>;  <span class="comment">// 目标在右半部分</span></span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            right = mid - <span class="number">1</span>;  <span class="comment">// 目标在左半部分</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;  <span class="comment">// 未找到目标元素</span></span><br><span class="line">    <span class="comment">// return left;  // 如果需要返回插入位置, 可以返回 left</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure></div> &gt; 最后的 left 指向第一个大于等于
target 的位置, 也就是插入位置.</p>
<h2 id="滑动窗口">滑动窗口</h2>
<p>滑动窗口是一种用于处理<strong>数组或字符串</strong>中<strong>子序列</strong>问题的高效算法技巧。它通过维护一个<strong>动态调整的窗口</strong>来遍历数据结构，从而避免了重复计算，提高了算法的效率。</p>
<h3 id="固定长度与可变长度滑动窗口">固定长度与可变长度滑动窗口</h3>
<p>按照窗口的长度是否固定，滑动窗口可以分为两种类型：</p>
<ol type="1">
<li>固定长度滑动窗口 (Fixed-size Sliding
Window)：窗口的大小在整个过程中保持不变。适用于寻找满足某种条件的<strong>固定长度子序列</strong>的问题。例如，寻找数组中所有长度为k的子数组的最大和。</li>
<li>可变长度滑动窗口 (Variable-size Sliding
Window)：窗口的大小可以根据需要动态调整。适用于寻找满足某种条件的<strong>任意长度子序列</strong>的问题。例如，寻找字符串中包含所有目标字符的最短子串。</li>
</ol>
<h4 id="固定长度滑动窗口">固定长度滑动窗口</h4>
<p>固定长度滑动窗口的基本思想是维护一个<strong>固定大小的窗口</strong>，并通过移动窗口来遍历数组或字符串。
-
初始化时，窗口覆盖数据结构的<strong>前k个元素</strong>，计算初始窗口的相关信息（如和、最大值等）。
- 循环遍历,
逐步向右移动窗口，每次移动一位，通过<strong>加入新元素</strong>并<strong>移除旧元素</strong>来更新窗口的信息。</p>
<p>例如, 寻找数组中所有长度为k的子数组的最大和: <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxSumSubarray</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>{</span><br><span class="line">    <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (n &lt; k) <span class="keyword">return</span> <span class="number">-1</span>;  <span class="comment">// 不合法的输入</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> maxSum = <span class="number">0</span>;  <span class="comment">// 记录最大和</span></span><br><span class="line">    <span class="type">int</span> cur = <span class="number">0</span>;  <span class="comment">// 记录当前窗口和</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化窗口</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; i++) {</span><br><span class="line">        cur += nums[i];</span><br><span class="line">    }</span><br><span class="line">    maxSum = cur;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环移动窗口</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n-k; i++) {</span><br><span class="line">        cur += nums[i+k<span class="number">-1</span>] - nums[i<span class="number">-1</span>];  <span class="comment">// 更新窗口和</span></span><br><span class="line">        maxSum = <span class="built_in">max</span>(maxSum, cur);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> maxSum;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>
对于其他问题, 只要窗口大小固定, 都可以使用类似的方法进行处理,
基本套路都是两步走: 初始化窗口 -&gt; 移动窗口并更新结果.</p>
<h5 id="示例">示例</h5>
<p>有这样一道题(leetcode239): 给你一个整数数组 nums，有一个大小为 k
的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k
个数字。滑动窗口每次只向右移动一位。返回滑动窗口中的最大值。</p>
<p>看起来是固定长度滑动窗口问题,
但是如果直接用上面的固定长度滑动窗口方法, 每次移动窗口都需要遍历窗口内的
k 个元素来找最大值, 时间复杂度是 O(n*k), 会超时.</p>
<p>为什么呢? 因为上面的其他固定长度滑动窗口问题, 每次移动窗口时,
只需要<strong>加上新元素, 减去旧元素</strong>, 窗口内的信息更新是 O(1)
的, 但是求最大值就不行了, 每次移动窗口时,
上一次的最大值可能被移出了窗口, 而我们又没有记录其他元素的信息,
只能遍历窗口内的 k 个元素来找最大值, 这样时间复杂度就是 O(n*k) 了.</p>
<p>为了解决这个问题,
我们需要使用一种特殊的数据结构——<strong>单调队列</strong>，来维护窗口内的元素顺序,
使得我们可以在 O(1) 时间内获取窗口的最大值.
具体代码可以参考队列部分的笔记.</p>
<h4 id="可变长度滑动窗口">可变长度滑动窗口</h4>
<p>可变长度滑动窗口的核心思想是通过<strong>调整窗口的左右边界</strong>来满足特定条件。通常使用<strong>两个指针/索引</strong>（left
和 right）来表示窗口的边界。 - 初始化时，left 和 right
指针都指向数据结构的<strong>起始</strong>位置。 - 循环遍历,
通过<strong>移动 right
指针</strong>来扩展窗口，直到窗口<strong>满足某种条件</strong>（如包含所有目标字符）。
- 然后通过<strong>移动 left
指针来收缩窗口</strong>，直到窗口<strong>不再满足条件</strong>。在这个过程中，<strong>记录</strong>满足条件的窗口信息（如最短长度、最大长度等）。
- 重复上述过程，直到 <strong>right 指针遍历完整个数据结构</strong>。</p>
<blockquote>
<p>注意:
可变长度滑动窗口通常需要一个<strong>辅助数据结构</strong>（如哈希表）来记录窗口内的元素信息，以便<strong>快速判断窗口是否满足条件</strong>。</p>
</blockquote>
<p>一般可变长度滑动窗口的题型有三种: 1.
找出满足某种条件的<strong>最小子数组/子字符串</strong>。 2.
找出满足某种条件的<strong>最大子数组/子字符串</strong>。 3.
计算满足某种条件的<strong>子数组/子字符串的数量</strong>。</p>
<p>例如, 给定一个含有 n 个正整数的数组和一个正整数 target ,
找出该数组中满足其和 ≥ target
的<strong>长度最小的连续子数组</strong>的长度: (最小长度子数组问题)
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="type">int</span> target, vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>{</span><br><span class="line">    <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span>(target&gt;<span class="built_in">accumulate</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>(),<span class="number">0</span>)) <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">// 特殊情况处理</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> left=<span class="number">0</span>, right=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> minlen = INT_MAX;</span><br><span class="line">    <span class="type">int</span> cur = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(right=<span class="number">0</span>;right&lt;n;right++){  <span class="comment">// 扩展窗口</span></span><br><span class="line"></span><br><span class="line">        cur += nums[right];  <span class="comment">// 增加当前窗口和</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(cur&gt;=target){  <span class="comment">// 收缩窗口</span></span><br><span class="line">            minlen = <span class="built_in">min</span>(right-left<span class="number">+1</span>, minlen);</span><br><span class="line">            cur -= nums[left];  <span class="comment">// 一定注意先减去left位置的元素, 再left++!!!!!</span></span><br><span class="line">            left++;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> minlen;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div></p>
<p>又例如, 给定一个字符串 s ,
求每个字符最多出现两次的<strong>最长子字符串的长度</strong>:
(最大长度子字符串问题) <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">lengthOfLongestSubstringTwoDistinct</span><span class="params">(string s)</span> </span>{</span><br><span class="line">    <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">3</span>) <span class="keyword">return</span> n;  <span class="comment">// 特殊情况处理</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> maxLen = <span class="number">2</span>;</span><br><span class="line">    unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; charCount;  <span class="comment">// 记录窗口内字符的出现次数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (right = <span class="number">0</span>; right &lt; n; right++) {  <span class="comment">// 扩展窗口</span></span><br><span class="line">        charCount[s[right]]++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (charCount.<span class="built_in">size</span>() &gt; <span class="number">2</span>) {  <span class="comment">// 收缩窗口, 直到左边界到达和右边界相同字符的位置</span></span><br><span class="line"></span><br><span class="line">            charCount[s[left]]--;</span><br><span class="line">            left++;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        maxLen = <span class="built_in">max</span>(maxLen, right - left + <span class="number">1</span>);  <span class="comment">// 更新最大长度</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> maxLen;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div> &gt; 其实, 之所以可以滑动窗口解决,
一个必不可少的条件就是<strong>连续性</strong>,
也就是说问题本质上是求一个<strong>连续子数组</strong>或者<strong>连续子字符串</strong>的问题,
这样才能用滑动窗口来解决.</p>
<p>下一个示例则是求子数组个数的问题: 给你一个整数数组 nums 和一个 正整数
k , 请你统计有多少满足 「 nums 中的最大 元素」<strong>至少出现 k
次</strong>(越多越行)的子数组，并返回满足这一条件的子数组的数目。</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">countSubarrays</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>{</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> left=<span class="number">0</span>, right=<span class="number">0</span>;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> sum=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> max_num=<span class="number">0</span>;  </span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> max_sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">            max_num = <span class="built_in">max</span>(nums[i], max_num);  <span class="comment">// 找到数组中的最大值</span></span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(right=<span class="number">0</span>;right&lt;n;right++){</span><br><span class="line">            <span class="keyword">if</span>(nums[right]==max_num) max_sum++;  <span class="comment">// 记录当前窗口内最大值的个数</span></span><br><span class="line">            <span class="keyword">while</span>(max_sum&gt;=k){  <span class="comment">// 收缩窗口, 不过是满足条件时</span></span><br><span class="line">                sum+=n-right;   <span class="comment">// 因为要求子数组个数, 所以每次符合条件进入收缩窗口时, 这个数组右边界到数组末尾的所有子数组都是符合条件的</span></span><br><span class="line">                <span class="keyword">if</span>(nums[left]==max_num) max_sum--;  <span class="comment">// 先减去left位置的元素对最大值个数的影响</span></span><br><span class="line">                left++;  <span class="comment">// 再移动左指针</span></span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></table></figure></div>
<p>还有一个经典问题:
给一个数组的分数定义为数组之和乘以数组的长度。比方说，[1, 2, 3, 4, 5]
的分数为 (1 + 2 + 3 + 4 + 5) * 5 = 75 。给你一个正整数数组 nums
和一个整数 k ，请你返回 nums 中分数 严格小于 k 的
非空整数子数组数目。(越小越行)</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">countSubarrays</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">long</span> <span class="type">long</span> k)</span> </span>{</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> cur_sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(right=<span class="number">0</span>;right&lt;n;right++){</span><br><span class="line">            cur_sum += nums[right];  <span class="comment">// 增加当前窗口和</span></span><br><span class="line">            <span class="keyword">while</span>(cur_sum*(right-left<span class="number">+1</span>)&gt;=k){  <span class="comment">// 收缩窗口, 如果不满足条件时</span></span><br><span class="line">                cur_sum -= nums[left];  <span class="comment">// 先减去left位置的元素对窗口和的影响</span></span><br><span class="line">                left++;  <span class="comment">// 再移动左指针</span></span><br><span class="line">            }</span><br><span class="line">            sum += (right-left<span class="number">+1</span>);  <span class="comment">// 增加符合条件的子数组个数, 这里因为求的是小于k的子数组个数, 所以所有以right结尾的子数组都是符合条件的</span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></table></figure></div>
<p>回顾上面两道题, 可以发现, 求子数组个数的问题, 每次满足条件时,
以right结尾的所有子数组, 或者是以left开头的所有子数组, 都是符合条件的,
这样就可以快速统计子数组个数. 也就是当窗口 [left, right]
满足某个条件时，其<strong>内部的某些子数组</strong>（或<strong>外部的某些超数组</strong>）也必然满足条件。我们利用这个性质来<strong>批量计数</strong>。</p>
<p>而且还可以发现,
第一题收缩窗口时是<strong>满足条件时</strong>收缩窗口,
第二题则是<strong>不满足条件时</strong>收缩窗口,
这取决于你要统计的<strong>子数组</strong>是“<strong>以 left
开头</strong>”还是“<strong>以 right 结尾</strong>”。</p>
<table>
<colgroup>
<col style="width: 15%">
<col style="width: 40%">
<col style="width: 44%">
</colgroup>
<thead>
<tr>
<th>策略</th>
<th>策略一：满足时收缩</th>
<th>策略二：不满足时收缩</th>
</tr>
</thead>
<tbody>
<tr>
<td>条件类型</td>
<td>“至少”型 (如 sum ≥ k)</td>
<td>“至多”型 (如 sum &lt;= k)</td>
</tr>
<tr>
<td>统计对象</td>
<td>所有以 left 为起点的达标数组</td>
<td>所有以 right 为终点的达标数组</td>
</tr>
<tr>
<td>while 循环条件</td>
<td>while (条件满足)</td>
<td>while (条件不满足)</td>
</tr>
<tr>
<td>收缩 left 的目的</td>
<td>统计完 left 后，移动到下一个起点</td>
<td>修复窗口，使其重新满足条件</td>
</tr>
<tr>
<td>计数公式</td>
<td><code>total += n - right;</code> (在 while 内部)</td>
<td><code>total += right - left + 1;</code> (在 for 循环内, while
外部)</td>
</tr>
</tbody>
</table>
<p>除此之外, 还有一种是”恰好”型的问题, 例如求恰好包含 k
个不同字符的最长子字符串,
这种问题可以<strong>转化</strong>为”至多”型问题来解决, 即: 恰好包含 k
个不同字符的最长子字符串 = 包含 至多 k 个不同字符的最长子字符串 - 包含
至多 (k-1) 个不同字符的最长子字符串.</p>
<p>或者也可以转换w为”至少”型问题来解决, 即: 恰好包含 k
个不同字符的最长子字符串 = 包含 至少 k 个不同字符的最长子字符串 - 包含
至少 (k+1) 个不同字符的最长子字符串.</p>
<p>例如给你一个二元数组 nums ，和一个整数 goal
，请你统计并返回有多少个和为 goal 的 非空 子数组。 <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">mostk</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> goal)</span></span>{</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> left=<span class="number">0</span>, right=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> level=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(right=<span class="number">0</span>;right&lt;n;right++){</span><br><span class="line">            level+=nums[right];</span><br><span class="line">            <span class="keyword">while</span>(level&gt;=goal&amp;&amp;left&lt;=right){  <span class="comment">// 符合条件时收缩</span></span><br><span class="line">                sum+=n-right;</span><br><span class="line">                level-=nums[left];</span><br><span class="line">                left++;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numSubarraysWithSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> goal)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">mostk</span>(nums, goal)-<span class="built_in">mostk</span>(nums, goal<span class="number">+1</span>);  <span class="comment">// 转换为"至少"型问题, 包含 至少 k 个不同字符的最长子字符串 - 包含 至少 (k+1) 个不同字符的最长子字符串</span></span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></table></figure></div></p>
<h2 id="枚举技巧">枚举技巧</h2>
<p>侧重于解决问题的通用思维方式，特别是如何<strong>优化循环和遍历</strong>。</p>
<ul>
<li>枚举右，维护左：一种将 <span class="math inline"><em>O</em>(<em>n</em><sup>2</sup>)</span>
复杂度（双变量）问题优化到 <span class="math inline"><em>O</em>(<em>n</em>)</span>（单变量）的常用技巧，通常与哈希表结合使用。-
枚举中间：处理三元组或四元组问题（如 <span class="math inline"><em>i</em> &lt; <em>j</em> &lt; <em>k</em></span>）的有效策略，通过固定中间变量
<span class="math inline"><em>j</em></span>，将问题分解为两个独立的子问题（处理
<span class="math inline"><em>i</em></span> 和 <span class="math inline"><em>k</em></span>）。</li>
<li>遍历对角线：针对矩阵问题的特定遍历方式。</li>
</ul>
<h2 id="序列与区间处理-sequence-range-processing">序列与区间处理
(Sequence &amp; Range Processing)</h2>
<p>这种方法用于将一个“朴素”的 <span class="math inline"><em>O</em>(<em>n</em><sup>2</sup>)</span> 解法优化到
<span class="math inline"><em>O</em>(<em>n</em>)</span>。</p>
<p>在我们的算法题中, 可能会遇到两类问题： - <strong>区间查询</strong>
(Range Query)：频繁地询问“数组 <span class="math inline"><em>i</em></span> 到 <span class="math inline"><em>j</em></span>
之间的<strong>和/积/异或值是多少</strong>？” - <strong>区间更新</strong>
(Range Update)：频繁地操作“把数组 <span class="math inline"><em>i</em></span> 到 <span class="math inline"><em>j</em></span> 之间的<strong>所有数都加上 <span class="math inline"><em>k</em></span></strong>。”</p>
<p>如果你对每一次“查询”或“更新”都老老实实地跑一个 for
循环，那么每次操作都是 <span class="math inline"><em>O</em>(<em>n</em>)</span>， <span class="math inline"><em>q</em></span> 次操作就是 <span class="math inline"><em>O</em>(<em>n</em><em>q</em>)</span>，这通常会超时。</p>
<p>下面是两种常见且互逆的优化技巧：</p>
<h3 id="前缀和">前缀和</h3>
<p>前缀和 (Prefix Sum)一般用于快速<strong>区间查询</strong>。 -
原理：花费 <span class="math inline"><em>O</em>(<em>n</em>)</span>
时间预处理一个<strong>prefixSum数组</strong>。 -
效果：之后每一次<strong>区间查询</strong>都降为 <strong><span class="math inline"><em>O</em>(1)</span></strong> 时间。</p>
<p>例如, 给定一个数组 nums，假如题目要求你频繁地计算子数组
nums[i…j]（闭区间）的和或者相关信息, 此时不急着直接入手,
我们可以构建一个<strong>前缀和数组 prefixSum 来预处理</strong>，其中
prefixSum[i] 存储 nums[0…i-1]（从第0个到第 <span class="math inline"><em>i</em> − 1</span> 个元素）的总和。</p>
<p>那么，nums[i…j]（闭区间）的和 <span class="math inline"><em>s</em><em>u</em><em>m</em>(<em>i</em>, <em>j</em>)</span>
是多少？ - <span class="math inline"><em>s</em><em>u</em><em>m</em>(<em>i</em>, <em>j</em>) = (前
<em>j</em> 个元素的和) − (前 <em>i</em> − 1 个元素的和)</span> - <span class="math inline"><em>s</em><em>u</em><em>m</em>(<em>i</em>, <em>j</em>) = <em>p</em><em>r</em><em>e</em><em>f</em><em>i</em><em>x</em><em>S</em><em>u</em><em>m</em>[<em>j</em> + 1] − <em>p</em><em>r</em><em>e</em><em>f</em><em>i</em><em>x</em><em>S</em><em>u</em><em>m</em>[<em>i</em>]</span></p>
<p>这样，我们用 <span class="math inline"><em>O</em>(<em>n</em>)</span>
预处理，换来了 <span class="math inline"><em>O</em>(1)</span>
的查询。</p>
<p>再比如, 问题变为“和为 <span class="math inline"><em>K</em></span>
的子数组有多少个？” 这个问题等价于：找到多少对 <span class="math inline">(<em>i</em>, <em>j</em>)</span> 使得 <span class="math inline"><em>s</em><em>u</em><em>m</em>(<em>i</em>, <em>j</em>) = <em>K</em></span>。</p>
<p>用前缀和公式代入：<span class="math inline"><em>p</em><em>r</em><em>e</em><em>f</em><em>i</em><em>x</em><em>S</em><em>u</em><em>m</em>[<em>j</em> + 1] − <em>p</em><em>r</em><em>e</em><em>f</em><em>i</em><em>x</em><em>S</em><em>u</em><em>m</em>[<em>i</em>] = <em>K</em></span>。
变换一下：<span class="math inline"><em>p</em><em>r</em><em>e</em><em>f</em><em>i</em><em>x</em><em>S</em><em>u</em><em>m</em>[<em>i</em>] = <em>p</em><em>r</em><em>e</em><em>f</em><em>i</em><em>x</em><em>S</em><em>u</em><em>m</em>[<em>j</em> + 1] − <em>K</em></span>。</p>
<p>这成为了一个“两数之和”问题！这就是“枚举右，维护左”的完美应用： -
枚举右 (j)：我们遍历数组，计算出当前的 prefixSum[j+1]（记为
current_sum）。 - 提问：我们需要在 <span class="math inline"><em>j</em></span> 的左边找到一个 <span class="math inline"><em>i</em></span>，使得 prefixSum[i] = current_sum -
K。 - 维护左：我们使用一个哈希表 memo 来存储所有历史上的 prefixSum
值及其出现的次数。</p>
<p>例题: 给定一个整数数组 nums 和一个整数 <span class="math inline"><em>K</em></span>，请你统计并返回该数组中和为 <span class="math inline"><em>K</em></span> 的子数组的个数。(LC 560 和为 K
的子数组个数)</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">subarraySum</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>{</span><br><span class="line">    <span class="comment">// 步骤 1: 初始化哈希表</span></span><br><span class="line">    <span class="comment">// 键(Key): 某个前缀和</span></span><br><span class="line">    <span class="comment">// 值(Value): 该前缀和出现的次数</span></span><br><span class="line">    std::unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; memo;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 步骤 2: 关键初始化</span></span><br><span class="line">    <span class="comment">// 放入 (0, 1) 来处理从索引 0 开始的子数组</span></span><br><span class="line">    <span class="comment">// 解释: 如果 nums[0...j] 的和恰好为 k,</span></span><br><span class="line">    <span class="comment">// 那么 current_sum = k, needed = k - k = 0。</span></span><br><span class="line">    <span class="comment">// 我们需要 memo.count(0) 为 true。</span></span><br><span class="line">    memo[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> current_sum = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> total_count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 步骤 3 &amp; 4: 一次循环 - 提问、查找、维护</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : nums) {</span><br><span class="line">        <span class="comment">// a. 更新状态: (枚举右)</span></span><br><span class="line">        current_sum += num;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// b. 提问: 我们需要找的左侧前缀和是什么？</span></span><br><span class="line">        <span class="type">int</span> needed = current_sum - k;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// c. 查找: 左侧存在吗？</span></span><br><span class="line">        <span class="comment">// 我们在 map 中查找是否存在键(key)为 needed</span></span><br><span class="line">        <span class="keyword">if</span> (memo.<span class="built_in">count</span>(needed)) {</span><br><span class="line">            <span class="comment">// 如果存在，说明找到了一个或多个以 num 结尾的</span></span><br><span class="line">            <span class="comment">// 且和为 k 的子数组。</span></span><br><span class="line">            total_count += memo[needed];</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// d. 维护: (维护左)</span></span><br><span class="line">        <span class="comment">// 把当前的前缀和存入 map，供后续的元素查找</span></span><br><span class="line">        memo[current_sum]++;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> total_count;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>
<p>如果更一般的, 我们会两次遍历 (Two-pass)，提前预处理 - 第一次遍历
(预处理)：创建一个 std::vector<int> prefixSum，prefixSum[i] 存储
nums[0…i-1] 的和。 - 第二次遍历 (求解)： - 创建一个
<code>std::unordered_map&lt;int, int&gt; memo</code>。 - 遍历这个
prefixSum 数组（从 prefixSum[0] 到 prefixSum[n]）。 - 在 memo 中查找
prefixSum[j] - k，累加答案。 - 将 prefixSum[j] 存入 memo。 例如:
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">subarraySum</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>{</span><br><span class="line">    <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="comment">// 步骤 1: 预处理前缀和数组</span></span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">prefixSum</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) {</span><br><span class="line">        prefixSum[i] = prefixSum[i - <span class="number">1</span>] + nums[i - <span class="number">1</span>];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 步骤 2: 初始化哈希表</span></span><br><span class="line">    std::unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; memo;</span><br><span class="line">    memo[<span class="number">0</span>] = <span class="number">1</span>;  <span class="comment">// 处理从索引 0 开始的子数组</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> total_count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 步骤 3: 遍历前缀和数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) {</span><br><span class="line">        <span class="type">int</span> needed = prefixSum[j] - k;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 查找左侧存在吗？</span></span><br><span class="line">        <span class="keyword">if</span> (memo.<span class="built_in">count</span>(needed)) {</span><br><span class="line">            total_count += memo[needed];</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 维护哈希表</span></span><br><span class="line">        memo[prefixSum[j]]++;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> total_count;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div></int></p>
<p>常见题型包括: - 基础（一维）与二维前缀和 - 前缀和 +
哈希表：解决特定和（如和为 <span class="math inline"><em>k</em></span>）的子数组问题的经典组合。 -
距离和（绝对值问题） - 状态压缩前缀和（处理位运算或小状态集）</p>
<h4 id="树上的前缀和">树上的前缀和</h4>
<p>在树结构中，前缀和的概念可以通过<strong>路径和</strong>来实现。路径和是指从树的根节点到当前节点的所有节点值的累加和。例如LC
437. 路径总和 III.</p>
<p>题目: 给定一个二叉树的根节点 root 和一个整数目标和 targetSum
，求该树中 <strong>路径和等于目标和</strong> 的路径数量。路径
不需要从根节点开始，也不需要在叶子节点结束，但路径方向必须是向下的（只能从父节点到子节点）。</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. "前缀和账本" (哈希表)</span></span><br><span class="line"><span class="comment">// 存储 {前缀和 -&gt; 该和出现的次数}</span></span><br><span class="line">std::unordered_map&lt;<span class="type">long</span> <span class="type">long</span>, <span class="type">int</span>&gt; prefixSumCount;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 最终答案</span></span><br><span class="line"><span class="type">int</span> totalPaths = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 目标值</span></span><br><span class="line"><span class="type">int</span> target;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 深度优先搜索 (DFS) 辅助函数</span></span><br><span class="line"><span class="comment"> * @param node 当前节点</span></span><br><span class="line"><span class="comment"> * @param currentPathSum 从根节点到 *当前节点* 的路径总和</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(TreeNode* node, <span class="type">long</span> <span class="type">long</span> currentPathSum)</span> </span>{</span><br><span class="line">    <span class="comment">// Base Case: 节点为空，结束递归</span></span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">nullptr</span>) {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --- 1. 处理当前节点 ---</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新当前路径的前缀和</span></span><br><span class="line">    currentPathSum += node-&gt;val;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找 "补数" (currentPathSum - target)</span></span><br><span class="line">    <span class="comment">// 看看在祖先中，是否存在一个前缀和 `complement`</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> complement = currentPathSum - target;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果 `complement` 存在于 "账本" 中，说明找到了路径</span></span><br><span class="line">    <span class="keyword">if</span> (prefixSumCount.<span class="built_in">count</span>(complement)) {</span><br><span class="line">        totalPaths += prefixSumCount[complement];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --- 2. 更新状态并进入子树 ---</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将当前节点的前缀和加入 "账本"，供其子节点使用</span></span><br><span class="line">    prefixSumCount[currentPathSum]++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 递归处理左右子树</span></span><br><span class="line">    <span class="built_in">dfs</span>(node-&gt;left, currentPathSum);</span><br><span class="line">    <span class="built_in">dfs</span>(node-&gt;right, currentPathSum);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --- 3. 恢复现场 (回溯) ---</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 离开当前节点，返回父节点时，必须将当前节点的前缀和从 "账本" 中移除</span></span><br><span class="line">    <span class="comment">// 这是为了防止干扰 "兄弟" 节点的计算</span></span><br><span class="line">    prefixSumCount[currentPathSum]--;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pathSum</span><span class="params">(TreeNode* root, <span class="type">int</span> targetSum)</span> </span>{</span><br><span class="line">    <span class="comment">// 初始化目标值</span></span><br><span class="line">    target = targetSum;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 初始化哈希表 "账本"</span></span><br><span class="line">    <span class="comment">// 放入 {0, 1} 是为了正确计算 "从根节点开始" 的路径</span></span><br><span class="line">    prefixSumCount[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 启动 DFS，初始前缀和为 0</span></span><br><span class="line">    <span class="built_in">dfs</span>(root, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 返回最终统计的路径总数</span></span><br><span class="line">    <span class="keyword">return</span> totalPaths;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>
<h3 id="差分数组">差分数组</h3>
<p>差分数组 (Difference Array) 一般用于高效<strong>区间更新</strong>。 -
原理：通过维护一个<strong>差分数组
diff</strong>，使得每次<strong>区间更新</strong>操作都降为 <strong><span class="math inline"><em>O</em>(1)</span></strong> 时间。 -
效果：之后可以通过<strong>一次前缀和计算</strong>，得到<strong>最终的数组状态</strong>。</p>
<p>给你一个数组 nums，我们定义它的差分数组 diff 如下： - diff[0] =
nums[0] - diff[i] = nums[i] - nums[i-1] (对于 <span class="math inline"><em>i</em> &gt; 0</span>) - 惊人的特性：从 diff
数组还原 nums 数组，只需要对 diff 求前缀和即可。 - <span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.777ex;" xmlns="http://www.w3.org/2000/svg" width="23.469ex" height="2.914ex" role="img" focusable="false" viewbox="0 -944.5 10373.3 1287.8"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mi" transform="translate(600,0)"><path data-c="1D462" d="M21 287Q21 295 30 318T55 370T99 420T158 442Q204 442 227 417T250 358Q250 340 216 246T182 105Q182 62 196 45T238 27T291 44T328 78L339 95Q341 99 377 247Q407 367 413 387T427 416Q444 431 463 431Q480 431 488 421T496 402L420 84Q419 79 419 68Q419 43 426 35T447 26Q469 29 482 57T512 145Q514 153 532 153Q551 153 551 144Q550 139 549 130T540 98T523 55T498 17T462 -8Q454 -10 438 -10Q372 -10 347 46Q345 45 336 36T318 21T296 6T267 -6T233 -11Q189 -11 155 7Q103 38 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mi" transform="translate(1172,0)"><path data-c="1D45A" d="M21 287Q22 293 24 303T36 341T56 388T88 425T132 442T175 435T205 417T221 395T229 376L231 369Q231 367 232 367L243 378Q303 442 384 442Q401 442 415 440T441 433T460 423T475 411T485 398T493 385T497 373T500 364T502 357L510 367Q573 442 659 442Q713 442 746 415T780 336Q780 285 742 178T704 50Q705 36 709 31T724 26Q752 26 776 56T815 138Q818 149 821 151T837 153Q857 153 857 145Q857 144 853 130Q845 101 831 73T785 17T716 -10Q669 -10 648 17T627 73Q627 92 663 193T700 345Q700 404 656 404H651Q565 404 506 303L499 291L466 157Q433 26 428 16Q415 -11 385 -11Q372 -11 364 -4T353 8T350 18Q350 29 384 161L420 307Q423 322 423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 181Q151 335 151 342Q154 357 154 369Q154 405 129 405Q107 405 92 377T69 316T57 280Q55 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mi" transform="translate(2050,0)"><path data-c="1D460" d="M131 289Q131 321 147 354T203 415T300 442Q362 442 390 415T419 355Q419 323 402 308T364 292Q351 292 340 300T328 326Q328 342 337 354T354 372T367 378Q368 378 368 379Q368 382 361 388T336 399T297 405Q249 405 227 379T204 326Q204 301 223 291T278 274T330 259Q396 230 396 163Q396 135 385 107T352 51T289 7T195 -10Q118 -10 86 19T53 87Q53 126 74 143T118 160Q133 160 146 151T160 120Q160 94 142 76T111 58Q109 57 108 57T107 55Q108 52 115 47T146 34T201 27Q237 27 263 38T301 66T318 97T323 122Q323 150 302 164T254 181T195 196T148 231Q131 256 131 289Z"/></g><g data-mml-node="mo" transform="translate(2519,0)"><path data-c="5B" d="M118 -250V750H255V710H158V-210H255V-250H118Z"/></g><g data-mml-node="mi" transform="translate(2797,0)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(3142,0)"><path data-c="5D" d="M22 710V750H159V-250H22V-210H119V710H22Z"/></g><g data-mml-node="mo" transform="translate(3697.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/></g><g data-mml-node="munderover" transform="translate(4753.6,0)"><g data-mml-node="mo"><path data-c="2211" d="M61 748Q64 750 489 750H913L954 640Q965 609 976 579T993 533T999 516H979L959 517Q936 579 886 621T777 682Q724 700 655 705T436 710H319Q183 710 183 709Q186 706 348 484T511 259Q517 250 513 244L490 216Q466 188 420 134T330 27L149 -187Q149 -188 362 -188Q388 -188 436 -188T506 -189Q679 -189 778 -162T936 -43Q946 -27 959 6H999L913 -249L489 -250Q65 -250 62 -248Q56 -246 56 -239Q56 -234 118 -161Q186 -81 245 -11L428 206Q428 207 242 462L57 717L56 728Q56 744 61 748Z"/></g><g data-mml-node="TeXAtom" transform="translate(1089,477.1) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mi"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"/></g></g><g data-mml-node="TeXAtom" transform="translate(1089,-285.4) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mi"><path data-c="1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"/></g><g data-mml-node="mo" transform="translate(521,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/></g><g data-mml-node="mn" transform="translate(1299,0)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g></g><g data-mml-node="mi" transform="translate(7331.3,0)"><path data-c="1D451" d="M366 683Q367 683 438 688T511 694Q523 694 523 686Q523 679 450 384T375 83T374 68Q374 26 402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487H491Q506 153 506 145Q506 140 503 129Q490 79 473 48T445 8T417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157Q33 205 53 255T101 341Q148 398 195 420T280 442Q336 442 364 400Q369 394 369 396Q370 400 396 505T424 616Q424 629 417 632T378 637H357Q351 643 351 645T353 664Q358 683 366 683ZM352 326Q329 405 277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q233 26 290 98L298 109L352 326Z"/></g><g data-mml-node="mi" transform="translate(7851.3,0)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mi" transform="translate(8196.3,0)"><path data-c="1D453" d="M118 -162Q120 -162 124 -164T135 -167T147 -168Q160 -168 171 -155T187 -126Q197 -99 221 27T267 267T289 382V385H242Q195 385 192 387Q188 390 188 397L195 425Q197 430 203 430T250 431Q298 431 298 432Q298 434 307 482T319 540Q356 705 465 705Q502 703 526 683T550 630Q550 594 529 578T487 561Q443 561 443 603Q443 622 454 636T478 657L487 662Q471 668 457 668Q445 668 434 658T419 630Q412 601 403 552T387 469T380 433Q380 431 435 431Q480 431 487 430T498 424Q499 420 496 407T491 391Q489 386 482 386T428 385H372L349 263Q301 15 282 -47Q255 -132 212 -173Q175 -205 139 -205Q107 -205 81 -186T55 -132Q55 -95 76 -78T118 -61Q162 -61 162 -103Q162 -122 151 -136T127 -157L118 -162Z"/></g><g data-mml-node="mi" transform="translate(8746.3,0)"><path data-c="1D453" d="M118 -162Q120 -162 124 -164T135 -167T147 -168Q160 -168 171 -155T187 -126Q197 -99 221 27T267 267T289 382V385H242Q195 385 192 387Q188 390 188 397L195 425Q197 430 203 430T250 431Q298 431 298 432Q298 434 307 482T319 540Q356 705 465 705Q502 703 526 683T550 630Q550 594 529 578T487 561Q443 561 443 603Q443 622 454 636T478 657L487 662Q471 668 457 668Q445 668 434 658T419 630Q412 601 403 552T387 469T380 433Q380 431 435 431Q480 431 487 430T498 424Q499 420 496 407T491 391Q489 386 482 386T428 385H372L349 263Q301 15 282 -47Q255 -132 212 -173Q175 -205 139 -205Q107 -205 81 -186T55 -132Q55 -95 76 -78T118 -61Q162 -61 162 -103Q162 -122 151 -136T127 -157L118 -162Z"/></g><g data-mml-node="mo" transform="translate(9296.3,0)"><path data-c="5B" d="M118 -250V750H255V710H158V-210H255V-250H118Z"/></g><g data-mml-node="mi" transform="translate(9574.3,0)"><path data-c="1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"/></g><g data-mml-node="mo" transform="translate(10095.3,0)"><path data-c="5D" d="M22 710V750H159V-250H22V-210H119V710H22Z"/></g></g></g></svg></mjx-container></span></p>
<p>关键操作：如果我们要对 nums 的区间 [i,
j]（闭区间）上的<strong>所有元素都加上 val</strong>： - nums[i] 增加了
val，而 nums[i-1] 不变，所以 diff[i]（即 nums[i] - nums[i-1]）增加了
val。 - nums[i+1] 到 nums[j] 这一段，由于 nums[k] 和 nums[k-1] 都增加了
val，它们的差 diff[k] 不变 - nums[j] 增加了 val，而 nums[j+1] 不变，所以
diff[j+1]（即 nums[j+1] - nums[j]）减少了 val。</p>
<p>结论：一次 <span class="math inline"><em>O</em>(<em>n</em>)</span>
的<strong>区间更新</strong> [i, j] 被转化为了<strong>两次 <span class="math inline"><em>O</em>(1)</span> 的单点更新</strong>！ -
<code>diff[i] += val; if (j + 1 &lt; n) { diff[j + 1] -= val; }</code></p>
<p>例题: LC 1109. 航班预订统计. 有 n 个航班，编号从 1 到 n。有一个预订表
bookings，其中 bookings[i] = [first, last, seats] 表示从 first 到 last
的航班都预订了 seats 个座位。请返回一个长度为 n 的数组 answer，其中
answer[i] 是第 i 个航班的总预订座位数。</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">corpFlightBookings</span><span class="params">(std::vector&lt;std::vector&lt;<span class="type">int</span>&gt;&gt;&amp; bookings, <span class="type">int</span> n)</span> </span>{</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 步骤 1: 初始化差分数组</span></span><br><span class="line">    <span class="comment">// 我们使用 n 个元素，对应 0 到 n-1 下标</span></span><br><span class="line">    <span class="comment">// diff[i] 对应第 i+1 号航班</span></span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">diff</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 步骤 2: 处理所有更新 (O(1) / query)</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; booking : bookings) {</span><br><span class="line">        <span class="comment">// 题目编号从 1 开始，数组下标从 0 开始</span></span><br><span class="line">        <span class="type">int</span> first = booking[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> last = booking[<span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> seats = booking[<span class="number">2</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 转换为 0-based 下标</span></span><br><span class="line">        <span class="type">int</span> i = first - <span class="number">1</span>; </span><br><span class="line">        <span class="type">int</span> j = last - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 应用差分</span></span><br><span class="line">        <span class="comment">// 1. 在区间的起始点 i 加上 val</span></span><br><span class="line">        diff[i] += seats;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 在区间的结束点 j 的下一个位置 j+1 减去 val</span></span><br><span class="line">        <span class="comment">// 注意检查边界</span></span><br><span class="line">        <span class="keyword">if</span> (j + <span class="number">1</span> &lt; n) {</span><br><span class="line">            diff[j + <span class="number">1</span>] -= seats;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 步骤 3: 还原结果 (O(n))</span></span><br><span class="line">    <span class="comment">// 通过对差分数组求前缀和，来还原出最终的航班座位数</span></span><br><span class="line">    <span class="comment">// 还原后的数组可以直接用 diff 自身来存储</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i) {</span><br><span class="line">        <span class="comment">// 第 i 个航班的座位 = 第 i-1 个航班的座位 + 第 i 个航班的“变化量”</span></span><br><span class="line">        diff[i] += diff[i - <span class="number">1</span>];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 步骤 4: 返回</span></span><br><span class="line">    <span class="comment">// 此时 diff 数组已经变成了我们想要的 answer 数组</span></span><br><span class="line">    <span class="keyword">return</span> diff;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>
<p>常见题型包括: -
一维差分：用于高效处理区间更新、单点查询的问题，常与扫描线思想结合。 -
二维差分：用于处理子矩阵的批量更新。</p>
<h2 id="栈">栈</h2>
<p>栈是一种后进先出（LIFO）的数据结构，支持基本操作：入栈（<strong>push</strong>）、出栈（<strong>pop</strong>）和查看栈顶元素（<strong>top</strong>）。栈的应用场景包括表达式求值、括号匹配、深度优先搜索等。</p>
<h3 id="邻项消除-合法括号字符串">邻项消除 &amp; 合法括号字符串</h3>
<p>这两个是栈的最经典应用，因为它们的思想完全一致。</p>
<p>核心思想：</p>
<ul>
<li><strong>遍历</strong>你的输入（如一个字符串）。</li>
<li>使用一个<strong>栈</strong>来维护一个“<strong>尚未被消除/匹配</strong>”的元素序列。</li>
<li>当你遇到一个新元素 current 时，你去看它和“栈顶”元素
stack.top()（即最近一个尚未被消除的元素）是否能“配对”。
<ul>
<li>如果能配对：说明 current 和 stack.top() 互相消除了。你执行
stack.pop()，并且不将 current 入栈。</li>
<li>如果不能配对：说明 current 暂时无法被消除，你将它
stack.push()，等待它未来的“配对者”出现</li>
</ul></li>
<li>遍历结束后，栈内剩下的元素就是“无法被消除/匹配”的元素。
<ul>
<li>对于邻项消除问题，栈内剩下的元素就是最终结果。</li>
<li>对于括号匹配问题，栈内剩下的元素数量就是无法被匹配的括号数量。</li>
</ul></li>
</ul>
<h3 id="单调栈">单调栈</h3>
<p>单调栈是一种特殊的栈数据结构，它在入栈和出栈操作时保持栈内元素的<strong>单调性</strong>（从栈底到栈顶递增或递减）。其核心思想，是在
<strong><span class="math inline"><em>O</em>(<em>n</em>)</span>
的一次遍历中</strong>，为数组中的<strong>每一个元素</strong>，快速找到它<strong>左侧或右侧</strong>(取决于遍历方向)的<strong>第一个比它“大”（或“小”）的元素</strong>。</p>
<p>它是如何工作的？ 以“单调递增栈”（栈底到栈顶）为例，当一个新元素 x
准备入栈时：</p>
<ol type="1">
<li>比较：x 会和栈顶 st.top() 比较。</li>
<li>“清洗”：
<ul>
<li>如果 x &lt; st.top()，说明栈顶元素 st.top()
“没用了”。为什么？因为它比 x 大，而且比 x 旧（在 x
左侧）。如果将来有一个元素 y（在 x
右侧）在寻找它“左侧第一个更小的元素”，y 会先看到 x，而永远不会看到
st.top()。</li>
<li>因此，我们弹出 (pop) st.top()，然后 x 继续和新的栈顶比较。</li>
<li>这个过程会一直持续，直到 st.top() &lt;= x。</li>
</ul></li>
<li>入栈：x 入栈。</li>
</ol>
<p>通过这个“清洗”过程，栈内始终维护了一个单调递增的序列，这个序列里的元素都是“有潜力”的（它们都还在等待右侧第一个比自己小的元素）。</p>
<p>单调栈目前主要有四大应用场景:</p>
<h4 id="基础寻找下一个更大更小元素-ngense">1.
基础：寻找下一个更大/更小元素 (NGE/NSE)</h4>
<p>问题：为数组中每个 nums[i]，找到它右侧第一个比它大的元素
nums[j]（<span class="math inline"><em>j</em> &gt; <em>i</em>, <em>n</em><em>u</em><em>m</em><em>s</em>[<em>j</em>] &gt; <em>n</em><em>u</em><em>m</em><em>s</em>[<em>i</em>]</span>）。
解法：使用一个单调递减的栈（栈内存放下标）。 - 遍历数组 i 从左到右。 -
while (!st.empty() &amp;&amp; nums[i] &gt; nums[st.top()])： -
这说明，nums[i] 是 st.top()
所代表的那个元素的<strong>“右侧第一个更大元素”</strong>。 -
找到了！ans[st.top()] = nums[i] (或 j - i，根据题目要求)。 - st.pop()。
- st.push(i)：nums[i] 入栈，等待它“右侧第一个更大元素”的出现。</p>
<p>例如每日温度: 给定一个整数数组 temperatures
，表示每天的温度，返回一个数组 answer ，其中 answer[i] 是指对于第 i
天，下一个更高温度出现在几天后。如果不存在更高温度，答案为 0 。(LC
739)</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dailyTemperatures</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; temperatures)</span> </span>{</span><br><span class="line">        <span class="type">int</span> n = temperatures.<span class="built_in">size</span>();</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; indexes;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ans</span><span class="params">(n,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">            <span class="type">int</span> cur = temperatures[i];</span><br><span class="line">            <span class="keyword">while</span>(!indexes.<span class="built_in">empty</span>()&amp;&amp; temperatures[indexes.<span class="built_in">top</span>()]&lt;cur){</span><br><span class="line">                <span class="type">int</span> index = indexes.<span class="built_in">top</span>();</span><br><span class="line">                ans[index] = i-index;</span><br><span class="line">                indexes.<span class="built_in">pop</span>();</span><br><span class="line">            }</span><br><span class="line">            indexes.<span class="built_in">push</span>(i);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></table></figure></div>
<h4 id="进阶柱状图中的最大矩形面积">2. 进阶：柱状图中的最大矩形面积</h4>
<p>这是单调栈最经典的应用。问题描述: 给定 n
个非负整数表示每个柱子的高度图，宽度均为
1，计算在该柱状图中，能够勾勒出来的矩形的最大面积(LC 84)。</p>
<p>解法：</p>
<ul>
<li>遍历每一个柱子 h[i]，并假设它就是矩形的最终高度。</li>
<li>我们需要找到这个矩形能向左和向右延伸的最大宽度。</li>
<li>向左：找到 h[i] <strong>左侧第一个小于</strong> h[i] 的柱子
h[l]。</li>
<li>向右：找到 h[i] <strong>右侧第一个小于</strong> h[i] 的柱子
h[r]。</li>
<li>这个 h[i] 的矩形面积就是 h[i] * (r - l - 1)。</li>
</ul>
<p>这就是“寻找下一个更小元素”(NSE)
问题。你可以通过两次遍历（一次找左侧，一次找右侧）来解决。
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">largestRectangleArea</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; heights)</span> </span>{</span><br><span class="line">        <span class="type">int</span> n = heights.<span class="built_in">size</span>();</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; left_s;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">left_vec</span><span class="params">(n,<span class="number">-1</span>)</span></span>;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; right_s;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">right_vec</span><span class="params">(n,n)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> max_aera = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">            <span class="type">int</span> cur = heights[i];</span><br><span class="line">            <span class="keyword">while</span>(!right_s.<span class="built_in">empty</span>()&amp;&amp; cur&lt;heights[right_s.<span class="built_in">top</span>()]){</span><br><span class="line">                right_vec[right_s.<span class="built_in">top</span>()] = i;</span><br><span class="line">                right_s.<span class="built_in">pop</span>();</span><br><span class="line">            }</span><br><span class="line">            right_s.<span class="built_in">push</span>(i);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--){</span><br><span class="line">            <span class="type">int</span> cur = heights[i];</span><br><span class="line">            <span class="keyword">while</span>(!left_s.<span class="built_in">empty</span>()&amp;&amp; cur&lt;heights[left_s.<span class="built_in">top</span>()]){</span><br><span class="line">                left_vec[left_s.<span class="built_in">top</span>()] = i;</span><br><span class="line">                left_s.<span class="built_in">pop</span>();</span><br><span class="line">            }</span><br><span class="line">            left_s.<span class="built_in">push</span>(i);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">                <span class="type">int</span> cur_aera = heights[i]*(right_vec[i]-left_vec[i]<span class="number">-1</span>);</span><br><span class="line">                max_aera = <span class="built_in">max</span>(max_aera, cur_aera);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> max_aera;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></table></figure></div></p>
<h4 id="贡献法子数组的最小值之和">贡献法：子数组的最小值之和</h4>
<p>这是单调栈最精妙的应用。问题描述: 给定一个整数数组 nums
，返回所有非空子数组的最小值之和。(由于答案可能很大，因此返回答案对 10^9
+ 7 取余后的结果)(LC 907)</p>
<p>核心思想（贡献法）：我们不遍历子数组，我们<strong>遍历每一个元素
nums[i]</strong>。 - 我们问：nums[i]
作为最小值，在多少个子数组中出现过？ - 同样，我们需要找到 nums[i]
的左侧第一个更小元素 (下标 l) 和右侧第一个更小元素 (下标 r)。 - 这说明
nums[i] 是<strong>开区间 (l, r) 内的唯一最小值</strong>。任何一个起点在
<code>(l, i]</code> 之间（共 <strong>i - l</strong> 种选择）且终点在
<code>[i, r)</code> 之间（共 <strong>r - i</strong>
种选择）组成的子数组，其最小值都是 nums[i]。 - nums[i] 的总贡献 =
nums[i] * (i - l) * (r - i)。 - 用单调栈求出所有 l 和 r，然后 <span class="math inline"><em>O</em>(<em>n</em>)</span> 累加总贡献。
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">sumSubarrayMins</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr)</span> </span>{</span><br><span class="line">        <span class="type">int</span> n = arr.<span class="built_in">size</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 1. 计算左边界 left[i]</span></span><br><span class="line">        <span class="comment">// left[i] = l, 其中 l 是 arr[i] 左侧第一个“严格小于” arr[i] 的元素下标</span></span><br><span class="line">        <span class="comment">// 我们使用一个单调递增栈</span></span><br><span class="line">        <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">left</span><span class="params">(n)</span></span>;</span><br><span class="line">        std::stack&lt;<span class="type">int</span>&gt; st_left;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) {</span><br><span class="line">            <span class="comment">// 解释: 栈顶元素如果 &gt;= 当前元素，说明它不是 arr[i] 的左边界</span></span><br><span class="line">            <span class="comment">// (我们在找严格小于的)</span></span><br><span class="line">            <span class="comment">// 并且它也不是它右侧任何元素的左边界了，弹出</span></span><br><span class="line">            <span class="keyword">while</span> (!st_left.<span class="built_in">empty</span>() &amp;&amp; arr[st_left.<span class="built_in">top</span>()] &gt;= arr[i]) {</span><br><span class="line">                st_left.<span class="built_in">pop</span>();</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// 解释: 栈为空，说明左侧没有更小元素；否则，栈顶就是左边界</span></span><br><span class="line">            left[i] = st_left.<span class="built_in">empty</span>() ? <span class="number">-1</span> : st_left.<span class="built_in">top</span>();</span><br><span class="line">            st_left.<span class="built_in">push</span>(i);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 计算右边界 right[i]</span></span><br><span class="line">        <span class="comment">// right[i] = r, 其中 r 是 arr[i] 右侧第一个“小于或等于” arr[i] 的元素下标</span></span><br><span class="line">        <span class="comment">// 我们也使用一个单调递增栈 (但从右往左遍历)</span></span><br><span class="line">        <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">right</span><span class="params">(n)</span></span>;</span><br><span class="line">        std::stack&lt;<span class="type">int</span>&gt; st_right;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) {</span><br><span class="line">            <span class="comment">// 解释: 栈顶元素如果 &gt; 当前元素，说明它不是 arr[i] 的右边界</span></span><br><span class="line">            <span class="comment">// (我们在找小于或等于的)</span></span><br><span class="line">            <span class="keyword">while</span> (!st_right.<span class="built_in">empty</span>() &amp;&amp; arr[st_right.<span class="built_in">top</span>()] &gt; arr[i]) {   <span class="comment">// 注意这里是严格大于, 因为要避免两个栈都是大于等于导致重复计算</span></span><br><span class="line">                st_right.<span class="built_in">pop</span>();</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// 解释: 栈为空，说明右侧没有更小或相等元素；否则，栈顶就是右边界</span></span><br><span class="line">            right[i] = st_right.<span class="built_in">empty</span>() ? n : st_right.<span class="built_in">top</span>();</span><br><span class="line">            st_right.<span class="built_in">push</span>(i);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 累加贡献</span></span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> total_sum = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> MOD = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) {</span><br><span class="line">            <span class="comment">// 解释: l = left[i], r = right[i]</span></span><br><span class="line">            <span class="comment">// 左侧的起点选择数: i - l</span></span><br><span class="line">            <span class="comment">// (j 可以在 (l, i] 范围内, 即 l+1, l+2, ..., i)</span></span><br><span class="line">            <span class="type">long</span> <span class="type">long</span> left_span = i - left[i];</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 解释: 右侧的终点选择数: r - i</span></span><br><span class="line">            <span class="comment">// (k 可以在 [i, r) 范围内, 即 i, i+1, ..., r-1)</span></span><br><span class="line">            <span class="type">long</span> <span class="type">long</span> right_span = right[i] - i;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 贡献 = arr[i] * (左侧选择数) * (右侧选择数)</span></span><br><span class="line">            <span class="type">long</span> <span class="type">long</span> contribution = (arr[i] * left_span * right_span);</span><br><span class="line">            </span><br><span class="line">            total_sum = (total_sum + contribution) % MOD;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (<span class="type">int</span>)total_sum;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></table></figure></div></p>
<h4 id="最小字典序移掉-k-位数字">最小字典序：移掉 K 位数字</h4>
<p>这是单调栈结合贪心思想的应用。问题描述:
给你一个以字符串表示的非负整数 num ，移除这个数中的 k
位数字，使得剩下的数字最小。返回移除 k
位数字后得到的最小整数，以字符串形式表示。(LC 402)</p>
<p>核心思想：</p>
<ul>
<li>为了让数字尽可能小，我们希望高位（左侧）的数字尽可能小。
<ul>
<li>因为高位数字权重更大，假如有两个数字 a 和 b，如果 a &lt; b，那么把 a
放在高位比把 b 放在高位更能减小整体数值。</li>
</ul></li>
<li>我们使用一个单调递增的栈来维护我们“<strong>保留”的数字</strong>。</li>
<li>遍历数字字符串，for (char c : num)：
<ul>
<li>while (!st.empty() &amp;&amp; k &gt; 0 &amp;&amp; c &lt; st.top())：
<ul>
<li>解释：新来的 c
比栈顶元素（已保留的数字）更小，并且我们还有删除的名额 (k &gt; 0)。</li>
<li>贪心：我们应该“扔掉”栈顶那个更大的数字，换成 c。</li>
<li>st.pop(); k–;</li>
</ul></li>
<li>st.push(c);</li>
</ul></li>
<li>最终，栈中就保留了最小的序列。</li>
</ul>
<h2 id="队列">队列</h2>
<p>队列是一种先进先出（FIFO）的数据结构，支持基本操作：入队（<strong>enqueue</strong>）、出队（<strong>dequeue</strong>）和查看队首元素（<strong>front</strong>）。队列的应用场景包括广度优先搜索、任务调度等。</p>
<p>我们可以使用容器适配器 <code>std::queue</code> 来实现队列, 也可以使用
<code>std::deque</code> 来实现双端队列。</p>
<p>对于 <code>queue</code>, 主要用到的接口有: push(), pop(), front(),
back(), empty(), size(). 并且需要注意的是, queue 没有迭代器,
不能使用范围for循环来遍历queue中的元素, 只能通过不断 pop
出队列的方式来访问每个元素.</p>
<p>而对于 <code>deque</code>,
由于它是双端队列，可以分别操作两端，因此在入队和出队时要加以说明,
主要用到的接口有: push_back(), push_front(), pop_back(), pop_front(),
front(), back(), empty(), size().</p>
<h3 id="单调队列">单调队列</h3>
<p>单调队列是一种特殊的队列数据结构，它在入队和出队操作时保持队列内元素的<strong>单调性</strong>（从队头到队尾递增或递减）。其核心思想，是在
<strong><span class="math inline"><em>O</em>(<em>n</em>)</span>
的一次遍历中</strong>，为数组中的<strong>每一个元素</strong>，快速找到它<strong>左侧或右侧</strong>(取决于遍历方向)的<strong>第一个比它“大”（或“小”）的元素</strong>。</p>
<p>单调队列的应用场景包括滑动窗口问题、最大值/最小值查询等。</p>
<h2 id="堆">堆</h2>
<p>当你需要在一个<strong>动态的集合中</strong>（元素不断在增加或减少）快速地查找并（或）移除“<strong>最值</strong>”（最大值或最小值）时，堆就是你的不二之选。</p>
<h3 id="top-k-问题-第-k-小大">Top-K 问题 / 第 K 小/大</h3>
<p>这是堆最基础、最直接的应用。核心思想是：维护一个<strong>大小固定为
K</strong> 的堆。这个堆里存储了你到目前为止见过的 “Top K” 个元素。</p>
<p>问题模型： - 静态数组：在 <span class="math inline"><em>N</em></span>
个元素中找到第 <span class="math inline"><em>K</em></span> 大的元素 (LC
215)。 - 数据流：在不断加入的数据流中，始终保持对第 <span class="math inline"><em>K</em></span> 大元素的快速访问 (LC 703)。</p>
<p>解题思路 (以“<strong>第 K
大</strong>”为例)：你需要一个<strong>最小堆</strong>（Min-Heap）。为什么？
最小堆的堆顶 <code>min_pq.top()</code>
永远是堆中最小的元素。如果我们的堆里有 <span class="math inline"><em>K</em></span> 个元素，那么堆顶就是<strong>这
<span class="math inline"><em>K</em></span> 个元素中的第 <span class="math inline"><em>K</em></span> 大</strong>的那个。 -
初始化：创建一个大小为 <span class="math inline"><em>K</em></span>
的最小堆 min_pq。 - 遍历数据：for (int num : nums) -
入堆：min_pq.push(num); - 维护大小：if (min_pq.size() &gt;
k)：min_pq.pop(); - (将堆中最小的元素——即“第 K+1 大”的元素——扔掉) -
获取答案：当所有数据都处理完毕后，堆中剩下的 <span class="math inline"><em>K</em></span> 个元素就是最大的 <span class="math inline"><em>K</em></span> 个，而 min_pq.top()
就是我们想要的第 K 大元素。</p>
<h3 id="对顶堆动态中位数">对顶堆（动态中位数）</h3>
<p>一个极其精妙的技巧,
使用<strong>两个堆</strong>来将一个<strong>动态数据流</strong>“从<strong>中间劈开</strong>”，从而
<span class="math inline"><em>O</em>(1)</span> 访问中位数。</p>
<p>数据结构配置： - small
(最大堆)：存储数据流中较小的一半元素。small.top() 是“小半”中的最大值。 -
large (最小堆)：存储数据流中较大的一半元素。large.top()
是“大半”中的最小值。</p>
<p>核心规则（不变式）： - small.size() 永远等于
large.size()（当总数为偶） - 或 small.size() 等于 large.size() +
1（当总数为奇）中位数：如果总数为奇，</p>
<p>中位数就是 small.top()。如果总数为偶，中位数就是 (small.top() +
large.top()) / 2。</p>
<h3 id="重排元素贪心">重排元素（贪心）</h3>
<h3 id="反悔堆反悔贪心">反悔堆（反悔贪心）</h3>
<h2 id="链表">链表</h2>
<p>链表是一种线性数据结构，由一系列节点组成，每个节点包含<strong>数据</strong>和<strong>指向下一个节点的指针</strong>。链表的主要类型包括单向链表、双向链表和循环链表。链表适合频繁的插入和删除操作，因为这些操作不需要移动其他元素。</p>
<h3 id="两个黄金问题">两个黄金问题</h3>
<p>对于链表, 有两个黄金问题, 贯穿了绝大多数链表题目的解法思路.</p>
<p><strong>什么时候用哨兵节点 (Dummy Node)？</strong></p>
<ul>
<li>答案：任何时候可能会<strong>修改</strong>（删除或插入）<strong>链表的头节点</strong>
(head)时，都应该使用哨兵节点。</li>
<li>为什么？
<ul>
<li>统一逻辑：常规操作中，删除一个节点 curr
需要操作它的<strong>前一个节点</strong> prev（即 prev-&gt;next =
curr-&gt;next）。</li>
<li>痛点：但如果你要删除的是头节点 head 呢？head 没有 prev！</li>
<li>常规解法：你需要写一个 if (curr == head)
的<strong>特殊判断</strong>，这非常繁琐且容易出错。</li>
<li>哨兵解法：创建一个<code>ListNode* dummy = new ListNode(0);</code>，并让
<code>dummy-&gt;next = head;</code>
<ul>
<li>现在，原 head 节点也有了一个“前驱”节点 dummy。</li>
<li>你所有的操作都可以从 dummy 节点开始，如果要删除 prev-&gt;next
所指向的元素, 所有的<strong>删除</strong>逻辑都统一成了
<strong>prev-&gt;next = prev-&gt;next-&gt;next</strong>。</li>
<li>最后返回：dummy-&gt;next（这可能是原来的 head，也可能是新的
head）。</li>
</ul></li>
</ul></li>
<li>典型案例：
<ul>
<li>删除节点 (如 203. 移除链表元素, 82. 删除排序链表中的重复元素
II)</li>
<li>合并链表 (如 21. 合并两个有序链表) - dummy
用来作为新链表的“假头”。</li>
</ul></li>
</ul>
<p><strong>while (node != nullptr) vs while (node-&gt;next !=
nullptr)？</strong></p>
<ul>
<li>这是一个关于<strong>循环终止条件</strong>的精髓问题，决定了你的指针最后“停在”哪里。</li>
<li>while (node != nullptr)
<ul>
<li>含义：我会处理 node，直到 node 变为 nullptr 为止。</li>
<li>循环体：在循环内部，node 是 你要处理的当前节点。</li>
<li>终止时：node 的值<strong>是</strong>
nullptr。你已经走过了（处理过了）最后一个节点。</li>
<li>用途：
<ul>
<li>遍历并访问<strong>所有</strong>节点的值（例如：打印链表、二进制求和）。</li>
<li>反转链表（你需要处理最后一个节点）。</li>
<li>示例：while (curr != nullptr) { … curr = curr-&gt;next; }</li>
</ul></li>
</ul></li>
<li>while (node-&gt;next != nullptr)
<ul>
<li>含义：我会<strong>检查</strong> node
的<strong>下一个</strong>节点，直到 node 的下一个<strong>是</strong>
nullptr 为止。</li>
<li>循环体：在循环内部，node 是
你要处理的当前节点的<strong>前一个节点</strong>, 而 node-&gt;next 是
你要处理的当前节点。</li>
<li>终止时：node 的值<strong>是</strong> 链表的最后一个节点
(node-&gt;next 是 nullptr)。</li>
<li>用途：
<ul>
<li>删除节点（你需要访问被删除节点的前一个节点）。</li>
<li>寻找链表的尾节点（例如：在尾部添加新节点）。</li>
<li>快慢指针中 fast 指针的检查（while (fast != nullptr &amp;&amp;
fast-&gt;next != nullptr)，因为你要访问 fast-&gt;next-&gt;next）。</li>
<li>当你的操作涉及 node 和 node-&gt;next 两个节点时（例如：83.
删除排序链表中的重复元素）。</li>
</ul></li>
</ul></li>
</ul>
<p>例如, 给你一个链表的头节点 head 和一个整数 val
，请你删除链表中所有满足 Node.val == val 的节点，并返回 新的头节点 。(LC
203)</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">removeElements</span><span class="params">(ListNode* head, <span class="type">int</span> val)</span> </span>{</span><br><span class="line">    ListNode* dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">    dummy-&gt;next = head;   <span class="comment">// 考虑到删除头节点的情况, 使用哨兵节点</span></span><br><span class="line"></span><br><span class="line">    ListNode* prev = dummy;  <span class="comment">// 因为删除节点需要访问前一个节点, 因此使用 while(prev-&gt;next!=nullptr)</span></span><br><span class="line">    <span class="keyword">while</span>(prev-&gt;next!=<span class="literal">nullptr</span>){  <span class="comment">// 实际上是遍历 prev-&gt;next 节点</span></span><br><span class="line">        <span class="keyword">if</span>(val==prev-&gt;next-&gt;val){</span><br><span class="line">            prev-&gt;next = prev-&gt;next-&gt;next;  <span class="comment">// 注意如果删除后, prev 不变, 继续检查新的 prev-&gt;next. 否则会跳过新的 prev-&gt;next 节点</span></span><br><span class="line">        }<span class="keyword">else</span>{</span><br><span class="line">            prev = prev-&gt;next;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>
<h3 id="遍历链表">遍历链表</h3>
<p>给你两个链表 list1 和 list2 , 请你将 list1 中下标从 a 到 b
的全部节点都删除，并将list2 接在被删除节点的位置。(LC 1669)</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">mergeInBetween</span><span class="params">(ListNode* list1, <span class="type">int</span> a, <span class="type">int</span> b, ListNode* list2)</span> </span>{</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 步骤 1：找到 list2 的尾节点 (tail2)</span></span><br><span class="line">    <span class="comment">// 应用「while (node-&gt;next != nullptr)」原则</span></span><br><span class="line">    <span class="comment">// 目标：循环结束后，tail2 停在 list2 的最后一个节点上。</span></span><br><span class="line">    ListNode* tail2 = list2;</span><br><span class="line">    <span class="keyword">while</span> (tail2-&gt;next != <span class="literal">nullptr</span>) {</span><br><span class="line">        tail2 = tail2-&gt;next;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 步骤 2：找到 list1 中第 a-1 个节点 (node_a_prev)</span></span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    <span class="comment">// 我们需要一个指针从 head (索引 0) 开始，走 a-1 步。</span></span><br><span class="line">    <span class="comment">// for 循环是执行“固定步数”的最清晰的工具。</span></span><br><span class="line">    ListNode* node_a_prev = list1;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; a - <span class="number">1</span>; ++i) {</span><br><span class="line">        <span class="comment">// i=0 时, cur 移动到索引 1</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="comment">// i=a-2 时, cur 移动到索引 a-1</span></span><br><span class="line">        node_a_prev = node_a_prev-&gt;next;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 步骤 3：找到 list1 中第 b+1 个节点 (node_b_next)</span></span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    <span class="comment">// 我们可以从 node_a_prev (索引 a-1) 继续出发。</span></span><br><span class="line">    <span class="comment">// 我们需要找到 b+1。</span></span><br><span class="line">    <span class="comment">// b+1 与 a-1 之间的步数差是：(b+1) - (a-1) = b - a + 2</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 我们让 node_b_next 从 node_a_prev 开始，</span></span><br><span class="line">    <span class="comment">// 再走 (b - a + 2) 步，它就会停在 b+1 节点上。</span></span><br><span class="line">    ListNode* node_b_next = node_a_prev;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; (b - a + <span class="number">2</span>); ++i) {</span><br><span class="line">        <span class="comment">// i=0 时, cur 移动到索引 a</span></span><br><span class="line">        <span class="comment">// i=1 时, cur 移动到索引 a+1</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="comment">// i=(b-a+1) 时, cur 移动到索引 b+1 (总共 b-a+2 步)</span></span><br><span class="line">        node_b_next = node_b_next-&gt;next;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 步骤 4：执行“链表手术”</span></span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    <span class="comment">// 此时我们手上有三个关键节点：</span></span><br><span class="line">    <span class="comment">// 1. node_a_prev: list1 的第 a-1 个节点</span></span><br><span class="line">    <span class="comment">// 2. node_b_next: list1 的第 b+1 个节点</span></span><br><span class="line">    <span class="comment">// 3. tail2:       list2 的最后一个节点</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 我们只需要执行两次链接：</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 1. 将 (a-1) 节点的 next 指向 list2 的头部</span></span><br><span class="line">    node_a_prev-&gt;next = list2;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 将 list2 的尾部 (tail2) 的 next 指向 (b+1) 节点</span></span><br><span class="line">    tail2-&gt;next = node_b_next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// (可选：在非 LeetCode 环境下，这里应该释放 [a, b] 之间的节点)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 步骤 5：返回 list1</span></span><br><span class="line">    <span class="comment">// 因为头节点 (list1) 始终未变</span></span><br><span class="line">    <span class="keyword">return</span> list1;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>
<h3 id="反转链表">反转链表</h3>
<p>这是链表操作的“Hello World”，是所有复杂操作（如 K
个一组反转）的基础。你必须能徒手、快速、无误地写出它。</p>
<p>核心思想：你需要<strong>三个指针</strong>在遍历过程中协同工作。 -
ListNode* prev：指向已反转部分的头，初始为 nullptr。 - ListNode*
curr：指向<strong>正在处理</strong>的当前节点，初始为 head。 - ListNode*
next_temp：<strong>临时保存</strong> curr
的下一个节点，防止链表“断开”后丢失。</p>
<p>“穿针引线”四步法（循环体内）： - next_temp = curr-&gt;next; // 1.
暂存：保存好“下一个” - curr-&gt;next = prev; // 2.
反转：当前节点指向“前一个” - prev = curr; // 3. 步进：prev 移动到“当前”
- curr = next_temp; // 4. 步进：curr 移动到“下一个”</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>{</span><br><span class="line">    <span class="comment">// 步骤 1: 初始化三个指针</span></span><br><span class="line">    ListNode* prev = <span class="literal">nullptr</span>;</span><br><span class="line">    ListNode* curr = head;</span><br><span class="line">    ListNode* next_temp = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 步骤 2: 循环遍历</span></span><br><span class="line">    <span class="comment">// 使用 while (curr != nullptr) 因为我们要处理到最后一个节点</span></span><br><span class="line">    <span class="keyword">while</span> (curr != <span class="literal">nullptr</span>) {</span><br><span class="line">        <span class="comment">// 步骤 3: 穿针引线四步法</span></span><br><span class="line">        next_temp = curr-&gt;next; <span class="comment">// 1. 暂存</span></span><br><span class="line">        curr-&gt;next = prev;      <span class="comment">// 2. 反转</span></span><br><span class="line">        prev = curr;            <span class="comment">// 3. 步进 prev</span></span><br><span class="line">        curr = next_temp;       <span class="comment">// 4. 步进 curr</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 步骤 4: 返回</span></span><br><span class="line">    <span class="comment">// 循环结束时，curr 是 nullptr, prev 正好是原链表的尾，</span></span><br><span class="line">    <span class="comment">// 即新链表的头</span></span><br><span class="line">    <span class="keyword">return</span> prev;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>
<p>LC 25: K 个一组反转链表. 给你一个链表，每 k
个节点一组进行翻转，请你返回翻转后的链表。</p>
<p>一个比较容易理解的解法是: 先反转每一组节点,
然后再把这些反转后的节点组连接起来. <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head, ListNode* tail)</span> </span>{</span><br><span class="line">    ListNode* prev = tail-&gt;next;  <span class="comment">// 反转后 tail 的下一个节点, 用于保持链表的连通性</span></span><br><span class="line">    ListNode* curr = head;</span><br><span class="line">    ListNode* next_temp = <span class="literal">nullptr</span>;</span><br><span class="line">    ListNode* tail_next = tail-&gt;next; <span class="comment">// 额外保存循环停止条件, 因为 tail 可能会变化</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (curr != tail_next) {</span><br><span class="line">        next_temp = curr-&gt;next;</span><br><span class="line">        curr-&gt;next = prev;</span><br><span class="line">        prev = curr;</span><br><span class="line">        curr = next_temp;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> prev;  <span class="comment">// 返回反转后的头节点</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">ListNode* <span class="title">reverseKGroup</span><span class="params">(ListNode* head, <span class="type">int</span> k)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span>(k &lt;= <span class="number">1</span> || !head) <span class="keyword">return</span> head;  <span class="comment">// 如果 k &lt;= 1 或链表为空, 不需要反转</span></span><br><span class="line">    ListNode* dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>, head);  <span class="comment">// 使用哨兵节点简化边界情况, 作为新链表的头节点</span></span><br><span class="line"></span><br><span class="line">    vector&lt;ListNode*&gt; Head; <span class="comment">// 存储每组的起始节点</span></span><br><span class="line">    vector&lt;ListNode*&gt; Tail; <span class="comment">// 存储每组的结束节点</span></span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;  <span class="comment">// 计数节点</span></span><br><span class="line">    ListNode* curr = head;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (curr != <span class="literal">nullptr</span>) {   <span class="comment">// 循环中处理的是 curr 节点</span></span><br><span class="line">        cnt++;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (cnt % k == <span class="number">1</span>) {         <span class="comment">// 这里如果k==1会导致无法记录节点, 因此在函数开头处理k&lt;=1的情况</span></span><br><span class="line">                                    <span class="comment">// 或者采取(cnt - 1) % k == 0 也可以处理</span></span><br><span class="line">            Head.<span class="built_in">push_back</span>(curr);  <span class="comment">// 记录每组的起始节点</span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (cnt % k == <span class="number">0</span>) {</span><br><span class="line">            Tail.<span class="built_in">push_back</span>(curr);  <span class="comment">// 记录每组的结束节点</span></span><br><span class="line">        }</span><br><span class="line">        curr = curr-&gt;next;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> full_groups = cnt / k;  <span class="comment">// 计算完整的 k 组数量</span></span><br><span class="line">    ListNode* prevTail = dummy;  <span class="comment">// 上一组的尾节点, 初始为哨兵节点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; full_groups; i++) {</span><br><span class="line">        ListNode* currHead = Head[i];</span><br><span class="line">        ListNode* currTail = Tail[i];</span><br><span class="line">        ListNode* newHead = <span class="built_in">reverseList</span>(currHead, currTail); <span class="comment">// 反转当前组</span></span><br><span class="line">        <span class="comment">// 这里 reverseList 函数会返回反转后的头节点(即之前的尾节点), 同时会将反转后的尾节点指向下一组的头节点, 从而保持链表的连通性</span></span><br><span class="line"></span><br><span class="line">        prevTail-&gt;next = newHead;  <span class="comment">// 连接上一组和当前组, 这是核心步骤, 将上一组的尾节点指向当前组反转后的头节点</span></span><br><span class="line">        prevTail = currHead;       <span class="comment">// 更新 prevTail 为当前组的尾节点</span></span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">    ListNode* newHead = dummy-&gt;next;;</span><br><span class="line">    <span class="keyword">delete</span> dummy;  <span class="comment">// 释放哨兵节点</span></span><br><span class="line">    <span class="keyword">return</span> newHead;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>
这个解法的时间复杂度是 O(N), 空间复杂度是 O(N/k) 用于存储每组的头尾节点.
如果想优化空间复杂度, 可以在遍历链表时, 每当遇到<strong>一组完整的 k
个节点</strong>时, <strong>立即反转</strong>该组节点,
并<strong>连接</strong>到结果链表中,
这样就不需要额外存储每组的头尾节点了, 从而将空间复杂度优化到 O(1).
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head, ListNode* tail)</span></span>{</span><br><span class="line">    ListNode* prev = tail-&gt;next;</span><br><span class="line">    ListNode* curr = head;</span><br><span class="line">    ListNode* next_temp = <span class="literal">nullptr</span>;</span><br><span class="line">    ListNode* tail_next = tail-&gt;next; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(curr != tail_next){</span><br><span class="line">        next_temp = curr-&gt;next;</span><br><span class="line">        curr-&gt;next = prev;</span><br><span class="line">        prev = curr;</span><br><span class="line">        curr = next_temp;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> prev;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">ListNode* <span class="title">reverseKGroup</span><span class="params">(ListNode* head, <span class="type">int</span> k)</span> </span>{</span><br><span class="line">    <span class="comment">// 使用一个哨兵节点</span></span><br><span class="line">    ListNode* dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>, head);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// prevGroupTail 指向上一组的尾部, 初始时，它指向哨兵节点</span></span><br><span class="line">    ListNode* prevGroupTail = dummy;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// currGroupHead 指向当前组的头部</span></span><br><span class="line">    ListNode* currGroupHead = head;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (currGroupHead != <span class="literal">nullptr</span>) {</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 步骤 1：找到当前组的尾节点 (currGroupTail)</span></span><br><span class="line">        ListNode* currGroupTail = currGroupHead;</span><br><span class="line">        <span class="type">int</span> count = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 向前走 k-1 步</span></span><br><span class="line">        <span class="keyword">while</span> (count &lt; k &amp;&amp; currGroupTail != <span class="literal">nullptr</span>) {</span><br><span class="line">            currGroupTail = currGroupTail-&gt;next;</span><br><span class="line">            count++;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 步骤 2：检查是否凑足了 k 个</span></span><br><span class="line">        <span class="comment">// 如果 currGroupTail 是 nullptr，说明剩余节点不足 k 个</span></span><br><span class="line">        <span class="keyword">if</span> (currGroupTail == <span class="literal">nullptr</span>) {</span><br><span class="line">            <span class="keyword">break</span>; <span class="comment">// 循环终止，剩余部分保持原样</span></span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 步骤 3：保存下一组的头节点，以便后续连接</span></span><br><span class="line">        ListNode* nextGroupHead = currGroupTail-&gt;next;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 步骤 4：翻转当前组 [currGroupHead, currGroupTail]</span></span><br><span class="line">        <span class="comment">// 你的 reverseList 函数会返回翻转后的新头 (即 currGroupTail)</span></span><br><span class="line">        <span class="comment">// 并且自动将翻转后的新尾 (即 currGroupHead) 指向 nextGroupHead</span></span><br><span class="line">        ListNode* newHead = <span class="built_in">reverseList</span>(currGroupHead, currGroupTail);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 步骤 5：将上一组的尾部连接到当前组的新头部</span></span><br><span class="line">        prevGroupTail-&gt;next = newHead; <span class="comment">// 或者写 prevGroupTail-&gt;next = currGroupTail;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 步骤 6：推进指针，为下一次循环做准备</span></span><br><span class="line">        <span class="comment">// 翻转后，currGroupHead 变成了当前组的尾巴</span></span><br><span class="line">        prevGroupTail = currGroupHead; </span><br><span class="line">        <span class="comment">// 移动到下一组的头部</span></span><br><span class="line">        currGroupHead = nextGroupHead;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放哨兵节点并返回</span></span><br><span class="line">    ListNode* newHead = dummy-&gt;next;</span><br><span class="line">    <span class="keyword">delete</span> dummy;</span><br><span class="line">    <span class="keyword">return</span> newHead;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div> ### 快慢指针及前后指针</p>
<p>快慢指针是一种常用的链表技巧，使用两个指针以不同速度遍历链表，从而解决诸如<strong>寻找中间节点</strong>、<strong>检测环</strong>、<strong>寻找环的入口</strong>等问题。
- ListNode* slow：每次走 1 步。 - ListNode* fast：每次走 2 步 (fast =
fast-&gt;next-&gt;next)。</p>
<p>循环条件：while (fast != nullptr &amp;&amp; fast-&gt;next != nullptr)
- （必须同时检查两者，使得fast和它的下一个节点都非空, 因为你要访问
fast-&gt;next-&gt;next）</p>
<p><strong>找中点</strong> (876. 链表的中间结点)： - 当 fast
走到终点（nullptr）时，slow 恰好在中点。 - （如果偶数个节点，slow
在后一个中点，符合题目要求）。</p>
<p><strong>判环</strong> (141. 环形链表)： - fast 走得快，slow 走得慢。
- 如果链表有环，fast 迟早会从“后面”追上 slow（fast == slow）。</p>
<p><strong>倒数第 N 个</strong> (19. 删除链表的倒数第 N 个结点)： -
这是“快慢”的变体，也叫<strong>前后指针</strong>。 - <strong>fast 先走 N
步</strong>。 - 然后 slow 和 fast <strong>一起走</strong>（每次各走 1
步）。 - 当 fast 走到尾节点（fast-&gt;next == nullptr）时，slow
就停在倒数第 N+1 个节点上，即要删除节点的前驱。(这里配合 dummy
节点食用更佳)。 <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="type">int</span> n)</span> </span>{</span><br><span class="line">    ListNode* dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>, head); <span class="comment">// 使用哨兵节点简化边界情况</span></span><br><span class="line">    ListNode* fast = dummy;</span><br><span class="line">    ListNode* slow = dummy;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 让 fast 先走 n 步</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) {</span><br><span class="line">        fast = fast-&gt;next;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 然后 slow 和 fast 一起走，直到 fast 到达链表末尾</span></span><br><span class="line">    <span class="keyword">while</span> (fast-&gt;next != <span class="literal">nullptr</span>) {</span><br><span class="line">        fast = fast-&gt;next;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此时 slow 停在倒数第 n+1 个节点上，删除它的下一个节点</span></span><br><span class="line">    slow-&gt;next = slow-&gt;next-&gt;next;</span><br><span class="line">    <span class="comment">// 返回新的头节点</span></span><br><span class="line">    ListNode* newHead = dummy-&gt;next;</span><br><span class="line">    <span class="keyword">delete</span> dummy; <span class="comment">// 释放哨兵节点</span></span><br><span class="line">    <span class="keyword">return</span> newHead;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div></p>
<h3 id="lru">LRU</h3>
<p>LRU (Least Recently Used)
缓存是一种常用的缓存淘汰策略，用于在缓存容量有限时，移除最久未使用的数据。LRU
缓存通常使用<strong>哈希表</strong>和<strong>双向链表</strong>结合实现，以支持高效的插入、删除和访问操作。
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LRUCache</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">DListNode</span>{</span><br><span class="line">        <span class="type">int</span> key;</span><br><span class="line">        <span class="type">int</span> value;</span><br><span class="line">        DListNode* prev;</span><br><span class="line">        DListNode* next;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">DListNode</span>(<span class="type">int</span> k, <span class="type">int</span> v): <span class="built_in">key</span>(k), <span class="built_in">value</span>(v), <span class="built_in">prev</span>(<span class="literal">nullptr</span>), <span class="built_in">next</span>(<span class="literal">nullptr</span>){}</span><br><span class="line">    };</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> capacity;</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, DListNode*&gt; cache_map;</span><br><span class="line">    DListNode* head;</span><br><span class="line">    DListNode* tail;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">removeNode</span><span class="params">(DListNode* node)</span></span>{</span><br><span class="line">        node-&gt;next-&gt;prev = node-&gt;prev;</span><br><span class="line">        node-&gt;prev-&gt;next = node-&gt;next;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addNodeToHead</span><span class="params">(DListNode* node)</span></span>{</span><br><span class="line">        node-&gt;next = head-&gt;next;</span><br><span class="line">        head-&gt;next-&gt;prev = node;</span><br><span class="line">        head-&gt;next = node;</span><br><span class="line">        node-&gt;prev = head;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">moveToHead</span><span class="params">(DListNode* node)</span></span>{</span><br><span class="line">        <span class="built_in">removeNode</span>(node);</span><br><span class="line">        <span class="built_in">addNodeToHead</span>(node);</span><br><span class="line">    }</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">LRUCache</span>(<span class="type">int</span> capacity): <span class="built_in">capacity</span>(capacity) {</span><br><span class="line">        head = <span class="keyword">new</span> <span class="built_in">DListNode</span>(<span class="number">-1</span>,<span class="number">-1</span>);</span><br><span class="line">        tail = <span class="keyword">new</span> <span class="built_in">DListNode</span>(<span class="number">-1</span>,<span class="number">-1</span>);</span><br><span class="line">        head-&gt;next = tail;</span><br><span class="line">        tail-&gt;prev = head;</span><br><span class="line">    }</span><br><span class="line">    ~<span class="built_in">LRUCache</span>(){</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; pair:cache_map){</span><br><span class="line">            <span class="keyword">delete</span> pair.second;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">delete</span> head;</span><br><span class="line">        <span class="keyword">delete</span> tail;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> key)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(!cache_map.<span class="built_in">contains</span>(key)){</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        }</span><br><span class="line">        DListNode* node = cache_map[key];</span><br><span class="line">        <span class="built_in">moveToHead</span>(node);</span><br><span class="line">        <span class="keyword">return</span> node-&gt;value;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(cache_map.<span class="built_in">contains</span>(key)){</span><br><span class="line">            DListNode* node = cache_map[key];</span><br><span class="line">            node-&gt;value = value;</span><br><span class="line">            <span class="built_in">moveToHead</span>(node);</span><br><span class="line">        }<span class="keyword">else</span>{</span><br><span class="line">            DListNode* newNode = <span class="keyword">new</span> <span class="built_in">DListNode</span>(key, value);</span><br><span class="line">            cache_map[key] = newNode;</span><br><span class="line">            <span class="built_in">addNodeToHead</span>(newNode);</span><br><span class="line">            <span class="keyword">if</span>(cache_map.<span class="built_in">size</span>()&gt;capacity){</span><br><span class="line">                DListNode* lruNode = tail-&gt;prev;</span><br><span class="line">                cache_map.<span class="built_in">erase</span>(lruNode-&gt;key);</span><br><span class="line">                <span class="built_in">removeNode</span>(lruNode);</span><br><span class="line">                <span class="keyword">delete</span> lruNode;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></table></figure></div> ## 其余 ### 递归</p>
<p>这里帮助大家确定下来递归算法的三个要素。每次写递归，都按照这三要素来写，可以保证大家写出正确的递归算法！</p>
<ul>
<li><p>确定递归函数的<strong>参数</strong>和<strong>返回值</strong>：
确定哪些参数是递归的过程中需要处理的，那么就在递归函数里加上这个参数，
并且还要明确每次递归的返回值是什么进而确定递归函数的返回类型。</p></li>
<li><p>确定<strong>终止条件</strong>： 写完了递归算法,
运行的时候，经常会遇到栈溢出的错误，就是没写终止条件或者终止条件写的不对，操作系统也是用一个栈的结构来保存每一层递归的信息，如果递归没有终止，操作系统的内存栈必然就会溢出。</p></li>
<li><p>确定<strong>单层递归的逻辑</strong>：
确定每一层递归需要处理的信息。在这里也就会重复调用自己来实现递归的过程。</p></li>
</ul>
<p>递归的实现就是：每一次递归调用都会把函数的局部变量、参数值和返回地址等压入调用栈中，然后递归返回的时候，从栈顶弹出上一次递归的各项参数，所以这就是递归为什么可以返回上一层位置的原因。</p>
<p>另一种算法, 回溯, 其实是递归的副产品，只要有递归就会有回溯。</p>
<p>递归时如果超时, 可能是递归时<strong>对某些元素重复计算</strong>了,
这时可以考虑用<strong>记忆化搜索</strong>(Memoization)来优化递归算法,
即可以用一个<strong>哈希表</strong>来<strong>缓存已经计算过的结果,</strong>
避免重复计算.</p>
<p>在函数的开始先检查哈希表中是否已经存在该结果,
如果存在则直接返回该结果, 否则继续计算并将结果存入哈希表中.</p>
<p>例如LeetCode 337</p>

		</div>

		

		
		<ul class="post-tags-box text-lg mt-1.5 flex-wrap justify-center flex md:hidden">
			
			<li class="tag-item mx-0.5">
				<a href="/tags/algorithms/">#algorithms</a>&nbsp;
			</li>
			
		</ul>
		

		

		
		<div class="article-nav my-8 flex justify-between items-center px-2 sm:px-6 md:px-8">
			
			<div class="article-prev border-border-color shadow-redefine-flat shadow-shadow-color-2 rounded-medium px-4 py-2 hover:shadow-redefine-flat-hover hover:shadow-shadow-color-2">
				<a class="prev" rel="prev" href="/2025/10/10/system/linux/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/%E9%AB%98%E5%B9%B6%E5%8F%91/Ractor/">
					<span class="left arrow-icon flex justify-center items-center">
						<i class="fa-solid fa-chevron-left"></i>
					</span>
					<span class="title flex justify-center items-center">
						<span class="post-nav-title-item truncate max-w-48">Ractor</span>
						<span class="post-nav-item">Prev posts</span>
					</span>
				</a>
			</div>
			
			
			<div class="article-next border-border-color shadow-redefine-flat shadow-shadow-color-2 rounded-medium px-4 py-2 hover:shadow-redefine-flat-hover hover:shadow-shadow-color-2">
				<a class="next" rel="next" href="/2025/10/09/algorithms/Coding%E6%8A%80%E5%B7%A7/%E7%BD%91%E6%A0%BC%E5%9B%BE/">
					<span class="title flex justify-center items-center">
						<span class="post-nav-title-item truncate max-w-48">网格图 DFS 与 BFS</span>
						<span class="post-nav-item">Next posts</span>
					</span>
					<span class="right arrow-icon flex justify-center items-center">
						<i class="fa-solid fa-chevron-right"></i>
					</span>
				</a>
			</div>
			
		</div>
		


		
	</div>

	
	<div class="toc-content-container">
		<div class="post-toc-wrap">
	<div class="post-toc">
		<div class="toc-title">On this page</div>
		<div class="page-title">Coding技巧</div>
		<ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE"><span class="nav-text">二分查找</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3"><span class="nav-text">滑动窗口</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%BA%E5%AE%9A%E9%95%BF%E5%BA%A6%E4%B8%8E%E5%8F%AF%E5%8F%98%E9%95%BF%E5%BA%A6%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3"><span class="nav-text">固定长度与可变长度滑动窗口</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9B%BA%E5%AE%9A%E9%95%BF%E5%BA%A6%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3"><span class="nav-text">固定长度滑动窗口</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B"><span class="nav-text">示例</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%AF%E5%8F%98%E9%95%BF%E5%BA%A6%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3"><span class="nav-text">可变长度滑动窗口</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9E%9A%E4%B8%BE%E6%8A%80%E5%B7%A7"><span class="nav-text">枚举技巧</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BA%8F%E5%88%97%E4%B8%8E%E5%8C%BA%E9%97%B4%E5%A4%84%E7%90%86-sequence-range-processing"><span class="nav-text">序列与区间处理
(Sequence &amp; Range Processing)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%89%8D%E7%BC%80%E5%92%8C"><span class="nav-text">前缀和</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%91%E4%B8%8A%E7%9A%84%E5%89%8D%E7%BC%80%E5%92%8C"><span class="nav-text">树上的前缀和</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B7%AE%E5%88%86%E6%95%B0%E7%BB%84"><span class="nav-text">差分数组</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%88"><span class="nav-text">栈</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%82%BB%E9%A1%B9%E6%B6%88%E9%99%A4-%E5%90%88%E6%B3%95%E6%8B%AC%E5%8F%B7%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-text">邻项消除 &amp; 合法括号字符串</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%95%E8%B0%83%E6%A0%88"><span class="nav-text">单调栈</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9F%BA%E7%A1%80%E5%AF%BB%E6%89%BE%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E6%9B%B4%E5%B0%8F%E5%85%83%E7%B4%A0-ngense"><span class="nav-text">1.
基础：寻找下一个更大&#x2F;更小元素 (NGE&#x2F;NSE)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%9B%E9%98%B6%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E7%9F%A9%E5%BD%A2%E9%9D%A2%E7%A7%AF"><span class="nav-text">2. 进阶：柱状图中的最大矩形面积</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%B4%A1%E7%8C%AE%E6%B3%95%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC%E4%B9%8B%E5%92%8C"><span class="nav-text">贡献法：子数组的最小值之和</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%80%E5%B0%8F%E5%AD%97%E5%85%B8%E5%BA%8F%E7%A7%BB%E6%8E%89-k-%E4%BD%8D%E6%95%B0%E5%AD%97"><span class="nav-text">最小字典序：移掉 K 位数字</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%98%9F%E5%88%97"><span class="nav-text">队列</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97"><span class="nav-text">单调队列</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A0%86"><span class="nav-text">堆</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#top-k-%E9%97%AE%E9%A2%98-%E7%AC%AC-k-%E5%B0%8F%E5%A4%A7"><span class="nav-text">Top-K 问题 &#x2F; 第 K 小&#x2F;大</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%B9%E9%A1%B6%E5%A0%86%E5%8A%A8%E6%80%81%E4%B8%AD%E4%BD%8D%E6%95%B0"><span class="nav-text">对顶堆（动态中位数）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%87%8D%E6%8E%92%E5%85%83%E7%B4%A0%E8%B4%AA%E5%BF%83"><span class="nav-text">重排元素（贪心）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%8D%E6%82%94%E5%A0%86%E5%8F%8D%E6%82%94%E8%B4%AA%E5%BF%83"><span class="nav-text">反悔堆（反悔贪心）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%93%BE%E8%A1%A8"><span class="nav-text">链表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%A4%E4%B8%AA%E9%BB%84%E9%87%91%E9%97%AE%E9%A2%98"><span class="nav-text">两个黄金问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%81%8D%E5%8E%86%E9%93%BE%E8%A1%A8"><span class="nav-text">遍历链表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8"><span class="nav-text">反转链表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#lru"><span class="nav-text">LRU</span></a></li></ol></li></ol>

	</div>
</div>
	</div>
	
</div>
			</div>

			
		</div>

		<div class="main-content-footer">
			<footer class="footer mt-5 py-5 h-auto text-base text-third-text-color relative border-t-2 border-t-border-color">
    <div class="info-container py-3 text-center">
        
            <div class="customize-info my-1">AI是新时代的灯塔</div>
        
        <div class="text-center">
            &copy;
            
              <span>2025</span>
              -
            
            2025&nbsp;&nbsp;<i class="fa-solid fa-heart fa-beat" style="--fa-animation-duration: 0.5s; color: #f54545"></i>&nbsp;&nbsp;<a href="/">ZaynPei</a>
            
                
                <p class="post-count space-x-0.5">
                    <span>
                        193 posts in total
                    </span>
                    
                        <span>
                            609.9k words in total
                        </span>
                    
                </p>
            
        </div>
        
        <div class="relative text-center lg:absolute lg:left-[20px] lg:top-1/2 lg:-translate-y-1/2 lg:text-left">
            <span class="lg:block text-sm">POWERED BY <?xml version="1.0" encoding="utf-8"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg class="relative top-[2px] inline-block align-baseline" version="1.1" id="圖層_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="1rem" height="1rem" viewBox="0 0 512 512" enable-background="new 0 0 512 512" xml:space="preserve"><path fill="#0E83CD" d="M256.4,25.8l-200,115.5L56,371.5l199.6,114.7l200-115.5l0.4-230.2L256.4,25.8z M349,354.6l-18.4,10.7l-18.6-11V275H200v79.6l-18.4,10.7l-18.6-11v-197l18.5-10.6l18.5,10.8V237h112v-79.6l18.5-10.6l18.5,10.8V354.6z"/></svg><a target="_blank" class="text-base" href="https://hexo.io">Hexo</a></span>
            <span class="text-sm lg:block">THEME&nbsp;<a class="text-base" target="_blank" href="https://github.com/EvanNotFound/hexo-theme-redefine">Redefine v2.8.5</a></span>
        </div>
        
        
            <div>
                Blog up for <span class="odometer" id="runtime_days" ></span> days <span class="odometer" id="runtime_hours"></span> hrs <span class="odometer" id="runtime_minutes"></span> Min <span class="odometer" id="runtime_seconds"></span> Sec
            </div>
        
        
            <script data-swup-reload-script>
                try {
                    function odometer_init() {
                    const elements = document.querySelectorAll('.odometer');
                    elements.forEach(el => {
                        new Odometer({
                            el,
                            format: '( ddd).dd',
                            duration: 200
                        });
                    });
                    }
                    odometer_init();
                } catch (error) {}
            </script>
        
        
            
                
        
                
        
        
    </div>  
</footer>
		</div>
	</div>

	
	<div class="post-tools">
		<div class="post-tools-container">
	<ul class="article-tools-list">
		<!-- TOC aside toggle -->
		
		<li class="right-bottom-tools page-aside-toggle">
			<i class="fa-regular fa-outdent"></i>
		</li>
		

		<!-- go comment -->
		
	</ul>
</div>
	</div>
	

	<div class="right-side-tools-container">
		<div class="side-tools-container">
	<ul class="hidden-tools-list">
		<li class="right-bottom-tools tool-font-adjust-plus flex justify-center items-center">
			<i class="fa-regular fa-magnifying-glass-plus"></i>
		</li>

		<li class="right-bottom-tools tool-font-adjust-minus flex justify-center items-center">
			<i class="fa-regular fa-magnifying-glass-minus"></i>
		</li>

		<li class="right-bottom-tools tool-dark-light-toggle flex justify-center items-center">
			<i class="fa-regular fa-moon"></i>
		</li>

		<!-- rss -->
		

		

		<li class="right-bottom-tools tool-scroll-to-bottom flex justify-center items-center">
			<i class="fa-regular fa-arrow-down"></i>
		</li>
	</ul>

	<ul class="visible-tools-list">
		<li class="right-bottom-tools toggle-tools-list flex justify-center items-center">
			<i class="fa-regular fa-cog fa-spin"></i>
		</li>
		
		<li class="right-bottom-tools tool-scroll-to-top flex justify-center items-center">
			<i class="arrow-up fas fa-arrow-up"></i>
			<span class="percent"></span>
		</li>
		
		
	</ul>
</div>
	</div>

	<div class="image-viewer-container">
	<img src="">
</div>

	
	<div class="search-pop-overlay">
	<div class="popup search-popup">
		<div class="search-header">
			<span class="search-input-field-pre">
				<i class="fa-solid fa-keyboard"></i>
			</span>
			<div class="search-input-container">
				<input autocomplete="off" autocorrect="off" autocapitalize="off" placeholder="Search..." spellcheck="false" type="search" class="search-input">
			</div>
			<span class="popup-btn-close">
				<i class="fa-solid fa-times"></i>
			</span>
		</div>
		<div id="search-result">
			<div id="no-result">
				<i class="fa-solid fa-spinner fa-spin-pulse fa-5x fa-fw"></i>
			</div>
		</div>
	</div>
</div>
	

</main>



<script src="/js/build/libs/Swup.min.js"></script>

<script src="/js/build/libs/SwupSlideTheme.min.js"></script>

<script src="/js/build/libs/SwupScriptsPlugin.min.js"></script>

<script src="/js/build/libs/SwupProgressPlugin.min.js"></script>

<script src="/js/build/libs/SwupScrollPlugin.min.js"></script>

<script src="/js/build/libs/SwupPreloadPlugin.min.js"></script>

<script>
    const swup = new Swup({
        plugins: [
            new SwupScriptsPlugin({
                optin: true,
            }),
            new SwupProgressPlugin(),
            new SwupScrollPlugin({
                offset: 80,
            }),
            new SwupSlideTheme({
                mainElement: ".main-content-body",
            }),
            new SwupPreloadPlugin(),
        ],
        containers: ["#swup"],
    });
</script>




	
<script src="/js/build/tools/imageViewer.js" type="module"></script>

<script src="/js/build/utils.js" type="module"></script>

<script src="/js/build/main.js" type="module"></script>

<script src="/js/build/layouts/navbarShrink.js" type="module"></script>

<script src="/js/build/tools/scrollTopBottom.js" type="module"></script>

<script src="/js/build/tools/lightDarkSwitch.js" type="module"></script>

<script src="/js/build/layouts/categoryList.js" type="module"></script>



    
<script src="/js/build/tools/localSearch.js" type="module"></script>




    
<script src="/js/build/tools/codeBlock.js" type="module"></script>




    
<script src="/js/build/layouts/lazyload.js" type="module"></script>




    
<script src="/js/build/tools/runtime.js"></script>

    
<script src="/js/build/libs/odometer.min.js"></script>

    
<link rel="stylesheet" href="/assets/odometer-theme-minimal.css">




  
<script src="/js/build/libs/Typed.min.js"></script>

  
<script src="/js/build/plugins/typed.js" type="module"></script>








    
<script src="/js/build/libs/anime.min.js"></script>





    
<script src="/js/build/tools/tocToggle.js" type="module" data-swup-reload-script=""></script>

<script src="/js/build/layouts/toc.js" type="module" data-swup-reload-script=""></script>

<script src="/js/build/plugins/tabs.js" type="module" data-swup-reload-script=""></script>




<script src="/js/build/libs/moment-with-locales.min.js" data-swup-reload-script=""></script>


<script src="/js/build/layouts/essays.js" type="module" data-swup-reload-script=""></script>





	
</body>

</html>